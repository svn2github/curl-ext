||| Maintained by: cwstern
{import CURL.DESKTOP.CLIPBOARD, using-name = "CLIPBOARD"}

{import * from CURL.LANGUAGE.REGEXP}
{import * from CURL.LANGUAGE.SOURCE}
{import InstanceMaker from CURL.LANGUAGE.REFLECTION}

{import * from CURL.UTIL.ELASTIC}
{import * from CURL.UTIL.OBSERVER}
{import * from CURL.UTIL.POINTER-TO}

{import * from CURL.DATA-ACCESS.BASE}

{import * from CURL.GRAPHICS.STANDARD}
{import CURL.GRAPHICS.WINDOW, using-name = "WINDOW"}

{import * from CURL.GUI.BASE}
{import * from CURL.GUI.IME}
{import * from CURL.GUI.TEXT-FORMATS}
{import * from CURL.GUI.CONTROL-BASE}
{import * from CURL.GUI.CONTROL-HELPERS}
||--{import * from COM.CURL.OPEN.GUI.CONTROL-LOGICAL, override? = true}
||--{import * from COM.CURL.OPEN.GUI.CONTROL-UI-GENERIC, override? = true}

|| From DisplayFrame.curl
{define-class package {DisplayFrame-of t:Type} 
  {inherits BaseFrame} 

  field private _contents:#t = null
  field private _display?:bool = true

  {constructor package {default 
                           contents:#t = null, 
                           display?:bool=true,
                           ...
                       }
    {construct-super ...}
    set self.display? = display?
    set self.contents = contents
  }

  {getter package {contents}:#t {return self._contents}}
  {setter package {contents value:#t}:void
    {if value != self._contents then
        set self._contents = value
        {self.clear}
        {if-non-null value then
            {if self.display? then
                {self.add-internal value}
            }
        }
    }
  }

  {getter package {display?}:bool {return self._display?}}
  {setter package {display? value:bool}:void
    {if value != self._display? then
        set self._display? = value
        {if not value then
            {self.clear}
         else
            {if-non-null con = self._contents then
                {self.add-internal con}
            }
        }   
    }   
  }
}


||||||||||||||||||||||||||||||||||||||||||||||||
|| SkinnableRecordGridUI
||
||
|| Notes:
|| - Currently left button pointer-release stands
||   in as "click" for selection.
||||||||||||||||||||||||||||||||||||||||||||||||||
{doc-next
    {purpose
        The skinnable UI delegate for {docref RecordGrid}.
    }
    {details
        This {docref RecordGridUI} subclass will attempt to use subclasses
        of {docref StandardRecordGridCell} when creating new
        {docref RecordGridCell}s, although this can be overridden through
        the {docref RecordGridOptions.cell-spec} option as usual. 
        Although any {docref RecordGridCell} can be used,
        {docref StandardRecordGridCell} and its standard subclasses
        have additional display and user gesture handling code which
        results in a more fully-featured UI experience.
        If {docref StandardRecordGridCell}s and
        non-{docref StandardRecordGridCell}s are mixed together,
        keyboard or mouse navigation can become uneven. For
        maximum consistency, the use of only subclasses of
        {docref StandardRecordGridCell} is recommended.
        
        This class attempts to optimize performance by reusing
        {docref RecordGridCell}s when possible. Because of this, cells
        used by this class should attempt to avoid storing excessive
        state, and all such state should be validated or refreshed when
        {docref RecordGridCell.refresh-data} is called.
    }
    {notes
        Unlike most subclasses of {docref SkinnableControlUI}, this
        class directly adds tagged child {docref Graphic}s
        to its graphic hierarchy, a task normally left to attached
        {docref ControlSkin}s. Directly mutating the graphical hierarchy
        under this {docref Graphic} may have negative side effects
        and should be avoided.
    }
    {since 7.0}
}
{define-class public open ProtoSkinnableRecordGridUI
  {inherits RecordGridUI, ScrollerInterface, SkinnableControlUI}
  
  || Class constants.
  let package constant column-drag-delta:Distance = 2mm
  let package constant default-column-width:Elastic = 
      {dimension-to-elastic 3cm}
  let package constant row-selector-width:Distance = 0.4cm

  || Internal structures. Package access for SkRGInternalGrid.
  field package constant _col-layouts:SkRGColumnLayouts
  field package-get private-set _row-selectors?:bool
  field package-get private-set _data-epoch:int = 1
  field package-get private-set _data-row-count:int = 0
  field package-get private-set _display-filler-column?:bool 
  
  || Freeze frame state.
  || Copied from RecordGrid because they need to be queried frequently,
  || and so that we can remember the old values when changed.
  field package frozen-row-count:int = 0
  field package frozen-row-start:int = 0
  field package frozen-col-count:int = 0
  field package frozen-col-start:int = 0
  
  || Internal graphical structures.
  field private _grid-background:#Background = null
  field package constant _internal-grid:SkRGInternalGrid 
  field private constant _navigation-panel:{DisplayFrame-of 
                                             RecordSetDisplayNavigationPanel}
  field private constant _hscroll:{DisplayFrame-of Scrollbar}
  field package constant _vscroll:{DisplayFrame-of Scrollbar}
  field private constant _data-rows:{HashTable-of int, SkRGDataRow}
  field private constant _cached-data-rows:{Array-of SkRGDataRow}
  field package _header-rows:{Array-of SkRGBaseHeaderRow}
  field private constant _cached-cells:{HashTable-of
                                         RecordGridColumn,
                                         {Array-of RecordGridCell}
                                       }
  || Columns that need their cell caches flushed.
  field constant private _column-caches-to-flush:{Set-of RecordGridColumn}
  
  || Operational flag. True when scrollbars are being updated.
  field private _synchronizing-scrollbars?:bool = false
  || The cached width of this object.
  field private _cached-width:Distance = 0cm
  || Scroll event flag. True when there is an Adjustment event in the
  || queue and not yet handled.
  field private _scroll-adjustment-pending?:bool = false
  field private _hscroll-toggle-cnt:int = 0
  field private _vscroll-toggle-cnt:int = 0

  || If false, then set grid focus to null when we change current record.
  || If true, then attempt to move grid focus within the currect column.
  field package _adjust-record-focus?:bool = true
  
  || Scrolling/Paging State
  || The first data row visible at the top of the display.
  field private _first-visible-row:int = 0
  || The first potentially scrollable, visible data row.
  field private _first-scrollable-row:int = 0
  || The faux vertical scroll position. 1cm == one data row.
  field private _vertical-position:Distance = 0cm
  field package _disable-vscroll?:bool
  field package _disable-hscroll?:bool
  
  || All BRGCs by group depth. Primary use: creating shared headers.
  field constant package _column-layer-map:{Array-2-of #SkRGHeaderMapElement}
  
  || BUG: 26729: used to mark the duration of certain calls as unsafe
  || for first-scrollable-row set operations. 
  field private _safe-to-set-fsr?:bool = true
    
  {doc-next 
    {purpose
        Construct this object.
    }
    {parameter control-skin,
        The {docref RecordGridSkin} for this control UI.
    }
    {parameter control-feel,
        The {docref RecordGridFeel} for this control UI.
    }
    {parameter ..., 
        Option settings are passed along to the base class.
    }
    {since 7.0}
  }
  {constructor public {default
                          control-skin:#ProtoRecordGridSkin = null,
                          control-feel:#ProtoRecordGridFeel = null,
                          ...
                      }
    set self.hstretch? = true
    set self.vstretch? = true

    
    || Initialize constant structures
    set self._internal-grid = {SkRGInternalGrid self}
    set self._col-layouts = {SkRGColumnLayouts self, self._internal-grid}
    set self._data-rows = {{HashTable-of int, SkRGDataRow}}
    set self._cached-data-rows = {{Array-of SkRGDataRow}}
    set self._cached-cells = {{HashTable-of
                                  RecordGridColumn,
                                  {Array-of RecordGridCell}
                              }}
    set self._column-caches-to-flush = {new {Set-of RecordGridColumn}}
    set self._header-rows = {{Array-of SkRGBaseHeaderRow}}
    
    set self._column-layer-map = 
        {new {Array-2-of #SkRGHeaderMapElement}, 0, 0}
    
    set self._navigation-panel =
        {{DisplayFrame-of RecordSetDisplayNavigationPanel}}
    set self._navigation-panel.test-name = "CurlSRGUINavPanel" ||""
    set self._navigation-panel.test-parent? = true
    set self._navigation-panel.active-traversal-container = null
        
    let sb:Scrollbar =
        {Scrollbar
            test-name = "Curl-srgui-horizontal-scrollbar", ||""
            direction = Orientation.horizontal,
            quantized? = true,
            blocksize = 1,
            unitsize = 0.1,
            {on ad:Adjustment at sb:Scrollbar do
                {if not ad.consumed? and 
                    not self._synchronizing-scrollbars? and
                    not self._scroll-adjustment-pending? 
                 then
                    set self._scroll-adjustment-pending? = true
                    {after 0s do
                        set self.horizontal-position =
                            {sb.get-scroll-value} * 1cm
                        set self._scroll-adjustment-pending? = false
                    }
                    {ad.consume}
                }
            }
        }
    set sb.multi-unit-scroll? = true
    set self._hscroll = {{DisplayFrame-of Scrollbar} contents = sb}
    
    || Since we don't want the horizontal scrollbar to stretch vertically,
    || we put its DisplayFrame in with something that can.
    let constant hscroll-box:VBox =
        {VBox
            hstretch? = true,
            {Fill height = 3px},
            self._hscroll,
            {Fill}
        }
    
    set sb = {Scrollbar 
            test-name = "Curl-srgui-vertical-scrollbar", ||""
                 direction = Orientation.vertical,
                 quantized? = true,
                 blocksize = 1,
                 unitsize = 1,
                 {on ad:Adjustment at sb:Scrollbar do
                     {if not ad.consumed? and 
                         not self._synchronizing-scrollbars? and
                         not self._scroll-adjustment-pending?
                      then
                         set self._scroll-adjustment-pending? = true
                         {after 0s do
                             set self.vertical-position =
                                 {sb.get-scroll-value} * 1cm
                             set self._scroll-adjustment-pending? = false
                             {self.adjust-followers {sb.get-scroll-value} * 1cm}
                         }
                         {ad.consume}
                     }
                 }
             }
    set sb.multi-unit-scroll? = true
    set self._vscroll = {{DisplayFrame-of Scrollbar} contents = sb}
    
    {construct-super.SkinnableControlUI control-skin, control-feel}
    
    || Options
    || all sub-controls should lookup options from main control-ui.
    set self.control-appearance-changeable? = true
||--    set self.width = 10cm 
||--    set self.height = 10cm 
    {self.copy-options.insert "skin"} ||""
    {self.copy-options.insert "focus-skin"} ||""    
    
    || Layout internals

    || FIXME: style-element should eventually refer to the SRGInternalGrid.
    let g:Grid = {Grid _style-element = "RecordGrid/internal-grid"} ||""
    
    let vf1:GridFiducial = {g.make-fiducial orientation = Orientation.vertical}
    let vf2:GridFiducial = {g.make-fiducial orientation = Orientation.vertical}
    let hf:GridFiducial = {g.make-fiducial orientation = Orientation.horizontal}
    
    {g.add
        self._internal-grid, 
||PROTO
||--        left = {g.left}, top = {g.top}, right = vf2, bottom = hf
        left = {g.left}, top = {g.top}, right = vf2, bottom = {g.bottom}
    }

    {g.add 
        self._navigation-panel, 
        left = {g.left}, top = hf, right = vf1, bottom = {g.bottom}
    } 

    ||PROTO: no horizontal scrolling when embedded
    {g.add 
        hscroll-box, 
        left = vf1, top = hf, right = vf2, bottom = {g.bottom} 
    }
    {g.add 
        self._vscroll,
||--        left = vf2, top = {g.top}, right = {g.right}, bottom = hf
        left = vf2, top = {g.top}, right = {g.right}, bottom = {g.bottom}
    }
                     
    || NOTE: unlike other SkinnableControlUIs, we directly add the
    || tagged child here, because of uncorrected legacy behaviors.
    {self.add-internal g}
    {self.set-tagged-content "internal-grid", g} ||""
    
  }
  
  ||-----------------------------------------------
  || Methods for communication with control
  ||-----------------------------------------------

  {method protected open {create-default-control-skin}:ControlSkin
    {return {ProtoRecordGridSkin}}
  }
  
  {method protected open {create-default-control-feel}:ControlFeel
    {return {ProtoRecordGridFeel}}
  }

  {setter public open {control val:Control}:void
    set super.control = val
    {self.note-columns-collection-changed}
    {self.note-control-changed}
  }
  
  {getter public open {selecting?}:bool
    {return self._internal-grid.selecting?}
  }
  
  {getter public open {slide-grid-focus-on-record-change?}:bool
    {return self._adjust-record-focus?}
  }
  {setter public open {slide-grid-focus-on-record-change? b:bool}:void
    set self._adjust-record-focus? = b
  }
  
  {method public open {note-record-set-event ev:RecordSetEvent}:void
    {type-switch ev
     case ev:RecordFieldsChanged do
        || FIXME: this case might be covered by note-columns-collection-changed
        {self.rebuild-column-header-map}
        {self.destroy-all-rows}
        {self.react-to-state-change}
     case ev:RecordsChanged do
        {self.increment-data-epoch}
        {self.resize-data-rows}
    }
    
    {self._internal-grid.refresh-display}    
  }
  
  {method public open {note-current-record-changed}:void
    {super.note-current-record-changed}
    
    let grid:RecordGrid = self.grid
    let curr:int = grid.current-index

    || Adjust focus cell, if necessary. If there is no selection, 
    || we can just shift the focused cell up or down to the current record.
    {if grid.selection.empty? then
        let col-index:int = {if grid.columns.size > 0 then 0 else -1}
        
        set col-index = -1
        
        {if-non-null rgc = self.grid-focus then
            set col-index = {self.get-cell-column rgc}
        }

        {if self._adjust-record-focus? and
            curr != -1 and 
            col-index != -1 
         then
            {self.set-grid-focus {self.get-data-row curr}[col-index]}
         else
            {self.set-grid-focus null}
        }
     else
        {self.set-grid-focus null}
    }
    
    {self.scroll-to-reveal row-index = curr}
    
    {self._internal-grid.refresh-display}
  }

  {method public open {note-columns-collection-changed}:void
    {self.rebuild-column-header-map}
    || Mark columns removed from the RG for removal from the cache.
    {for one-col in {self._cached-cells.keys-to-Iterator} do
        {if {self.grid.columns.find one-col} == -1 then
            {self._column-caches-to-flush.insert one-col}
        }
    }
    || BUG 26729: do not induce layout before column layouts are refreshed.
    {with self._safe-to-set-fsr? = false do
        {self.destroy-all-rows} 
    }
    {self._col-layouts.note-column-collection-changed}
    {self._internal-grid.refresh-display}
  }
  
  {method public open {note-column-changed 
                          column:BaseRecordGridColumn,
                          property-name:String
                      }:void    
    
    {if column.grid != self.grid then {return}}
    
    || Ignore notifications when a column change is pending,
    || except do mark cell caches that will need clearing.
    {if self.grid.column-change-pending? then
        {switch property-name
         case "cell-spec", "" do ||""
            {type-switch column
             case rgc:RecordGridColumn do
                {self._column-caches-to-flush.insert rgc}
            }
        }
        {return}
    }
    
    || Update cells
    {switch property-name
        
     case "width" do ||""
        || If the width is being changed by a column adjustment gesture,
        || do nothing. Otherwise trigger a layout.
        {type-switch column
         case rgc:RecordGridColumn do
            let i:int = self._internal-grid._resize-col
            {if i != -1 and self.grid.columns[i] == rgc then
                {return}
            }
        }
        {self._col-layouts.layout-columns}
        
     case "cell-spec", "" do ||""
        {type-switch column
         case rgc:RecordGridColumn do
            {self._column-caches-to-flush.insert rgc}
            {self.destroy-all-rows}
         case rgcg:RecordGridColumnGroup do
            {self.destroy-all-rows}
        }
            
     case "background", "enclose-header-label?" do ||""
        {self._internal-grid.request-draw}
        
     case "halign", "valign" do ||""
        {type-switch column
         case rgc:RecordGridColumn do
            {if-non-null header-row = {self.get-header-row 0} then
                let constant col-index:int = {self.grid.columns.find rgc}
                {if col-index != -1 then 
                    {header-row[col-index].ensure-valid}
                }
            }
         case column-group:RecordGridColumnGroup do
            {if not column-group.has-concrete-child-column? then {return}}
            {if-non-null header-row = {self.get-header-row 0} then
                {for i = column-group.first-column-index to
                    column-group.last-column-index
                 do
                    {header-row[i].ensure-valid}                    
                }
                || Not fully efficient, but safe.
                {for layer = 1 to self.grid.max-column-depth do
                    {self._header-rows[layer].ensure-valid}
                }
            }
        }
        
     case "header-spec" do ||""
        {self.note-column-header-spec-changed column}
    }
  }
  
  || Broken out from note-column-changed for being large.
  {method private {note-column-header-spec-changed
                      column:BaseRecordGridColumn
                  }:void

    {if-non-null header-row = {self.get-header-row 0} then
        
        let constant grid:RecordGrid = self.grid
    
        {type-switch column
            
         case rgc:RecordGridColumn do
            let constant col:int = {grid.columns.find rgc}
            {if col != -1 then
                let constant new-selector:SkRGColumnSelector =
                    {SkRGColumnSelector rgc}
                {header-row[col].replace-with new-selector}
                {new-selector.ensure-valid}
            }

         case rgcg:RecordGridColumnGroup do
            {if not rgcg.has-concrete-child-column? then {return}}

            || Reset the appropriate concrete column headers.
            {for col = rgcg.first-column-index to rgcg.last-column-index do
                let constant new-selector:SkRGColumnSelector =
                    {SkRGColumnSelector grid.columns[col]}
                {header-row[col].replace-with new-selector}
                {new-selector.ensure-valid}
            }
            
            || Reset the appropriate shared column headers.
            let constant layer:int =
                grid.max-column-depth - column.column-depth
            {for one-header in 
                (self._header-rows[layer] asa SkRGSharedHeaderRow) 
             do
                let constant group:RecordGridColumnGroup = 
                    one-header.column-group
                {if group.first-column-index != -1 and
                    (group.first-column-index <= rgcg.last-column-index and
                     group.first-column-index >= rgcg.last-column-index) or
                    (group.last-column-index >= rgcg.first-column-index and
                     group.last-column-index <= rgcg.last-column-index) or
                    (group.first-column-index < rgcg.first-column-index and
                     group.last-column-index > rgcg.last-column-index)
                 then
                    let constant new-header:SkRGSharedColumnHeader =
                        {SkRGSharedColumnHeader group}
                    {one-header.replace-with new-header}
                    {new-header.ensure-valid}
                    
                 elseif group.first-column-index > rgcg.last-column-index then
                    {break}
                }
            }
        }
    }
  }

  {method public open {note-row-options-changed
                          row:RecordGridRowOptions,
                          property-name:String
                      }:void
    {if row == self.grid.header-options then
        
        || 1) bulk change, destroy header and rebuild with proper options
        {if property-name.empty? and 
            not self._header-rows.empty? 
         then
            {self._header-rows.clear}
            {self._internal-grid.refresh-display}
            {return}
        }

        || 2) non-local option change, synchronize trampolined value
        let non-local-handled?:bool = false
        {for hr in self._header-rows do
            {if-non-null hr-key = {hr.name-to-option-key 
                                      property-name, 
                                      error-if-missing? = false
                                  }
             then
                set non-local-handled? = true
                let constant row-key:OptionKey = 
                    {non-null {row.name-to-option-key property-name}}
                let constant (item:#OptionItem, local?:bool) = 
                    {row.option-lookup-here row-key, true}  
                {if not local? then
                    {if-non-null item then
                        {hr.set-option-by-name property-name, item.value}
                     else
                        {hr.unset-option-by-name property-name}
                    }
                }
            }
        }
        {if non-local-handled? then {return}}
        
        || 3) Special local options that are pulled or need to be refreshed
        {if (property-name == "valign" or ||""
             property-name == "halign" or ||""
             property-name == "background") ||""
         then
            {for hr in self._header-rows do 
                {hr.ensure-valid}
            }
            {self.request-layout}
            {return}
        }
    }
  }

  {method public open {note-frozen-count-changed}:void
    
    || 0) Setup
    
    let constant grid:RecordGrid = self.grid
    
    let constant old-frozen-row-count:int = self.frozen-row-count
    let constant old-frozen-col-count:int = self.frozen-col-count
    let constant old-frozen-row-start:int = self.frozen-row-start
    let constant old-frozen-col-start:int = self.frozen-col-start
    
    || 1) Preliminary steps -- before internal state is updated.
    
    {if grid.frozen-column-count != old-frozen-col-count or
        grid.frozen-column-start != old-frozen-col-start
     then
        set self._col-layouts.offset = 0cm
    }

    || 2) Set and handle rows.
    
    set self.frozen-row-count = grid.frozen-row-count
    set self.frozen-row-start = grid.frozen-row-start
    
    {if self.frozen-row-count != old-frozen-row-count or
        self.frozen-row-start != old-frozen-row-start
     then
        set self.first-scrollable-row = 
            self.frozen-row-count + self.frozen-row-start
        {self._internal-grid.refresh-display}
        {self.scroll-to-reveal row-index = grid.current-index}
    }
    
    || 3) Set and handle columns.
    
    set self.frozen-col-count = grid.frozen-column-count
    set self.frozen-col-start = grid.frozen-column-start

    {if self.frozen-col-count != old-frozen-col-count or
        self.frozen-col-start != old-frozen-col-start
     then
        {for one-row in self._data-rows do
            {one-row.note-frozen-column-count-changed}
        }
        {for one-header-row in self._header-rows do
            {one-header-row.note-frozen-column-count-changed}
        }
        {self._col-layouts.recompute-column-flags}
        {self._col-layouts.layout-columns}
    }
    
  }

  {method public open {react-to-state-change}:void
    
    || 0) Ensure rows are properly initialized
    {self.resize-data-rows}
    
    || 1) Destroy rows if presence of row selectors changed
    {if self.grid.display-record-selectors? != self._row-selectors? then     
        set self._row-selectors? = self.grid.display-record-selectors?
        {self.destroy-all-rows}
        {self._col-layouts.layout-columns}
    }
    
    || 2) Reexamine nav-panel
    {if self.grid.display-navigation-panel? and
        self._navigation-panel.contents == null
     then
        set self._navigation-panel.contents = 
            {RecordSetDisplayNavigationPanel self.grid}
     elseif not self.grid.display-navigation-panel? and
        self._navigation-panel.contents != null 
     then
        set self._navigation-panel.contents = null
    }    

    set self._display-filler-column? = self.grid.display-filler-column? 

    || 3) Sync background 
    set self._grid-background = self.grid.background
    {self.synchronize-internal-background}
    
    || 4) Trigger synchronization
    {self._internal-grid.refresh-display} 
    
    {self.control-skin.react-to-state-change}
    {self.control-feel.react-to-state-change}
  }
  
  {method public open {react-to-visual-change}:void
    {super.react-to-visual-change}
    {self.control-skin.react-to-visual-change}
  }

  {method public open {grid-objects-at 
                          x:Distance,
                          y:Distance
                      }:(cell:#RecordGridCell,
                         record-index:int,
                         column-index:int
                        )
    let constant (xt:Distance, yt:Distance, valid?:bool) =
        {transform-coordinates-with-test
            x, y,
            self, self._internal-grid
        }
    {if not valid? then {return null, -1, -1}}
    let constant (target:Graphic, record-index:int, column-index:int) =
        {self._internal-grid.map-point xt, yt}
    {return
        {type-switch target
         case rgc:RecordGridCell do
            rgc 
         else
            null
        },
        record-index, 
        column-index
    }
  }

  {method public open {context-menu-at
                          x:Distance,
                          y:Distance
                      }:#MenuPane
    
    let constant grid:RecordGrid = self.grid
    let constant dr:RecordView = grid.records
    
    let constant (cell:#RecordGridCell, rec:int, col:int) =
        {self.grid-objects-at x, y}
    
    let constant mp:MenuPane = {MenuPane}
    
    let constant selection-empty?:bool = grid.selection.empty?

    || Copy
    let copy-enabled?:bool = false
    let copy-set?:bool = false
    {if not selection-empty? then
        || When there's a selection, present a RecordGridCopy.
        {if-non-null copy-command = {grid.get-command "copy"} then ||""
            {if-non-null copy-impl = copy-command.impl then
                set copy-enabled? = copy-impl.enabled?
            }
        }
        {mp.add
            {MenuAction
                label = {hlmessage Copy},
                enabled? = copy-enabled?,
                {on Action do
                    {grid.do-command
                        "copy", ||""
                        throw-exception-on-failure? = false
                    }
                }
            }
        }
        set copy-set? = true
        
     elseif cell != null then
        || If cell is a SBESC, then try to get a CopyCommand
        || off of its editor.
        {type-switch cell
         case edit-cell:StandardBaseEditableStringCell do
            {if edit-cell.edit-active? then
                {type-switch edit-cell.current-editor
                 case command-context:CommandContext do
                    {if-non-null copy-command =
                        {command-context.get-command "copy"} ||""
                     then
                        {if-non-null copy-impl = copy-command.impl then
                            set copy-enabled? = copy-impl.enabled?
                        }
                    }
                    {mp.add
                        {MenuAction
                            label = {hlmessage Copy},
                            enabled? = copy-enabled?,
                            {on Action do
                                {command-context.do-command
                                    "copy", ||""
                                    throw-exception-on-failure? = false
                                }
                            }
                        }
                    }
                    set copy-set? = true
                }
            }
        }
        
        || Otherwise, just present a direct copy to clipboard from the
        || cell's formatted data, not using any Commands.
        {if not copy-set? then
            {mp.add
                {MenuAction
                    label = {hlmessage Copy},
                    {on Action do
                        {{CLIPBOARD.Clipboard.get-system-clipboard}.set-string
                            {{non-null cell}.get-formatted-data}
                        }
                    }
                }
            }
            set copy-set? = true
        }
    }
    
    || Paste
    let paste-set?:bool = false
    let paste-enabled?:bool = false
    {if cell != null then
        || If cell is a SBESC, then try to get a PasteCommand
        || off of its editor.
        {type-switch cell
         case edit-cell:StandardBaseEditableStringCell do
            || Only advance if the cell is in edit mode; otherwise
            || we should try for a block paste.
            {if edit-cell.edit-active? then
                {type-switch edit-cell.current-editor
                 case command-context:CommandContext do
                    {if-non-null paste-command =
                        {command-context.get-command "paste"} ||""
                     then
                        {if-non-null paste-impl = paste-command.impl then
                            set paste-enabled? = paste-impl.enabled?
                        }
                    }
                    {mp.add
                        {MenuAction
                            label = {hlmessage Paste},
                            enabled? = paste-enabled?,
                            {on Action do
                                {command-context.do-command
                                    "paste", ||""
                                    throw-exception-on-failure? = false
                                }
                            }
                        }
                    }
                    set paste-set? = true
                }
            }
        }
    }
    
    || Try to present a RecordGridPaste.
    {if not paste-set? and
        (not selection-empty? or
         cell != null)
     then
        {if-non-null paste-command = {grid.get-command "paste"} then ||""
            {if-non-null paste-impl = paste-command.impl then
                set paste-enabled? = paste-impl.enabled?
            }
        }
        {mp.add
            {MenuAction
                label = {hlmessage Paste Region},
                enabled? = paste-enabled?,
                {on Action do
                    {grid.do-command
                        "paste", ||""
                        throw-exception-on-failure? = false
                    }
                }
            }
        }
        set paste-set? = true
    }
    
    || Otherwise, if cell is non-null, insert a null Paste item.
    {if not paste-set? and
        cell != null
     then
        {mp.add
            {MenuAction
                label = {hlmessage Paste},
                enabled? = false
            }
        }
        set paste-set? = true
    }
    
    {if copy-set? or paste-set? then
        {mp.add {menu-separator}}        
    }

    let any-frozen-ops?:bool = false
    
    {if not grid.frozen? and
        (rec >= 0 or col >= 0)
     then
        
        let constant frozen-row-count:int =
            {if rec == -1 then
                0
             else
                rec - self.first-visible-row
            }
        let constant frozen-row-start:int =
            {if rec == -1 then
                0
             else
                rec - frozen-row-count
            }
        
        let frozen-col-start:int = 0

        || Find the first column displayed, and then round for whether it's
        || more or less than half unclipped.
        {for one-layout key i in self._col-layouts do
            {if one-layout.ui-rextent > 0m then
                {if one-layout.ui-rextent + one-layout.ui-lextent > 0m then
                    set frozen-col-start = i
                 else
                    set frozen-col-start = i + 1
                }
                {break}
            }
        }

        let constant frozen-col-count:int =
            {if col == -1 then
                0
             else
                col - frozen-col-start
            }

        {if rec >=0 and col >= 0 then
            {mp.add
                {MenuAction
                    label = {hlmessage Freeze Frame},
                    enabled? = (frozen-row-start != 0 or
                                frozen-row-count != 0 or
                                frozen-col-start != 0 or
                                frozen-col-count != 0),
                    {on Action do
                        {grid.set-frozen-region 
                            frozen-row-count, 
                            frozen-col-count,
                            row-start = frozen-row-start,
                            column-start = frozen-col-start
                        }
                    }
                }
            }       
            set any-frozen-ops? = true
            
        }
        
        {if col >= 0 and rec == -1 then
            {mp.add
                {MenuAction
                    label = {hlmessage Freeze Column},
                    enabled? = (col != -1 or
                                frozen-col-start != 0),
                    {on Action do
                        {grid.set-frozen-region 
                            0, 
                            frozen-col-count + 1,
                            row-start = 0,
                            column-start = frozen-col-start
                        }
                    }
                }
            }       
            set any-frozen-ops? = true
        }
        
        {if rec >= 0 and col == -1 then
            {mp.add
                {MenuAction
                    label = {hlmessage Freeze Row},
                    enabled? = (rec != -1 or
                                frozen-row-start != 0),
                    {on Action do
                        {grid.set-frozen-region 
                            frozen-row-count + 1,
                            0,
                            row-start = frozen-row-start,
                            column-start = 0
                        }
                    }
                }
            }       
            set any-frozen-ops? = true
        }
    }
        
    {if grid.frozen? then
        {mp.add
            {MenuAction
                label = {hlmessage Unfreeze},
                {on Action do
                    {grid.unset-frozen-region}
                }
            }
        }                
        set any-frozen-ops? = true
    }
    
    {if any-frozen-ops? then
        {mp.add {menu-separator}}
    }
    
    || Sorts
    let sort-section?:bool = false
    {if col != -1 then
        set sort-section? = true
        let column:RecordGridColumn = grid.columns[col]
        {if column.field != null and column.sort-spec != null then
            {mp.add 
                {MenuAction
                    label = {hlmessage Sort Ascending},
                    {on Action do
                        set grid.sort = {RecordGridColumnSort column, true}
                    }
                }
            }
            {mp.add 
                {MenuAction
                    label = {hlmessage Sort Descending},
                    {on Action do
                        set grid.sort = {RecordGridColumnSort column, false}
                    }
                }
            }
        }
    }

    {if grid.sort != null then
        set sort-section? = true
        {mp.add
            {MenuAction
                label = {hlmessage Default Sort},
                {on Action do
                    set grid.sort = null
                }
            }
        }
    }

    {if sort-section? then
        {mp.add {menu-separator}}
    }
    
    || Filters
    {if-non-null cell then
        {if-non-null filter-array = {self.context-filters-at-cell cell} then
            {for one-filter in filter-array do
                {mp.add one-filter}
            }
        }
    }
    
    {mp.add
        {MenuAction 
            label = {hlmessage Remove Filters},
            enabled? = (dr.filter != null),
            {on Action do
                {self.note-filter-changing}
                set dr.filter = null
            } 
        }
    }

    ||-- Allow user to null out nullable fields.  
    {if cell != null and cell.can-update? then
        {if-non-null field = cell.field then
            {if field.nullable? then
                let (data:any, valid?:bool) = {cell.get-data}
                {if valid? then
                    {mp.add {menu-separator}}
                    {mp.add
                        {MenuAction
                            label = {hlmessage Unset Value},
                            enabled? = (data != null),
                            {on Action do
                                {cell.update-data null}
                            }
                        }
                    }
                }
            }
        }
    }
    
    ||-- Commit, revert
    {if grid.editable? and
        grid.records.modifiable?
     then
        
        {mp.add {menu-separator}}
        {mp.add
            {MenuAction 
                label = {hlmessage Commit Changes},
                bound-command = {self.grid.get-command "commit"} ||""
            }
        }
        {mp.add
            {MenuAction 
                label = {hlmessage Revert Changes},
                bound-command = {self.grid.get-command "revert"} ||""
            }
        }
    }
    {return mp}
  }
  
  || Create the filters submenu.
  {method private {context-filters-at-cell
                      cell:RecordGridCell
                  }:#{Array-of MenuItem}
    
    {if cell.field == null then {return null}}
    
    let constant (data:any, valid?:bool) = {cell.get-data}
    let constant (f-data:String, f-valid?:bool) = {cell.get-formatted-data}
    
    {if not valid? or not f-valid? then {return null}}
    
    let constant grid:RecordGrid = self.grid
    let constant record-view:RecordView = grid.records
    let item-array:{Array-of MenuItem} = {new {Array-of MenuItem}}
    
    let constant display-string:String =
        {if f-data == "" then ||""
            {hlmessage <blank>}
         else
            f-data
        }
        
    || Filter for X
    {item-array.append
        {MenuAction 
            label = 
                {hlmessage 
                    comment = 
                        {message
                            Appears in the default context menu 
                            for a RecordGridCell.  For example,
                            if the cell contains the data 'monday',
                            the user sees 'monday only'.
                        },
                    Filter for {value display-string} only
                } asa Visual, || Force conversion to Visual, not Label
            enabled? = not cell.pending-value?,
            {on Action do
                let constant rd:RecordData = {RecordData}
                set rd[cell.field.name] = data
                let constant new-fil:RecordFilter = rd
                {self.note-filter-changing}
                set record-view.filter =
                    {if-non-null fil = record-view.filter then
                        {RecordFilter.logical-and fil, new-fil}
                     else
                        new-fil
                    }
            } 
        }
    }
    
    {type-switch data
        
     case b:bool do
        || Do not add additional filters for boolean; only two states.
     else
        || Filter for X and below
        {item-array.append
            {MenuAction 
                label = 
                    {hlmessage 
                        comment = 
                            {message
                                Appears in the default context menu 
                                for a RecordGridCell.  For example,
                                if the cell contains the data 'monday',
                                the user sees 'monday and below'.
                            },
                        Filter for {value display-string} and below
                    } asa Visual, || Force conversion to Visual, not Label
                enabled? = not cell.pending-value?,
                {on Action do
                    let constant new-fil:RecordFilter =
                        {RecordFilter
                            {proc {r:Record}:bool
                                {return
                                    {r.compare-field 
                                        cell.field.name, 
                                        data
                                    } <= 0
                                }
                            }
                        }
                    {self.note-filter-changing}
                    set record-view.filter =
                        {if-non-null fil = record-view.filter then
                            {RecordFilter.logical-and fil, new-fil}
                         else
                            new-fil
                        }
                } 
            }
        }
        
        || Filter for X and above
        {item-array.append
            {MenuAction 
                label = 
                    {hlmessage 
                        comment = 
                            {message
                                Appears in the default context menu 
                                for a RecordGridCell.  For example,
                                if the cell contains the data 'monday',
                                the user sees 'monday and above'.
                            },
                        Filter for {value display-string} and above
                    } asa Visual, || Force conversion to Visual, not Label
                enabled? = not cell.pending-value?,
                {on Action do
                    let constant new-fil:RecordFilter =
                        {RecordFilter
                            {proc {r:Record}:bool
                                {return
                                    {r.compare-field 
                                        cell.field.name, 
                                        data
                                    } >= 0
                                }
                            }
                        }
                    {self.note-filter-changing}
                    set record-view.filter =
                        {if-non-null fil = record-view.filter then
                            {RecordFilter.logical-and fil, new-fil}
                         else
                            new-fil
                        }
                } 
            }
        }
    }
    
    || Filter out X
    {item-array.append
        {MenuAction 
            label = 
                {hlmessage 
                    comment = 
                        {message
                            Appears in the default context menu 
                            for a RecordGridCell.  For example,
                            if the cell contains the data 'monday',
                            the user sees 'not monday'.
                        },
                    Filter for not {value display-string} 
                } asa Visual, || Force conversion to Visual, not Label
            enabled? = not cell.pending-value?,
            {on Action do
                let constant new-fil:RecordFilter =
                    {RecordFilter
                        {proc {r:Record}:bool
                            {return
                                {r.compare-field 
                                    cell.field.name, 
                                    data
                                } != 0
                            }
                        }
                    }
                {self.note-filter-changing}
                set record-view.filter =
                    {if-non-null fil = record-view.filter then
                        {RecordFilter.logical-and fil, new-fil}
                     else
                        new-fil
                    }
            } 
        }
    }
    
    let constant filter-proc:#{proc-type {{Array-of MenuItem}, RecordGridCell}
                                  :{Array-of MenuItem}} =
        cell.filter-menu-proc
    {if-non-null filter-proc then
        set item-array = {filter-proc item-array, cell}
    }
        
    {return item-array}

  }
  
  ||----------------------------------------
  || Methods to implement ScrollerInterface
  ||----------------------------------------
  
  ||PROTO
  field public-get protected-set vsync-followers:#{Array-of ProtoSkinnableRecordGridUI}

  {method public open {follow follower:ProtoSkinnableRecordGridUI}:void
    {if self.vsync-followers == null then
        set self.vsync-followers = {new {Array-of ProtoSkinnableRecordGridUI}}
    }
    {if-non-null followers = self.vsync-followers then
        {followers.append follower}
    }
||--    {follower._vscroll.contents.detach}
  }

  {method protected open {adjust-followers pos:Distance}:void
    {if-non-null followers = self.vsync-followers then
        {for follower in followers do
            set follower.vertical-position = pos
            set follower._scroll-adjustment-pending? = false
        }
    }
  }

  {getter public open {vertical-position}:Distance
    {return self._vertical-position}
  }
  
  || vertical-position stores the scrolling in a non-discrete from
  || it also gets translated to the discrete max-vertical-position 
  {setter public open {vertical-position val:Distance}:void
    {if val != self._vertical-position then
        set val = {max val, self.min-vertical-position}
        set val = {min val, self.max-vertical-position}
        set self._vertical-position = val 
        set self.first-scrollable-row = 
            ({round val / 1cm} asa int + 
             self.frozen-row-count + 
             self.frozen-row-start)
    }  
  }
  
  {getter public open {min-vertical-position}:Distance
    {return
        {if self._disable-vscroll? then
            self._vertical-position
         else   
            0cm
        }
    }
  }

  {getter public open {max-vertical-position}:Distance
    {return 
        {if self._disable-vscroll? then
            self._vertical-position 
         else
            {max
                0cm,
                (self.max-first-scrollable-row - 
                 self.frozen-row-count - 
                 self.frozen-row-start) * 1cm
            }
        }
    }
  }

  {getter public open {horizontal-position}:Distance
    {return self._col-layouts.offset}
  }
  
  {setter public open {horizontal-position val:Distance}:void
    || Range checking done by offset setter.
    set self._col-layouts.offset = val
  }
  
  {getter public open {min-horizontal-position}:Distance
    {return
        {if self._disable-hscroll? then
            self._col-layouts.offset
         else
            0cm
        }
    }
  }

  {getter public open {max-horizontal-position}:Distance
    {return
        {if self._disable-hscroll? then
            self._col-layouts.offset
         else
            self._col-layouts.max-offset
        }
    }
  }

  {method public open {get-viewport-bounds
                          relative-to:Visual,
                          dest:#GRect = null
                      }:#GRect
    let ret:GRect = 
        {if-non-null dest then dest else {GRect 0cm,0cm,0cm,0cm}}
    let constant internal-grid:SkRGInternalGrid = self._internal-grid
    {ret.set {internal-grid.layout.get-cell-bounds}}
    {dec ret.lextent, self._col-layouts.start-visible-x}
    {dec ret.ascent, internal-grid.header-block-descent}
    let constant (x:Distance, y:Distance, valid?:bool) = 
        {transform-coordinates-with-test
            0cm, 0cm,
            internal-grid, relative-to
        }
    {if valid? then
        {ret.shift-xy x, y}
        {return ret}
    }
    {return null}
  }
  
  {method public open {scroll-to-include-relative-point
                          relative-to:Visual,
                          x:Distance = 0pt,
                          y:Distance = 0pt,
                          min-window:double = 0.0,
                          max-window:double = 1.0
                      }:void
    || TODO: We make this a no-op, because this object already has
    || a mechanism for putting the focused cell in view, and this
    || mechanism was causing the focused cell to *too* aggressively
    || scroll to itself.  However we are arguably not aggressive enough
    || because one can easily arrange things so that the active cursor 
    || (where a user is typer) in a text cell is not visible. This, 
    || we should consider reimplementing this at some point.
    {return}
  }

  ||-----------------------------------------------------
  || Scroll Management
  ||
  || Changing first-visible-row will scroll the specified 
  || record to the top of the visible area. The value set 
  || is normalized to be between 0 and the maximum needed to
  || bring the entire page into view.
  ||
  || Changing first-scrollable-row will scroll the specified
  || record to the top of the scrollable area, similar to
  || above. If there are no frozen rows, this will always 
  || equal first-visible-row.
  ||
  || first-scrollable-row >= first-visible-row
  ||
  || Note that FVR has a min of 0, while FSR has a min of -1.
  || FSR == -1 means that no rows are in the scrollable region.
  || FSR == 0 means that row 0 is in the scrollable region.
  ||
  ||-----------------------------------------------------
  
  {getter package {first-visible-row}:int 
    {return self._first-visible-row}
  } 
  
  {setter package {first-visible-row value:int}:void
    set value = {min value, self.max-first-visible-row}
    set value = {max 0, value}
    {if value != self._first-visible-row then
        set self._first-visible-row = value
        {self._internal-grid.refresh-display}
    }
  }

  {getter private {max-first-visible-row}:int
    || If the first-visible is legal, use curr-page-size to calc
    || max to bring all rows into view. If first-visible is illegal 
    || (e.g. it is in the process of being lowered) use the absolute max.  
    let constant row-count:int = self._data-row-count
    let constant first-visible:int = self._first-visible-row 
    {return
        {if self.frozen-row-count > 0 or
            self.frozen-row-start > 0
         then
            {if row-count > self.frozen-row-start then
                self.frozen-row-start
             else
                -1
            }

         elseif first-visible <= row-count - 1 then
            {max
                (row-count - 
                 {max 1, self._internal-grid.curr-page-size}
                ),
                first-visible
            }
            
         else
            row-count - 1 
        }
    }
  }
  
  {method public open {reveal-grid-focus-cell}:void
    {if-non-null focus-cell = self.grid-focus then
        let constant hidden-row-index:int = self.hidden-row-index
        {if hidden-row-index == focus-cell.record-index and
            hidden-row-index != -1
         then
            {self.reveal-index row-index = hidden-row-index}
        }
    }
  }
  
  {method protected open {reveal-index
                             row-index:int = -1,
                             column-index:int = -1
                         }:void
    {if row-index >= self._data-row-count or
        row-index < (self.frozen-row-start + self.frozen-col-count)
     then
        set row-index = -1
    }
    {if column-index >= self.grid.columns.size or
        column-index < (self.frozen-col-start + self.frozen-col-count)
     then
        set column-index = -1
    }

    {self.scroll-to-reveal 
        row-index = row-index, 
        col-index = column-index
    }
  }

  {method private {scroll-to-reveal
                      row-index:int = -1, 
                      col-index:int = -1
                  }:void
    
    {if row-index != -1 then
        {self._internal-grid.scroll-to-reveal-row row-index}
    }
    
    {if col-index != -1 then
        {self._col-layouts.scroll-to-reveal col-index}
    }
  }
  
  
  {getter package {first-scrollable-row}:int
    {return self._first-scrollable-row}
  }
  
  {setter package {first-scrollable-row i:int}:void
        
    let constant max-row:int = self.max-first-scrollable-row
    let constant min-row:int = self.frozen-row-count + self.frozen-row-start
    
    {if min-row > max-row then
        set i = -1
     elseif min-row == max-row then
        set i = min-row
     else
        set i = {max min-row, {min max-row, i}}
    }
    
    {if i != self._first-scrollable-row then
        {self.force-set-first-scrollable-row i}
        {self._internal-grid.refresh-display}
    }
  }
  
  || Force the first-scrollable-row to some setting without notification
  || or refresh. Used only when layout is occuring, and generally when
  || the frozen row count is changing, or from within normal setter.
  || Does perform basic clamping on min and max.
  {method package {force-set-first-scrollable-row i:int}:void
    || We cannot set FSR to within the frozen region, or too high.
    let constant min-row:int = self.frozen-row-count + self.frozen-row-start
    let constant max-row:int = self._data-row-count - 1
    set self._first-scrollable-row =
        {if (max-row < min-row) or (i == -1) then
            -1
         else
            {min max-row, {max min-row, i}}
        }
    || If there's no freeze, first-visible-row == first-scrollable-row.
    {if min-row == 0 then
        set self._first-visible-row = {max 0, i}
    }
    || Sync non-discrete _vertical position if needed
    {if self._vertical-position > (i + min-row) * 1cm or
        ({round self._vertical-position / 1cm} asa int) != (i + min-row)
     then
        set self._vertical-position = 
            (self._first-scrollable-row - min-row) * 1cm
    }
  }
  
  {getter private {max-first-scrollable-row}:int
    let constant row-count:int = self._data-row-count
    let constant first-scrollable:int = self._first-scrollable-row 
    {return
        {if row-count == 0 then
            -1
         elseif first-scrollable <= row-count - 1 then
            {max
                (row-count - 
                 {max 1, self._internal-grid.curr-page-size}
                ),
                self.frozen-row-start + self.frozen-row-count,
                first-scrollable
            }
         else
            row-count - 1 
        }
    }    
  }
  
  {getter package {hidden-row-index}:int
    {return self._internal-grid.hidden-row-index}
  }
  
  ||-----------------------------------------------
  || Cell Management
  ||-----------------------------------------------
  
  {method package {get-cell col:RecordGridColumn}:RecordGridCell
    
    || try cache
    let (cache:{Array-of RecordGridCell}, cache-exists?:bool) = 
        {self._cached-cells.get-if-exists col}
    {if cache-exists? and cache.size > 0 then 
        {return {cache.pop}}
    }

    || or build with explicit cell type, or based on domain type    
    def cell = {self.create-cell col}
    set cell.column = col
    {return cell}
  }

  {doc-next
    {purpose Creates a cell of the default type for a column.}
    {parameter col, The {docref RecordGridColumn} to create the cell for.}
    {details
        The implementation on {docref SkinnableRecordGridUI} uses the
        {ctext RecordGridColumn.cell-spec} to determine the type of cell
        to create, as follows:
        {itemize
            {item
                If {ctext cell-spec} is a {docref Type}, then a cell
                of that type is created.  An error will occur if the
                value is not a subtype of {ctext RecordGridCell}.
            }
            {item
                If {ctext cell-spec} is a proc that takes a {ctext
                RecordGridColumn} as a parameter and returns a
                {ctext RecordGridCell}, the proc is called.
            }
        }

        If the above cases do not apply, then the {docref Domain} of
        the {docref RecordField} for the column is consulted to
        determine the type of cell to create, as follows:
        {itemize
            {item
                If {ctext Domain.type} is a {ctext bool}, then a
                {docref StandardCheckButtonCell} is created.
            }
            {item
                If the {ctext Domain} has a list of allowable values,
                then a {docref StandardDropdownCell} is created.
            }
            {item
                For other {ctext Domain}s, a {docref
                StandardStringCell} is created.
            }
            {item
                For {ctext RecordGridColumn}s that have no {ctext
                RecordField} (and therefore no {ctext Domain}), a
                {docref StandardRecordGridCell} is created.
            }
        }
    }
    {override
        Implementors should not attempt to cache values, as {ctext
        SkinnableRecordGridUI} implements its own cache.
    }
  }
  {method private {create-cell col:RecordGridColumn}:RecordGridCell
    {return
        {type-switch col.cell-spec
         case a-type:Type do
            {if {a-type.subtype-of? RecordGridCell} then
                {with-compiler-directives allow-any-calls? = true do
                    {a-type} asa RecordGridCell
                }
             else
                {error {hlmessage cell-spec not a subtype of RecordGridCell.}}
            }
         case a-proc:{proc-type {RecordGridColumn}:RecordGridCell} do
            {a-proc col}
         else
            {if-non-null record-field = col.field then
                {switch record-field.domain.type
                 case bool do
                    {StandardCheckButtonCell}
                 else
                    {if record-field.domain.allowable-values != null then
                        {StandardDropdownCell}
                     else
                        {StandardStringCell}
                    }
                }
             else
                {StandardRecordGridCell}
            }
        }
    }
  }

  {method package {release-cell rgc:RecordGridCell}:void
    
    || cache it
    {if-non-null col = rgc.column then
        let (cache:{Array-of RecordGridCell}, cache-exists?:bool) = 
            {self._cached-cells.get-if-exists col}
        {if not cache-exists?  then 
            set cache = {{Array-of RecordGridCell}}
            {self._cached-cells.set col, cache}
        }
        {cache.push rgc}
    }
  }

  {method public open {set-grid-focus rgc:#RecordGridCell}:void
    || Do not give a frozen-out grid focus.
    {if-non-null rgc then
        let constant (rec:int, col:int) = {rgc.get-indices}
        {if rec < self.frozen-row-start or
            col < self.frozen-col-start
         then
            {return}
        }
    }
    {if rgc != self.grid-focus then
        {super.set-grid-focus rgc}
        
        {if-non-null rgc then
            
            || Superclass might have given focus to someone else.
            {if rgc.has-grid-focus? then
                
                {self.grid.select-nothing}
                
                let constant rec-index:int = rgc.record-index
                let constant col-index:int = {self.get-cell-column rgc}
                                
                {if rgc.record-index != -1 then
                    set self.grid.current-index = rec-index
                }
                
                {self.scroll-to-reveal 
                    row-index = rec-index,
                    col-index = col-index
                }
            
                {try
                    set self._internal-grid._region-selection-anchor =
                        {RecordGridRegion
                            rec-index,
                            col-index,
                            1,
                            1
                        }
                 catch e:Exception do
                    set self._internal-grid._region-selection-anchor = null
                }
            }
            
         else
            set self._internal-grid._region-selection-anchor = null
        }
        
    }
    {self.grid.request-update-commands}
  }
  
  {method public open {get-cell-at
                          record:Record,
                          column:RecordGridColumn
                      }:#RecordGridCell
    {return 
        {self.get-cell-at-index 
            {self.grid.records.get-index record},
            {self.grid.columns.find column}
        }
    }
  }
  
  {method public open {get-cell-at-index
                          record-index:int,
                          column-index:int
                      }:#RecordGridCell
    
    let constant grid:RecordGrid = self.grid

    {if record-index < 0 or
        record-index >= grid.records.size or
        column-index < 0 or
        column-index >= grid.columns.size
     then
        {return null}
     else
        let constant data-row:SkRGDataRow = {self.get-data-row record-index}
        let constant cell:RecordGridCell = {data-row.get column-index}
        {return cell}
    }
    
  }
  
  ||-----------------------------------------------
  || Row management
  ||-----------------------------------------------  
  
  || Get header row if appropriate; sync cached value with control. 
  {method package {get-header-row i:int}:#SkRGBaseHeaderRow
    {self.resync-header-rows}
    {if (i >= 0) and 
        (i < self._header-rows.size)
     then
        {return self._header-rows[i]}
     else
        {return null}
    }
  }
  
  || Ensures that the header rows are valid.
  {method package {resync-header-rows}:void
    {if self.grid.display-column-headers? then
        {if self._header-rows.empty? then
            {self._header-rows.insert {SkRGHeaderRow self}, 0}
            let constant grid:RecordGrid = self.grid
            {for i = 1 to grid.max-column-depth do
                {self._header-rows.append {SkRGSharedHeaderRow self, i}}
            }
        }
     else
        {if not self._header-rows.empty? then
            {self._header-rows.clear}
        }
    }    
  }
    
  || Get a data row for record index i.
  || Take from cache, or construct it if necessary.
  {method package {get-data-row i:int}:SkRGDataRow
    let (data-row:SkRGDataRow, valid?:bool) = {self._data-rows.get-if-exists i}
    {if not valid? then
        set data-row =
            {if self._cached-data-rows.size > 0 then
                {self._cached-data-rows.pop}
             else
                {SkRGDataRow self, i}
            }
        
        || Ensure there's no leftover height setting.
        {unset data-row.height}

        set data-row.index = i
        {self._data-rows.set i, data-row}
        || Ensure the row is updated for any change in freeze settings
        || since it was cached.
        {data-row.note-frozen-column-count-changed}
    }
    {return data-row}
  }
  
  || Release (and cache) a data row that is no longer needed.
  {method package {release-data-row row:SkRGDataRow}:void
    || Release and cache row if not destroyed or current record.
    {if row.index != -1 and 
        row.index != self.grid.current-index 
     then
        {self._data-rows.remove row.index, error-if-missing? = true}
        set row.index = -1
        {self._cached-data-rows.push row}
    }
  }
  
  {method private {resize-data-rows}:void
    let old-count:int = self._data-row-count
    let new-count:int = self.grid.records.size 

    set self._data-row-count = new-count
    
    || BUG: 26729
    || Don't potentially trigger layout if results would be useless
    || or dangerous (eg called from note-columns-collection-changed).
    let constant safe-to-set-fsr?:bool = self._safe-to-set-fsr?
    
    {if old-count > new-count then
        
        || Release rows beyond the current count,
        || need to replicate code in release-data-row and
        || do in to steps in order to do this in place.
        {for row in self._data-rows do
            {if row.index >= new-count then
                set row.index = -1
                {self._cached-data-rows.push row}
            }
        }
        {self._data-rows.filter-keys
            {proc {i:int}:bool {return i < new-count}}
        }
        
        || May need to adjust scroll position 
        {if self.first-scrollable-row > new-count - 1 then
            {if safe-to-set-fsr? then
                set self.first-scrollable-row = new-count - 1
             else
                {self.force-set-first-scrollable-row new-count - 1}
            }
        }
        
     elseif new-count > old-count then
        
        || Ensure that we reset integer display bounds if we were in
        || the "no content displayed" mode.
        {if self.first-scrollable-row == -1 then
            {if safe-to-set-fsr? then
                || This value will be normalized.
                set self.first-scrollable-row =
                    (self.frozen-row-start + self.frozen-row-count)
             else
                let constant target-fsr:int =
                    (self.frozen-row-start + self.frozen-row-count)
                {if target-fsr > new-count then
                    {self.force-set-first-scrollable-row target-fsr}
                }
            }
        }
            
    }
  }

  {method private {destroy-all-rows}:void

    let constant old-data-row-count:int = self._data-row-count
    
    || Clear out references to the rows.
    {self.set-grid-focus null}
    {self._internal-grid.clear-display}
    
    || Destroy active rows, including header(s).
    {for one-header-row in self._header-rows do
        {one-header-row.destroy}
    }
    {self._header-rows.clear}
    
    {for row in self._data-rows do
        {row.destroy}
    }
    {self._data-rows.clear}
    
    || Destroy cached rows
    {for row in self._cached-data-rows do
        {row.destroy}
    }
    {self._cached-data-rows.clear}
    
    || Remove caches that have been invalidated.
    {for one-col in self._column-caches-to-flush do
        {self._cached-cells.remove one-col, error-if-missing? = false}
    }
    {self._column-caches-to-flush.clear}

    || With all rows destroyed we can refresh the data epoch
    set self._data-epoch = 1 

    {self.resize-data-rows}

    || If we were and still aren't displaying any rows, resize-data-rows
    || won't cause the internal grid to update.
    || Do that here so that header cells are regenerated. 
    {if old-data-row-count == 0 and
        || FIXME: [2008-02-22] we're using this more as a proxy for
        || "safe-to-refresh?", which is currently safe but overall iffy.
        self._safe-to-set-fsr? and
        self._data-row-count == 0
     then
        {self._internal-grid.refresh-display}
    }
    
  }

  || Rebuilds the internal view of columns by depth.
  {method package {rebuild-column-header-map}:void
    
    let constant grid:RecordGrid = self.grid
    let constant columns:{Array-of RecordGridColumn} = grid.columns
    let constant base-columns:{Array-of BaseRecordGridColumn} =
        grid.base-columns
    let constant map:{Array-2-of #SkRGHeaderMapElement} =
        self._column-layer-map
    {if base-columns.empty? or
        columns.empty?
     then
        {map.set-size 0, 0}
        {return}
    }

    let constant max-depth:int = grid.max-column-depth
    
    {map.clear}
    {map.set-size columns.size, grid.max-column-depth + 1}
    
    {for x = 0 to (columns.size - 1) do
        let constant one-col:RecordGridColumn = columns[x]
        || Set the map element for the RGC.
        {map.set x, 0, {SkRGHeaderMapElement one-col, x, x}}
        
        let first-parent-level:int = max-depth - one-col.column-depth + 1
        let parent-group:#RecordGridColumnGroup = one-col.parent-group
        
        || Insert null column map elements in the voids above the RGC.
        {for y = 1 to first-parent-level - 1 do
            {map.set x, y, {SkRGHeaderMapElement null, x, x}}
        }
        {for y = first-parent-level to max-depth do
            {if-non-null this-parent-group = parent-group then
                {if-non-null element = {map.get x, y} then
                    {if element.base-col != this-parent-group then
                        {error "internal layout error"} ||""
                    }
                 else
                    let constant new-element:SkRGHeaderMapElement = 
                        this-parent-group
                    {map.set x, y, new-element}
                }
             else
                {error "internal layout error"} ||""
            }
            set parent-group = parent-group.parent-group
        }
    }
    
    || Collapse horizontally-adjacent elements.
    {for y = 1 to grid.max-column-depth do
        let prev-element:#SkRGHeaderMapElement
        {for x = 0 to (columns.size - 1) do
            let constant element:#SkRGHeaderMapElement = {map.get x, y}
            {if-non-null element then
                {if-non-null base-col = element.base-col then
                    {type-switch base-col
                     case rgcg:RecordGridColumnGroup do
                        {if-non-null prev-element then
                            {if prev-element.base-col == rgcg then
                                {map.set x, y, prev-element}
                                set prev-element.last-col = x
                                {continue}
                            }
                        }
                    }
                }
            }
            set prev-element = element
        }
    }

  }
  
  || Returns the array of columns at layer N. Relies on the header map.
  {method package {get-columns-at-layer 
                      layer:int}:#{Array-of BaseRecordGridColumn}
    
    let constant grid:RecordGrid = self.grid
    {if layer < 0 or layer > grid.max-column-depth then {return null}}
    
    let constant map:{Array-2-of #SkRGHeaderMapElement} =
        self._column-layer-map
    {if map.empty? then {return null}}
    
    let constant layer-array:{Array-of BaseRecordGridColumn} =
        {new {Array-of BaseRecordGridColumn}}
    
    let last-element:#SkRGHeaderMapElement
    {for x = 0 to ({map.size} - 1) do
        let constant element:#SkRGHeaderMapElement = {map.get x, layer}
        {if-non-null element then
            {if element == last-element then
                {continue}
             else
                {if-non-null col = element.base-col then
                    {layer-array.append col}
                }
            }
        }
        set last-element = element
    }
    
    {return layer-array}
  }

  {nonlocal-option public vertical-grid-line-width:any
    {self.destroy-all-rows}
    {self._col-layouts.layout-columns}
  }
  
  ||------------------------------------------
  || Layout/Drawing
  ||------------------------------------------    
  
  {method public open {before-reposition layout-context:LayoutContext}:void   
    {super.before-reposition layout-context}
    {self.request-draw layout-context = layout-context}
    {self.note-graphic-state-change GraphicStateChange.reposition}
  }
  
  {method public open {after-reposition layout-context:LayoutContext}:void   
    {super.after-reposition layout-context}
    {self.request-draw layout-context = layout-context}
  }

  {method public open {set-size lc:LayoutContext, bounds:GRect}:void
    {super.set-size lc, bounds}
    {if bounds.width != self._cached-width then
        set self._cached-width = bounds.width
        {self._col-layouts.layout-columns}
    }
    
    {if self.layout-valid? then
        set self._hscroll-toggle-cnt = 0
        set self._vscroll-toggle-cnt = 0
    }
    {self.note-graphic-state-change GraphicStateChange.resize}
  }
  
  {method public open {end-pagination}:void
    {if self.is-paginating? then
        {if-non-null child = self._internal-grid.layout then
            {child.end-pagination}
        }
        {super.end-pagination}
    }
  }

  || FIXME: [2008-06-23 cwstern] The pagination code needs to be reviewed
  || in the context of skinnable controls, where the internal grid may
  || not be attached as expected in the hierarchy.
  || FIXME: transform-coordinates calls should probably all be changed to
  || -with-test, when the failure results can be properly cataloged.
  {method public open {paginate
                          page-height:Distance,
                          next-page-height:Distance,
                          query-only?:bool
                      }:(PaginationState, PaginationQuality)
    let constant epsilon:Distance = epsilon-float * 1m
    let pstate:PaginationState = {self.get-pagination-state query-only?}
    let bounds:GRect = pstate.bounds
    
    || All done.
    {if {abs bounds.descent - pstate.end-offset} < epsilon then
        set pstate.start-offset = pstate.end-offset
        {return pstate, PaginationQuality.complete}
    }

    || No space left for the graphic.
    {if page-height < epsilon then
        {return pstate, PaginationQuality.clipped-outside}
    }

    let new-start-offset:Distance = pstate.min-end-offset 
    let new-maybe-end-offset:Distance = 
        {min new-start-offset + page-height, bounds.descent}

    || Note that the child probably contains a VBox which has
    || both the header and the data.
    let child-graphic:Graphic = self._internal-grid
    let child:Layout = {non-null child-graphic.layout}
    let child-bounds:GRect = {child.get-cell-bounds}
    let (x:Distance, y:Distance, valid?:bool) =
        {transform-coordinates-with-test
            0m, -child-bounds.ascent, child-graphic, self
        }
    {if not valid? then {return pstate, PaginationQuality.complete}}
    let child-top:Distance = y
    set (x, y, valid?) =
        {transform-coordinates-with-test
            0m, child-bounds.descent, child-graphic, self
        }
    {if not valid? then {return pstate, PaginationQuality.complete}}
    let child-bottom:Distance = y 
    let child-height:Distance = child-bottom - child-top
    || Case. The child is already paginating.
    {if child.pagination-state != null then
        let less-header-height:Distance = 0m
        {for hr in self._header-rows do
            {if not hr.is-paginating? then
                {inc less-header-height, {hr.layout.get-cell-bounds}.height}
            }
        }

        let (cps:PaginationState, cpq:PaginationQuality) =
            {child.paginate 
                page-height - less-header-height, 
                next-page-height - less-header-height, 
                query-only?
            }

        || Adjust child end offset if needed. This is needed as in this particular
        || graphical hierarchy the internal VBox may return an end offset that is 
        || lower than the end offset of the internal grid.
        {if cps.end-offset > child-bounds.descent then
            set cps.end-offset = child-bounds.descent
            set cps.min-end-offset = cps.end-offset
            set cpq = PaginationQuality.complete
        }

        {if cpq == PaginationQuality.complete then
            || The remaining portion of the graphic could fit in the available
            || page height.
            let constant complete?:bool = 
                {abs new-maybe-end-offset - bounds.descent} < epsilon
            set pstate.start-offset = new-start-offset
            {if complete? then
                set pstate.end-offset = new-maybe-end-offset
                set pstate.min-end-offset = new-maybe-end-offset
             else
                let (x:Distance, y:Distance) =
                    {transform-coordinates
                        0m, cps.end-offset, child-graphic, self
                    }
                set pstate.end-offset = y
                || If the header row is not paginating, we will draw it
                || in each page this object paginates to. So make sure that
                || we will have space for it to draw.
                set pstate.min-end-offset = y - less-header-height
            }

            {return
                pstate,
                {if complete? then
                    PaginationQuality.complete
                 else
                    PaginationQuality.good
                }
            }
         else
            || The child extends to the next page.
            set pstate.start-offset = new-start-offset
            let (x:Distance, y:Distance) =
                {transform-coordinates
                    0m, cps.end-offset, child-graphic, self
                }
            
            set pstate.end-offset = y
            set (x, y) =
                {transform-coordinates
                    0m, cps.min-end-offset, child-graphic, self
                }

            || If the header row is not paginating, we will draw it
            || in each page this object paginates to. So make sure that
            || we will have space for it to draw.
            set pstate.min-end-offset = y - less-header-height

            || We return whatever the childs pagination state is.
            {return pstate, cpq}
        }
    }

    let constant complete?:bool = 
        {abs new-maybe-end-offset - bounds.descent} < epsilon
    {if complete? then
        set pstate.start-offset = new-start-offset
        set pstate.end-offset = new-maybe-end-offset
        set pstate.min-end-offset = new-maybe-end-offset
        {return pstate, PaginationQuality.complete}
    }

    || Child needs to paginate.
    let less-height:Distance = child-top - new-start-offset
    let available-height:Distance = page-height - less-height

    {child.start-pagination}

    || See what pagination quality we would get if we decide to paginate
    || this graphic.
    let (cps:PaginationState, cpq:PaginationQuality) = 
        {child.paginate available-height, next-page-height, true}

    {if cpq == PaginationQuality.good then
        let (x:Distance, cps-end-offset:Distance) =
            {transform-coordinates
                0m, cps.end-offset, child-graphic, self
            }
        || Make sure that we have at least a row if present.
        let (first-row:SkRGDataRow, found?:bool) =
            {self._data-rows.get-if-exists self._first-visible-row}
        {if found? then
            let row-bounds:GRect = {first-row.layout.get-cell-bounds}
            let (x:Distance, row-bottom:Distance) =
                {transform-coordinates 0m, row-bounds.descent, first-row, self}

            {if row-bottom - cps-end-offset > epsilon then
                set cpq = PaginationQuality.poor
            }
         else
            {if not self._header-rows.empty? then
                let constant hr:SkRGBaseHeaderRow = 
                    {self._header-rows.top-of-stack}
                let (x:Distance, header-bottom:Distance) =
                    {transform-coordinates
                        0m, {hr.layout.get-cell-bounds}.descent, hr, self
                    }
                {if header-bottom - cps-end-offset > epsilon then
                    set cpq = PaginationQuality.poor
                }
            }
        }
    }
    
    let avoid-page-break?:bool = child-graphic.avoid-page-break?
    let maybe-push-to-next-page?:bool =
        ((next-page-height - available-height > epsilon) and
         avoid-page-break? or cpq.value < PaginationQuality.good.value)

    {if maybe-push-to-next-page? and not avoid-page-break? then
        || See if the pagination would be better if we moved this 
        || graphic to the next page.
        let (new-cps:PaginationState, new-cpq:PaginationQuality) =
            {child.paginate next-page-height, next-page-height, true}
        
        || After pushing to the next page, if the footer is not included,
        || we allow the footer to be in the next page.
        set maybe-push-to-next-page? =
            new-cpq.value >= PaginationQuality.good.value
    }
    set pstate.start-offset = new-start-offset
    {if maybe-push-to-next-page? then
        || Push this child to the next page.
        set pstate.end-offset = child-top 
        set pstate.min-end-offset = child-top
        {if query-only? then
            {child.end-pagination}
        }
        {return 
            pstate,
            {if {abs child-top - -bounds.ascent} < epsilon then
                || The top of child of this object is aligned with the
                || top of the object. Splitting the object in this way would
                || not slice the child, but it would end up putting this
                || object border/margin in the current page and child in the top 
                || of the next page. In this situaltion we would ideally want to 
                || move this entire object to the next page. So we return
                || PaginationQuality.poor and let the container of this object
                || decide how this object would be paginated.
                PaginationQuality.poor
             else
                PaginationQuality.good
            }
        }
     else
        || Ask the child to paginate.
        let (new-cps:PaginationState, new-cpq:PaginationQuality) =
            {child.paginate available-height, next-page-height, query-only?}
        let (x:Distance, y:Distance) =
            {transform-coordinates
                0m, new-cps.end-offset, child-graphic, self
            }
        
        set pstate.end-offset = y
        set (x, y) =
            {transform-coordinates
                0m, new-cps.min-end-offset, child-graphic, self
            }
        || FIXME: is the following correct? Perhaps see draw method.
        {for hr in self._header-rows do
            {if not hr.is-paginating? then
                set y = y - {hr.layout.get-cell-bounds}.height
            }            
        }

        set pstate.min-end-offset = y
        {if query-only? then
            {child.end-pagination}
        }
        || The pagination quality is the one that is returned by the child.
        || In case the child returns complete or none, does not mean that the
        || PaginationQuality of the parent is also the smae. So take care of 
        || this situation.
        {return 
            pstate,
            {if {abs pstate.end-offset - bounds.descent} < epsilon then
                PaginationQuality.complete
             else
                {if new-cpq == PaginationQuality.complete then
                    PaginationQuality.good
                 else
                    new-cpq
                }
            }
        }
    }
  }
  
  {method public open {draw r:Renderer2d}:void
    {self.draw-skin r}
    {super.draw r}
    {if self.is-paginating? then
        {if not self._header-rows.empty? then
            let constant hr:SkRGBaseHeaderRow = 
                {non-null {self.get-header-row 0}}
            let ps:PaginationState = {self.get-pagination-state false}
            let height:Distance = ps.start-offset - -ps.bounds.ascent
            let hr-cell-bounds:GRect = {hr.layout.get-cell-bounds}

            || HACK: A test to see if the header rows can be transformed:
            let constant (xjunk:Distance, yjunk:Distance, valid?:bool) =
                {transform-coordinates-with-test
                    0m, 0m,
                    hr, self
                }
            {if not valid? then
                {self.overdraw-skin r}
                {return}
            }
            
            let cell-bounds:GRect = hr-cell-bounds
            let top-header-row:SkRGBaseHeaderRow = hr
            let header-height:Distance = cell-bounds.height
            {for i = 1 to self._header-rows.size - 1 do
                let one-header-row:SkRGBaseHeaderRow = 
                    {non-null {self.get-header-row i}}
                {inc header-height,
                    {one-header-row.layout.get-cell-bounds}.height
                }
                {inc header-height,
                    self._internal-grid._vertical-grid-line-width
                }
                set top-header-row = one-header-row
            }
            {if not hr.is-paginating? and
                self._header-rows.size >= 2 and
                header-height < (height / 1.5)
             then
                || If the header is not paginating, and we have space, 
                || we draw each header in each 
                || page where this object is paginated to.
                let (x:Distance, y:Distance) =
                    {transform-coordinates
                        -cell-bounds.lextent, -cell-bounds.ascent, 
                        top-header-row, self
                    }
                {with ignore-pagination-state-on-draw? = true do
                    {with-render-properties
                        translation-y = height,
                        clipping-region = 
                            {Region.from-rectangle
                                x, y, cell-bounds.width, header-height
                            }
                        on r do
                        {super.draw r}
                    }
                }
                
             elseif hr-cell-bounds.height < (height / 2) then
                || Draw only the concrete column header row in each page 
                || if we didn't have space for all header rows.
                let (x:Distance, y:Distance) =
                    {transform-coordinates
                        -cell-bounds.lextent, -cell-bounds.ascent, 
                        hr, self
                    }
                {with ignore-pagination-state-on-draw? = true do
                    {with-render-properties
                        translation-y = height,
                        clipping-region = 
                            {Region.from-rectangle
                                x, y, cell-bounds.width, cell-bounds.height
                            }
                        on r do
                        {super.draw r}
                    }
                }
            }
        }
    }
    {self.overdraw-skin r}
  }
  
  ||------------------------------------------------------------------
  || Gesture Interpretation
  || 
  || Note that an enabled SkinnableRecordGridUI will consume *all* 
  || pointer presses and all left releases.  Right releases will not 
  || be consumed in order to allow generation of ContextMenuEvents.
  ||------------------------------------------------------------------

  || FIXME: cannot enable this currently due to built-in gestures:
||--  {method public open {contains-point? x:Distance, y:Distance}:bool
||--    {return
||--        {super.contains-point? x, y} or
||--        {self.control-skin.opaque-point? "", x, y}
||--    }
||--  }

  {method public open {on-pointer-press ev:PointerPress}:void
    
    || Presses over internal grid should already be consumed
    || This consume stray presses.
    {if not ev.consumed? and self.enabled? then
        set ev.test-recorded? = true
        {ev.consume}
    }
    {super.on-pointer-press ev}
  }

  {method public open {on-pointer-release ev:PointerRelease}:void
    
    {if ev.consumed? or not self.enabled? then  
        {return}
    }
    
    def grid = self.grid
    def old-index = grid.current-index
    || If release was not over internal grid, select-nothing, activate
    || Internal grid handles all this for releases in its bounds
    {if {self.pick-child ev.x, ev.y} == null and
        ev.click-count == 1
     then
        set ev.test-recorded? = true
        {if not grid.selection.empty? then
            {grid.test-record "DeselectAll"} ||""
        }
        {grid.select-nothing}   
        {grid.become-active}
    }        
    
    {if ev.button != right-button then 
        {ev.consume}
        set ev.test-recorded? = true
    }
    {super.on-pointer-release ev}    
    def new-index = grid.current-index
    {if old-index != new-index then
        || Record the index.
        {grid.test-record "SetCurrentIndex", new-index} ||""
    }
  }

  {method public open {reserved-key? ev:KeyPress}:bool
    {return
        {switch ev.value
         case 
            KeyPressValue.right, KeyPressValue.left, KeyPressValue.home,
            KeyPressValue.end, KeyPressValue.pgdn, KeyPressValue.pgup,
            KeyPressValue.up, KeyPressValue.down, KeyPressValue.tab
         do 
            true
         else
            false
        }
    }
  }

  || Several helper methods follow the on-key-press method:  
  {method public open {on-key-press e:KeyPress}:void
    def grid = self.grid
    def old-index = grid.current-index
    {self.on-key-press-aux e}
    def new-index = grid.current-index
    {if old-index != new-index then
        || Record the index.
        {grid.test-record "SetCurrentIndex", new-index} ||""
    }
  }

  {method private {on-key-press-aux ev:KeyPress}:void

    || 0) Check for validity.
    
    || Ignore RGKPs that were fired downwards and then returned.
    {type-switch ev
     case rgkp:RecordGridKeyPress do
        {if not rgkp.upwards? then 
            {return}
        }
    }
    
    let constant grid:RecordGrid = self.grid

    || If there's no content or we're "off", pass to super and return.
    {if ev.consumed? or 
        not self.enabled? or
        grid.columns.size == 0 or
        self._data-row-count == 0
     then
        {super.on-key-press {self.reconvert-key-press ev}}
        {return}
    }
    
    || 1) Setup and miscellaneous preprocessing
    
    || Mark the event as recorded by default.  We'll unmark it if we
    || need to later.
    set ev.test-recorded? = true

    let constant internal-grid:SkRGInternalGrid = self._internal-grid
    let constant selection:RecordGridSelection = grid.selection

    let constant old-cell:#RecordGridCell = self.grid-focus
    let constant old-cell-column:int =
        {if-non-null old-cell then
            {self.get-cell-column old-cell}
         else
            -1
        }
    let constant old-current-index:int = grid.current-index
    
    let forward?:bool = true
    let v-nav?:bool = false
    let h-nav?:bool = false
    let deleted?:bool = false

    || Set to true when we consider ourselves done with post-processing.
    let processed?:bool = false
    
    || 2) There is no selection active, so a cell might be active.
    || Translate keypress to navigation increments or action.
    || We also will try to immediately navigate if select-current-record?
    || is true, except where we're extending a selection.
    
    || Tab is a special case where shift doesn't mean +selection.
    {if ev.value == KeyPressValue.tab and
        (selection.empty? or
        (grid.record-selection-enabled? and
         grid.select-current-record?))
     then
        set forward? = not ev.shift?
        set h-nav? = {self.traverse forward? = forward?} 
        {if not h-nav? then
            || If we fail to tab traverse in ui, jump up a level.
            {if-non-null atc = self.grid.active-traversal-container then
                {if {atc.traverse forward? = forward?} then
                    {ev.consume}
                    || We want the system to record the tab for us.
                    set ev.test-recorded? = false
                    {return}
                }
            }
        }
        set processed? = true
        {ev.consume}
        
    elseif selection.empty? or
        (grid.record-selection-enabled? and
         grid.select-current-record? and
         not ev.shift?)
     then
        {switch ev.value
            
         case KeyPressValue.right do
            set forward? = true
            set h-nav? = {self.traverse forward? = forward?}
            {ev.consume}
         case KeyPressValue.left do
            set forward? = false
            set h-nav? = {self.traverse forward? = forward?}
            {ev.consume}
         case KeyPressValue.up do
            set forward? = false
            set v-nav? = 
                {self.vtraverse 
                    grid.current-index - 1, 
                    forward?
                }
            {ev.consume}
         case KeyPressValue.down do
            set forward? = true
            set v-nav? = 
                {self.vtraverse 
                    grid.current-index + 1, 
                    forward?
                } 
            {ev.consume}
         case KeyPressValue.home do
            set forward? = false
            set v-nav? = {self.vtraverse 0, forward?} 
            {ev.consume}
         case KeyPressValue.end do 
            set forward? = true
            set v-nav? = {self.vtraverse grid.records.size - 1, forward?}
            {ev.consume}
         case KeyPressValue.pgdn do
            set forward? = true
            || If in the frozen region, jump to the first unfrozen row.
            let constant target-row:int =
                {if grid.current-index <
                    (self.frozen-row-start + self.frozen-row-count)
                 then
                    {if self.first-scrollable-row != -1 then
                        self.frozen-row-start + self.frozen-row-count
                     else
                        self._data-row-count - 1
                    }
                 else
                    self.first-scrollable-row + 
                    {max 1, internal-grid.curr-page-size}
                }
            set v-nav? = 
                {self.vtraverse    
                    target-row,
                    forward?,
                    set-first-visible? = true
                }
            {ev.consume}
         case KeyPressValue.pgup do
            set forward? = false
            || If at the top of the scrolling region,
            || jump to the first visible row.
            || Otherwise, on't jump out of the scrolling region in one go.
            let constant target-row:int = 
                {if grid.current-index <=
                    (self.frozen-row-start + self.frozen-row-count)
                 then
                    self.first-visible-row
                 else
                    {max 
                        self.first-scrollable-row - 
                        {max 1, internal-grid.curr-page-size},
                        (self.frozen-row-start + self.frozen-row-count)
                    }
                }
            set v-nav? =
                {self.vtraverse    
                    target-row,
                    forward?,
                    set-first-visible? = true
                }
            {ev.consume}
        }
    }

    || 3) Selection active: no cell is active
    {if not ev.consumed? and
        not selection.empty?
     then
        || 3a) If shift is not down, consider activating a cell or
        || perform operations on the current selection
        || HACK: we're special-casing tab here again.
        {if not ev.shift? or ev.value == KeyPressValue.tab then
                        
            || delete: possibly perform the RecordGridDelete command
            {if ev.value == KeyPressValue.delete then
                let constant delete-command:#Command = 
                    {grid.get-command "delete"} ||""
                {if-non-null delete-command then
                    {if-non-null delete-impl = delete-command.impl then
                        {if delete-impl.enabled? then
                            let min-index:int = max-int
                            {for i in grid.selection.records do
                                set min-index = {min i, min-index}
                            }
                            {delete-impl.do-command}
                            {grid.test-record "DeleteSelectedRows"} ||""
                            set deleted? = grid.selection.empty?
                            set grid.current-index = 
                                {min grid.records.size - 1, min-index}
                            {self.become-active}
                            set forward? = true
                        }
                    }
                }
                {ev.consume}
                
             || Once again we have to special-case tab due to .shift?.
             elseif ev.value == KeyPressValue.tab and
                {self.reserved-key? ev} and
                {self.activate-within-selection ev}
             then
                {ev.consume}
                
                || send along reserved navigation keys:
             elseif ev.unmodified? and
                {self.reserved-key? ev} and
                {self.activate-within-selection ev}
             then
                {ev.consume}

            || HACK: send along magic reserved keys
            || insertable: activate the cell and 
            || send insertable KeyPresses to the selection anchor
             elseif (ev.insertable? or
                     ev.value == KeyPressValue.f2 or
                     ev.value == KeyPressValue.enter) and
                {self.activate-within-selection ev}
             then
                {ev.consume}
            }

            || 3b) If shift is down, try modifying the selection if it's
            || a region or contiguous block of records
         else
            
            {if selection.region-count == 1 and
                selection.record-count == 0 and
                selection.column-count == 0
             then
                {self.modify-region-selection ev}
                {ev.consume}
                
             elseif selection.region-count == 0 and
                selection.record-count >= 1 and
                selection.column-count == 0
             then
                {self.modify-record-selection ev}
                {ev.consume}
            }
            
        }
        
    }
    
    || 3c) Handle unconsumed keys. 
    
    {if not ev.consumed? then
        {super.on-key-press {self.reconvert-key-press ev}}

        || Nothing processed the event.  Let the system record it.
        set ev.test-recorded? = false
        {return}
    }
    
    || 4) Post-processing for handled keys on navigation or deletion.
        
    || 4a) Cancel old selections if we navigated
    || FIXME: I don't think the following is strictly necessary?
    {if not selection.empty? and
        (h-nav? or v-nav?) 
     then
        {grid.select-nothing}
        set processed? = true
    }
    
    || 4b) Try region selection.
    {if not processed? and
        grid.region-selection-enabled? and 
        (h-nav? or v-nav?) and
        not (grid.select-current-record?
             and grid.record-selection-enabled?)
     then
        {if ev.shift? and
            selection.empty?
         then
            {if old-cell-column != -1 then
                {if-non-null grid-focus = grid.ui.grid-focus then
                    let constant current-column:int = 
                        {self.get-cell-column grid-focus}
                    {grid.test-record
                        "SelectCellsRange", ||""
                        old-current-index,
                        old-cell-column,
                        grid.current-index,
                        current-column
                    }
                    {grid.select-region
                        {RecordGridRegion.from-corners
                            old-current-index,
                            old-cell-column,
                            grid.current-index,
                            current-column
                        }
                    }
                    set processed? = true
                }
            }
        }
    }
    
    || 4c) Try record selection. If current record was moved or deleted, 
    ||     selection  is either extended to match, or removed.
    {if grid.record-selection-enabled? and
        ((grid.select-current-record? and
          (v-nav? or deleted?)) or
         (v-nav? and
          not processed? and
          (grid.current-index != old-current-index or deleted?)))
     then
        let selection-processed?:bool = false
        
        || i) Try shift multiple selection: 
        {if v-nav? and
            ev.shift? and 
            grid.multiple-selection-enabled? and
            selection.empty?
         then
            || confirm selection anchor and attempt selection
            {if not {selection.contains-record? 
                        internal-grid._row-selection-anchor
                    } 
             then
                set internal-grid._row-selection-anchor = old-current-index
            }
            {if internal-grid._row-selection-anchor != -1 and 
                grid.current-index != -1 
             then
                {grid.test-record
                    "SelectRowsRange", ||""
                    internal-grid._row-selection-anchor,
                    grid.current-index
                }
                {grid.select-record-range
                    internal-grid._row-selection-anchor,
                    grid.current-index
                }
                set selection-processed? = true
            }
        }

        || ii) Try basic tracking of current
        {if not selection-processed? and
            (v-nav? or deleted?) and
            grid.select-current-record? and
            grid.current-index != -1
         then
            {grid.test-record "SelectRow", grid.current-index} ||""
            {grid.select-record grid.current-index}
            set selection-processed? = true
        }

        || iii) Otherwise drop selection
        {if not selection-processed? then
            {grid.select-nothing}
        }
    }
    
    {if grid.selection.empty? and
        (h-nav? or v-nav?)
     then
        {if self.grid-focus != old-cell then
            {if-non-null cell = self.grid-focus then
                {grid.test-record
                    "ActivateCell", ||""
                    cell.record-index,
                    {self.get-cell-column cell}
                }
             else
                {grid.test-record "ActivateCell", -1, -1} ||""
            }
        }
    }
    
    || 4d) Ensure ui active if active cell dropped.
    {if self.current-active == null then
        {self.become-active forward? = forward?}
    }    
    
    {super.on-key-press {self.reconvert-key-press ev}}
    
  }
  
  || Don't bubble RecordGridKeyPress-es up & out of this UI object.
  || Otherwise alt+(left arrow) might produce a page navigation, etc.
  {method private {reconvert-key-press ev:KeyPress}:KeyPress
    {type-switch ev
     case rgkp:RecordGridKeyPress do
        {if rgkp.test-recorded? then
            set rgkp.original.test-recorded? = true
        }
        {return rgkp.original}
     else
        {return ev}
    }
  }
  
  || Cancel out of a selection and make a cell within active.
  || Optionally provide an "interesting" KeyPress to the 
  || chosen RecordGridCell. Return true if we did.
  || FIXME: actually, the KeyPress is really required at present.
  {method private {activate-within-selection ev:#KeyPress}:bool
    
    let constant grid:RecordGrid = self.grid
    let constant selection:RecordGridSelection = grid.selection
    
    {if selection.empty? then {return false}}
    
    || 1) Determine which cell within the selection we should target.

    let constant (target-record:int, target-column:int) =
        {self.pick-selected-cell}
    {if target-record == -1 or target-column == -1 then {return false}}
    
    let constant cell:RecordGridCell = 
        {self.get-data-row target-record}[target-column]

    || 2) Attempt to activate the target cell, and then
    || forward KeyPresses that might be of interest to the cell.
    
    {if-non-null ev then
        
        || 2a) Enter is intercepted if the target will not take grid focus,
        || instead creating an Action on the RecordGrid.
        {if ev.value == KeyPressValue.enter and 
            not cell.cells-take-focus?
         then
            set ev.test-recorded? = true
            {grid.test-record "Action"} ||""
            {grid.enqueue-event {Action}}
        }
        
        {if {cell.become-active-from-traversal} then
            set ev.test-recorded? = true
            {grid.test-record
                "ActivateCell", ||""
                cell.record-index,
                {self.get-cell-column cell}
            }
            let constant rgkp:RecordGridKeyPress = 
                {RecordGridKeyPress ev, false}
            {cell.handle-event rgkp}
            {return true}
        }
    }
    
    {return false}
  }
  
  || Pick a cell from within the selection using our standard algorithm:
  || anchor cell from a region, or the leftmost, topmost cell.
  || Returns (record index, column index); (-1, -1) on failure.
  {method private {pick-selected-cell}:(int, int)

    let constant selection:RecordGridSelection = self.grid.selection
    
    {if selection.empty? then {return -1, -1}}
    
    let target-record:int = max-int
    let target-column:int = max-int
    
    {if selection.region-count == 1 and
        selection.record-count == 0 and
        selection.column-count == 0
     then 
        let constant target-region:RecordGridRegion =
            {selection.regions.read-one}
        set target-record = target-region.row-anchor
        set target-column = target-region.column-anchor
        
     else
        {for rec-index in selection.records do
            {if rec-index < target-record then
                set target-column = 0
                set target-record = rec-index
            }
        }
        {for one-column in selection.columns do
            let constant one-column-index:int =
                {self.grid.columns.find one-column}
            {if one-column-index < target-column then
                set target-record = 0
                set target-column = one-column-index
            }
        }
        {for one-region in selection.regions do
            {if one-region.first-column <= target-column and
                one-region.first-row < target-record
             then
                set target-record = one-region.first-row
                set target-column = one-region.first-column
            }
        }
    }
    
    || Don't pick a selected cell in the frozen out region.
    set target-record = {max target-record, self.frozen-row-start}
    set target-column = {max target-column, self.frozen-col-start}
    
    {if {selection.contains-cell? target-record, target-column} then
        {return target-record, target-column}
     else
        {return -1, -1}
    }

  }
  
  || Attempt to modify the current region selected via a KeyPress.
  {method private {modify-region-selection ev:KeyPress}:void
    
    let constant grid:RecordGrid = self.grid
    let constant selection:RecordGridSelection = grid.selection
    
    || Setup; check how our region is framed
    
    let constant region:RecordGridRegion =
        {selection.regions.read-one}
    let constant anchor-left?:bool = 
        (region.column-anchor <= region.first-column)
    let constant anchor-top?:bool =
        (region.row-anchor <= region.first-row)

    let move-record:int = 0
    let move-column:int = 0
    let terminal-record:int = 
        {if anchor-top? then
            region.first-row + region.row-count - 1
         else
            region.first-row
        }
    let terminal-column:int = 
        {if anchor-left? then
            region.first-column + region.column-count - 1
         else
            region.first-column
        }
    
    || Translate the key press into an increment
    {switch ev.value
     case KeyPressValue.left do
        {dec move-column}
     case KeyPressValue.right do
        {inc move-column}
     case KeyPressValue.up do
        {dec move-record}
     case KeyPressValue.down do
        {inc move-record}
     case KeyPressValue.home do
        set move-record = -1 * grid.records.size
     case KeyPressValue.end do
        set move-record = grid.records.size
     case KeyPressValue.pgup do
        set move-record = {min -1, -self._internal-grid.curr-page-size}
     case KeyPressValue.pgdn do
        set move-record = {max 1, self._internal-grid.curr-page-size}
    }
    
    || Normalize; also do not jump the anchor in one move
    
    {if move-record != 0 then
        {if (move-record * {if anchor-top? then -1 else 1} >=
             region.row-count) and
            (terminal-record != region.row-anchor)
         then
            set terminal-record = region.row-anchor
         else
            {inc terminal-record, move-record}
        }
    }
    
    {if move-column != 0 then
        {if (move-column * {if anchor-left? then -1 else 1} >=
             region.column-count) and
            (terminal-column != region.column-anchor)
         then
            set terminal-column = region.column-anchor
         else
            {inc terminal-column, move-column}
        }
    }
    
    set terminal-record = 
        {max 0, {min terminal-record, grid.records.size - 1}}
    set terminal-column = 
        {max 0, {min terminal-column, grid.columns.size - 1}}
    
    || Select the normalized region
    set ev.test-recorded? = true
    {grid.test-record
        "SelectCellsRange", ||""
        region.row-anchor,
        region.column-anchor,
        terminal-record,
        terminal-column
    }
    {grid.select-region
        {RecordGridRegion.from-corners
            region.row-anchor,
            region.column-anchor,
            terminal-record,
            terminal-column
        }
    }
    
    || ensure that the new endpoint is visible
    {self.scroll-to-reveal 
        row-index = terminal-record, 
        col-index = terminal-column
    }
    
  }
  
  || Attempt to modify the current records selected via a KeyPress.
  || Because of the interactions with tracking the current record,
  || this is not always as exact as selecting a region.
  {method private {modify-record-selection ev:KeyPress}:void

    let constant grid:RecordGrid = self.grid
    let constant selection:RecordGridSelection = grid.selection
    let constant internal-grid:SkRGInternalGrid = self._internal-grid
    
    let row-anchor:int = internal-grid._row-selection-anchor
    
    {if grid.multiple-selection-enabled? then

        || Find the bounds of the records selected
        
        let first-selected-record:int = max-int
        let last-selected-record:int = -1
        {for one-record in selection.records do
            {if one-record < first-selected-record then
                set first-selected-record= one-record
            }
            {if one-record > last-selected-record then
                set last-selected-record = one-record
            }
        }
        
        || Only continue if the records selected are continguous
        {if ((last-selected-record - first-selected-record + 1) ==
             selection.record-count)
         then
            || The row anchor should never logically be within the selected
            || block, but this can occur when the current record changes.
            || If this has happened, then set the anchor to the "best" edge.
            {if not ((first-selected-record == row-anchor) or
                     (last-selected-record == row-anchor))
             then
                {if grid.current-index == last-selected-record then
                    set row-anchor = last-selected-record
                 else
                    set row-anchor = first-selected-record
                }
                set internal-grid._row-selection-anchor = row-anchor
            }
            
            || Translate the key press into an increment
            let move-record:int = 0
            {switch ev.value
             case KeyPressValue.up do
                {dec move-record}
             case KeyPressValue.down do
                {inc move-record}
             case KeyPressValue.home do
                set move-record = -1 * grid.records.size
             case KeyPressValue.end do
                set move-record = grid.records.size
             case KeyPressValue.pgup do
                set move-record = {min -1, -self._internal-grid.curr-page-size}
             case KeyPressValue.pgdn do
                set move-record = {max 1, self._internal-grid.curr-page-size}
            }
            
            || Normalize; especially consider the case where the edges
            || are collapsed so that the correct edge is moved.
            || Do not move more than one edge with a single call.
            {if (first-selected-record == row-anchor and
                 (last-selected-record == first-selected-record and
                  move-record < 0)) or
                (last-selected-record == row-anchor and
                 not (last-selected-record == first-selected-record and
                      move-record > 0)
                )
             then
                {inc first-selected-record, move-record}
                set first-selected-record = 
                    {max 
                        {min
                            first-selected-record, 
                            last-selected-record
                        },
                        0
                    }
             else
                {inc last-selected-record, move-record}
                set last-selected-record = 
                    {min 
                        {max 
                            first-selected-record, 
                            last-selected-record
                        },
                        grid.records.size - 1
                    }

            }
            
            || Select the new range
            set ev.test-recorded? = true
            {grid.test-record
                "SelectRowsRange", ||""
                first-selected-record,
                last-selected-record
            } 
            {grid.select-record-range
                first-selected-record,
                last-selected-record
            }
            
            || ensure that the edge moved is visible
            let constant scroll-to-record:int =
                {if last-selected-record == row-anchor then
                    first-selected-record
                 else
                    last-selected-record
                }
            {self.scroll-to-reveal row-index = scroll-to-record}
        }
    }
  }
  
  {method public open {on-pointer-scroll e:PointerScroll}:void
    {if not e.consumed? then
        let constant scrollbar:#Scrollbar =
            {if e.axis == WINDOW.ScrollAxis.x then
                {if self._hscroll.display? then
                    self._hscroll.contents
                 else
                    null
                }
             else
                {if self._vscroll.display? then
                    self._vscroll.contents
                 else
                    null
                }
            }

        {if-non-null scrollbar then
            {scrollbar.ui-object.handle-event e}
        }
    }
    {super.on-pointer-scroll e}
  }
  
  ||------------------------------------------
  || Synchronization method to be called when scrollbars
  || need to be adjusted (e.g. internal grid has
  || completed layout or columns have been scrolled.)
  ||-------------------------------------------
  
  {method package {synchronize-navigation}:void
    
    {with self._synchronizing-scrollbars? = true do
        
        || Synchronize scrollbars
        
        || Show each only if necessary, or if toggle count
        || indicates a layout loop is occuring.  Such a loop
        || can happen when grid is highly compressed and adding 
        || the rigid scrollbar actually *increases* the size
        || available along that dimension.
        let constant vscroll-display?:bool = self._vscroll.display?
        let constant hscroll-display?:bool = self._hscroll.display?

        let constant grid:RecordGrid = self.grid
        let constant inner-grid:SkRGInternalGrid = self._internal-grid
        
        let constant max-scroll:int = self.max-first-scrollable-row
        let constant min-scroll:int = 
            self.frozen-row-count + self.frozen-row-start
        let constant scroll-interval:int = max-scroll - min-scroll
        set self._vscroll.display? = 
            ((scroll-interval > 0 or self._vscroll-toggle-cnt > 3) and
             inner-grid.vscroll-visible?
            )
        {if self._vscroll.display? then
            let sb:Scrollbar = {non-null self._vscroll.contents} 
            set sb.blocksize = 
                {max self._internal-grid.curr-page-size, 1} 
            set sb.thumb-length = sb.blocksize
            set sb.max = sb.thumb-length + scroll-interval
            let constant current-position:int =
                self.first-scrollable-row - min-scroll
            {sb.set-scroll-value current-position}
        }
        
        let col-layouts:SkRGColumnLayouts = self._col-layouts
        let max-offset:double = col-layouts.max-offset / 1cm
        let avail-width:double = col-layouts.scrollable-width / 1cm
        set self._hscroll.display? = ((max-offset > 0 and avail-width > 0) or
                                      self._hscroll-toggle-cnt > 3)
        {if self._hscroll.display? then
            let sb:Scrollbar = {non-null self._hscroll.contents} 
            set sb.blocksize = avail-width
            set sb.thumb-length = sb.blocksize
            set sb.max = sb.adjusted-thumb-length + max-offset
            {sb.set-scroll-value col-layouts.offset / 1cm}
        }

        {if vscroll-display? != self._vscroll.display? then
            {inc self._vscroll-toggle-cnt}
        }
        
        {if hscroll-display? != self._hscroll.display? then
            {inc self._hscroll-toggle-cnt}
        }

    }
  }
  
  ||---------------------------------------------
  || Miscellaneous Private Methods
  ||----------------------------------------------
  
  {method private {pull-arg args:Arguments, name:String, default:bool}:bool
    let (arg:any, found?:bool) = {args.get-keyword-argument-if-exists name}
    {if found? then
        {args.remove-keyword name}
        {return arg asa bool}
     else
        {return default}
    }       
  }
  
  {method private {get-cell-column
                      cell:RecordGridCell
                  }:int
    {return 
        {if-non-null col = cell.column then 
            {self.grid.columns.find col}   
         else
            -1
        }
    }
  }
  
  {method private {increment-data-epoch}:void
    {inc self._data-epoch}
    || unlikely paranoia: handle case where the epoch wraps
    {if self._data-epoch <= 0 then
        {self.destroy-all-rows}
    }
  }
  
  || We want the internal-grid to take any *non-transparent* background set
  || on the control, to allow user to specify this area.  Otherwise use 
  || a shade of control-color to distinguish the area grid control area.
  {method private {synchronize-internal-background}:void
    {if-non-null back = self._grid-background then
        {if back != Background.transparent then
            set self._internal-grid.background = back
            {return}
        }
    }
    set self._internal-grid.background = {get-shadow-for self.control-color} 
  }
  
  {nonlocal-option public control-color:FillPattern
    {self.synchronize-internal-background}
    {self.request-draw}
  }
  
  ||---------------------------------------------
  || ActiveTraversalContainer implementation.
  ||----------------------------------------------
  
  || Unused notifications. 
  {method protected open {register-active-traversor at:ActiveTraversor}:void} 
  {method protected open {unregister-active-traversor at:ActiveTraversor}:void}
  {method public open {react-to-child-change at:ActiveTraversor}:void}
  
  {method public open {traverse forward?:bool = true}:bool
    {if-non-null cell = 
        {self.get-next-cell-for-traversal forward? = forward?} 
     then
        {return
            {cell.become-active-from-traversal forward? = forward?}
        }
    }
    {return false}
  }
  
  || Find the "next" cell that can theoretically become active /
  || gain the grid-focus, either forward or backwards.
  {method package {get-next-cell-for-traversal
                      forward?:bool = true
                  }:#RecordGridCell
    let cols:{Array-of RecordGridColumn} = self.grid.columns

    {if cols.size > 0 and self._data-row-count > 0 then
        
        || 1) Scan for next cell. 
        
        || 1a) initialize start to just to left of first or last record. 
        let row-index:int = 
            {if forward? then 
                self.frozen-row-start
             else
                self._data-row-count - 1
            }
        let col-index:int = -1 
        let scan-required?:bool = true
        let start-found?:bool = false
        
        || 1b) modify start if we have a focused cell, 
        || or certain selections, or a current record
        {if-non-null cell = self.grid-focus then
            set row-index = cell.record-index
            set col-index = {self.get-cell-column cell}
            set start-found? = true
        }
        
        {if not start-found? and not self.grid.selection.empty? then
            
            set (row-index, col-index) = {self.pick-selected-cell}
            {if row-index != -1 and col-index != -1 then
                set start-found? = true
                set scan-required? = false
            }
            
        }
        
        {if not start-found? and self.grid.current-index != -1 then
            set row-index = self.grid.current-index
        }
        
        || 1c) Scan 
        let wrap-count:int = 0
        {while wrap-count < 2 do
            {if scan-required? then
                {if forward? then {inc col-index}  else {dec col-index}}
             else
                {inc wrap-count, 2}
            }
            
            || Jump to new row if must.
            {if col-index >= cols.size then
                {inc row-index}
                set col-index = self.frozen-col-start
                {inc wrap-count}
             elseif col-index < self.frozen-col-start then
                {dec row-index}
                set col-index = cols.size - 1
                {inc wrap-count}
            } 

            || Break conditions
            {if row-index < self.frozen-row-start or 
                row-index >= self._data-row-count 
             then
                {break}
            }

            || Check that the cell is focusable; return it if it is.
            let cell:RecordGridCell = {self.get-data-row row-index}[col-index]
            {if cell.cells-take-focus? then
                {return cell}
            }
        }
    }
    
    || 2) No cell found to take focus, fail.
    {return null}
  }
  
  || Traverse for vertical movement.
  {method private {vtraverse 
                      new-row:int,
                      forward?:bool,
                      set-first-visible?:bool = false
                  }:bool

    || Normalize new-row request
    set new-row = {min {max new-row, 0}, self._data-row-count - 1}
    
    {if new-row < self.frozen-row-start then {return false}}
        
    || We need to move row first, so that cell will be in view and can
    || be traversed to. And we want to move to a new row even if cell
    || traversal fails.  This is a bit different from {traverse}
    {if new-row != self.grid.current-index and 
        new-row != -1 and
        {self.grid.request-current-record-change new-row}
     then
        {if set-first-visible? then
            set self.first-scrollable-row = new-row
        }
                
        || Activate cell or ui
        {if self.grid-focus == null or
            not self.grid-focus.cells-take-focus? or
            not {self.grid-focus.become-active-from-traversal 
                    forward? = forward?}
         then
            {self.become-active forward? = forward?}
        }
        {return true}
    }
    
    {return false}
  }
  
  {setter public open {current-active at:#ActiveTraversor}:void
    {type-switch at
     case rgc:RecordGridCell do 
        {self.set-grid-focus rgc}
     case at:ActiveTraversor do
        {error 
            {hlmessage 
                SkinnableRecordGridUI.current-active may only be set
                to a subclass of RecordGridCell. This error may have
                occurred because an ActiveTraversor has been placed within
                a RecordGridCell without establishing an independent
                ActiveTraversalContainer for it.  See the documentation
                for RecordGridCell for more information.
            }
        }       
     else    
        {self.set-grid-focus null}
    }
  }
  
  {getter public open {current-active}:#ActiveTraversor
    {return self.grid-focus}
  }
  
  {method public open {become-active forward?:bool = true}:bool
    
    || Make sure that the grid itself is current-active in its container.
    {if-non-null atc = self.grid.active-traversal-container then
        {atc.insist-active self.grid}
    }
    
    || Attempt to trampoline activeness directly to active cell
    {if-non-null curr = self.current-active then
        {if {curr.become-active forward? = forward?} then
            {return true}
        }
    }   
    {self.grid.selection-context-request-activate}
    {self.request-key-focus}
    {return true} 
  }

  {method public open {become-active-from-traversal forward?:bool = true}:bool
    
    let constant ret:bool = {self.become-active forward? = forward?}
    
    {if ret then
        || Trampoline the become-active to cell, if possible
        {if-non-null curr = self.current-active then
            {if {curr.become-active-from-traversal forward? = forward?} then
                {return ret}
            }
        }
        {if {self.traverse forward?=forward?} then
            {return ret}
        }
        
    }

    {return ret} 
  }
  
  {method public open {resize-column-range
                          start-index:int,
                          end-index:int,
                          delta:Distance
                      }:void
    {if start-index < 0 or end-index < 0 then {return}}
    let constant grid:RecordGrid = self.grid
    let constant cols:{Array-of RecordGridColumn} = grid.columns
    let constant size:int = cols.size
    {if start-index >= size or end-index >= size then {return}}
    {self._internal-grid.resize-column-range start-index, end-index, delta}
  }

  {method public open {get-test-tabular-attributes
                      }:(full-size:int,
                         min-visible-row:int,
                         max-visible-row:int)
    {return
        self.grid.records.size,
        self.first-visible-row,
        self._internal-grid.last-row-displayed
    }
  }

  ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
  || Fix for 26194: Try not to lose or redirect pending edits on
  || shared editor Controls.
  ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

  {method public open {note-filter-changing}:void
    {if-non-null focus-cell = self.grid-focus then
        {focus-cell.commit-pending-value}
    }
  }

  || Skinnability

  {getter public open {control-feel}:ProtoRecordGridFeel
    {return super.control-feel asa ProtoRecordGridFeel}
  }

  {nonlocal-option public enabled?:bool
    set self.visual-state = 
        {if self.enabled? then
            "enabled" ||""
         else
            "disabled" ||""
        }
    {self.request-draw}
  }

}


||-------------------------------------------------------------
|| SkRGInternalGrid
||
|| Internal box used to layout the rows of SkinnableRecordGridUI.
||-------------------------------------------------------------
{define-class package SkRGInternalGrid
  {inherits ClipFrame, ContainerDragScroller}

  let package constant _size-preference:OriginElastic =
      {make-origin-elastic
        last =
            {make-elastic
                minimum-size = 0m,
                preferred-size = 100m,
                compress-order = rigid-compress-order,
                stretch-order = compliant-stretch-order
            }
      }

  field private constant _ui:ProtoSkinnableRecordGridUI
  field private constant _vbox:VBox
  
  || misc. state
  field private _last-row-displayed:int = -1
  field private _est-row-dim:Distance = 1cm
  field private _ensure-visible-row:int = -1
  field private _has-header-slot?:bool = false
  field private _header-slot-count:int = 0
  field private _refreshing-display?:bool = false
  
  || The index of the hidden row at the end of the internal VBox.
  || The final row should be 0 height.
  || If there is no such row, this index should be set to -1.
  field package hidden-row-index:int = -1
  
  || cached drawing options
  field package _horizontal-grid-line-width:Distance
  field package _vertical-grid-line-width:Distance
  field package _grid-line-color:FillPattern
  field package _grid-line-frozen-color:FillPattern
  field package _control-color:FillPattern
  field package _control-color-shadow:FillPattern
  field package _control-color-highlight:FillPattern
  field package _control-content-background:Background
  field package _alternate-row-background:Background
  field private _scratch-draw-grect:GRect = {GRect.empty}

  || Gesture interpretation.  
  
  || These fields give info about state of current pointer "grab"
  || They are reinitialized on grab release
  field package _resize-col:int = -1
  field private _resize-col-x:Distance = 0m
  field private _move-col:int = -1
  field private _move-col-target:int = -1
  field private _anchor-layer:int = 0
  field private _pending-click-target:#Graphic = null
  field private _selecting?:bool = false
  field private _drag-selecting?:bool = false
  
  || Tracking for selection gestures.
  field package _row-selection-anchor:int = -1
  field package _row-selection-point:int = -1
  field package _col-selection-anchor:#BaseRecordGridColumn = null 
  field package _region-selection-anchor:#RecordGridRegion = null
  field package _region-selection-transient:#RecordGridRegion = null

  || These fields track whether there's a continuing, additive row selection
  || gesture in progress; we need to cache the selection when one starts
  || so that we can later diff it with the current selection.
  field package _previous-row-selection-set?:bool = false
  field package _previous-row-selection:{Array-of int} = {new {Array-of int}}
  field package _previous-col-selection:{Array-of RecordGridColumn} =
      {new {Array-of RecordGridColumn}}
  field package _previous-region-selection:{Array-of RecordGridRegion} =
      {new {Array-of RecordGridRegion}}
  
  || A scratch Array of rows that are currently being deselected.
  || This is used by continue-row-selection and cached-selection-valid?
  || to avoid resetting the cached selection in the middle of a gesture.
  field private _row-deselecting-array:{Array-of int} = {new {Array-of int}}

  || Track clicks; e.g. to guard against "mid-click" scrolling.  
  field private _context-row:int = -2
  field private _context-column:int = -2

  {constructor package {default ui:ProtoSkinnableRecordGridUI}
    
    set self._ui = ui
        
||--    set self.width = SkRGInternalGrid._size-preference
||--    set self.height = SkRGInternalGrid._size-preference
    set self.cursor = null
    set self.horigin = 0.0
    set self.vorigin = 0.0
    
    || cache options
    set self._horizontal-grid-line-width = 
        {self.any-to-Distance self.horizontal-grid-line-width}
    set self._vertical-grid-line-width = 
        {self.any-to-Distance self.vertical-grid-line-width}
    set self._grid-line-color = self.grid-line-color
    set self._grid-line-frozen-color = 
        {self.get-offset-color-for-freeze self._grid-line-color}
    set self._control-color = self.control-color
    set self._control-color-shadow = {get-shadow-for self._control-color}
    set self._control-color-highlight = {get-highlight-for self._control-color}
    set self._control-content-background = self.control-content-background
    set self._alternate-row-background = self.alternate-row-background

    || build internal hierarchy
    set self._vbox = {VBox 
                         spacing = self._horizontal-grid-line-width,
                         vorigin = 0.0,
                         horigin = 0.0
                     } 
    {construct-super.ClipFrame self._vbox}
    {construct-super.ContainerDragScroller}
  }
  
  ||-------------------------------------------------------------
  || Layout
  ||
  || + This object specifies its origin to be the top left corner
  || + It aggressively stretches, and mildly resists compression
  ||   to interact well with the scrollbars it is adjacent with.
  || + Size preference is independent of size preference of child
  || + Child is clipped (see ClipFrame.)
  || + IMPORTANT NOTE: This object assumes that its origin
  ||   and its child VBox's origin are juxtaposed in the top
  ||   left corner of the two objects.  This greatly simplifies 
  ||   the drawing and layout calculations. 
  ||-------------------------------------------------------------  
  
  {method public open {set-size lc:LayoutContext, bounds:GRect}:void 
    {super.set-size lc, bounds}

    let ui:ProtoSkinnableRecordGridUI = self._ui
    
    let constant frozen-count:int = ui.frozen-row-count
    let constant frozen-start:int = ui.frozen-row-start
    
    || 1) If layout settled down, check that "ensure-visible-row" is visible.
    || If not visible, we need to scroll (which will trigger a new layout)
    || Note: This code block must scroll, or set ensure-visible-row to -1
    {if self.layout-valid? and self._ensure-visible-row != -1 then
        {if self._ensure-visible-row == ui.first-scrollable-row or
            self._ensure-visible-row < (frozen-count + frozen-start)
         then
            || 1a) Nothing to be done!
            set self._ensure-visible-row = -1
         elseif self._ensure-visible-row < ui.first-scrollable-row or 
            self._last-row-displayed == -1
         then
            || 1b) scroll record above to top, all we can do
            set ui.first-scrollable-row = self._ensure-visible-row
            set self._ensure-visible-row = -1
         elseif self._ensure-visible-row > self._last-row-displayed then
            || 1c) bring record below into layout, wait for new layout 
            {inc ui.first-scrollable-row,
                self._ensure-visible-row - self._last-row-displayed
            }
         else
            || 1d) Check laid out row, if clipped then bump up x rows
            || (where x is always at least one),
            let constant index:int =
                (self._ensure-visible-row - 
                 ui.first-scrollable-row + 
                 frozen-count)
            let deficit:Distance = {self.row-descent index} - bounds.height
            {if deficit < 0cm then 
                set self._ensure-visible-row = -1
             else
                {for i:int = 1 below self._data-slot-count do
                    let sl:Layout = {self.data-slot i}
                    {dec deficit, {sl.get-cell-bounds}.height}
                    {if deficit < 0cm then
                        {inc ui.first-scrollable-row, i}
                        {break}
                    }
                }
            }
        }
    }
    
    || 2) If layout still settled down, check to see if
    || we need to augment or trim the number of rows in child
    || Keep child between 1.0 and 1.2 times the size needed.   
    {if self.layout-valid? then
        
        let vbox-dim:Distance = {self._vbox.layout.get-cell-bounds}.height
        let child-excess:Distance = vbox-dim - bounds.height
        
        || Update the row-size estimate.
        || Horizontal grid line width cancels itself in this equation,
        || and is included in the estimated row dimension.
        let data-dim:Distance = vbox-dim - self.header-block-descent
        
        {if self._data-slot-count > 0 and data-dim > 0cm then
            set self._est-row-dim = data-dim / self._data-slot-count
        }
        
        {if child-excess < -{max self._horizontal-grid-line-width, 0.1mm} then
            || Augment rows based on size of current rows.
            || Target is 1.1 times the size needed.
            {self.add-data-slots 
                {ceiling 
                    ((bounds.height * 1.1) - vbox-dim) / self._est-row-dim
                } asa int
            } 
         elseif child-excess > 0.2 * bounds.height then
            || Reduce rows based on actual layout.
            || Never reduce beyond 1.1 * bounds or below a single row.
            let cnt:int = 0
            {for i:int = self._data-slot-count - 1 above 0 do
                let sl:Layout = {self.data-slot i}
                let (x:Distance, y:Distance) = {sl.get-origin-in-parent}
                {if y > bounds.height * 1.1 then
                    {inc cnt}
                 else
                    {break}
                }
            }
            {self.remove-data-slots cnt}
        }
    }
    
    || Synchronize the UI if layout finished
    {if self.layout-valid? then
        {ui.synchronize-navigation}
    }
  }  
  
  || VBox child count minus headers and the hidden row.
  {getter private {_data-slot-count}:int
    {return 
        self._vbox.child-array.size
        - self._header-slot-count
        - {if self.hidden-row-index >= 0 then 1 else 0}
    }
  }
  
  {method private {header-slot i:int}:#SequenceLayout
    {if i >= self._header-slot-count then
        {return null}
     else
        {return self._vbox.child-array[i]}        
    }
  }

  {method private {data-slot i:int}:SequenceLayout
    {inc i, self._header-slot-count}
    {if i >= self._vbox.child-array.size then
        {error
            {hlmessage
                Internal error in ProtoSkinnableRecordGridUI. Cannot 
                find data slot '{value i}' in SkRGInternalGrid.
            }
        }
    }
    {return self._vbox.child-array[i]}
  }
  
  || Get the row index containing the current grid-focus cell.
  {getter private {focus-record-index}:int
    let constant grid-focus:#RecordGridCell = self._ui.grid-focus
    {return
        {if-non-null grid-focus then
            grid-focus.record-index
         else
            -1
        }
    }
  }

  || Note that when the appropriate rows are already being 
  || shown this should execute quickly and not trigger layout
  || or option storms. Resetting slots to the same object is a no-op!
  {method private {refresh-row-contents}:void

    || 0) Setup
    
    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    
    || 1) Confirm header rows.
    
    {ui.resync-header-rows}
    let constant ui-header-count:int = ui._header-rows.size

    {for i = ui._header-rows.size - 1 downto 0 do
        let constant slot-index:int = ui-header-count - i - 1
        {if-non-null header-row = {ui.get-header-row i} then
            {if slot-index < self._vbox.child-array.size then
                let constant slot-graphic:Graphic = 
                    self._vbox.child-array[slot-index].graphic
                {if slot-graphic != header-row then
                    {slot-graphic.replace-with header-row}
                }
             else
                {self._vbox.add header-row}
            }
            {header-row.ensure-valid}
         else
            {error "internal layout error"} ||""
        }
    }
    
    || 1a) Remove unused headers.
    
    let constant header-removal-start:int =
        {min self._header-slot-count, self._vbox.child-array.size} - 1
    {for i = header-removal-start downto ui-header-count do
        let constant slot-graphic:Graphic = self._vbox.child-array[i].graphic
        {slot-graphic.detach}
    }
    
    set self._header-slot-count = ui._header-rows.size
    {if self._header-slot-count >= 1 then
        set self._has-header-slot? = true
     else
        set self._has-header-slot? = false
    }
        
    
    || 2) Confirm data rows until there are no more rows, or slots.
    
    let constant frozen-count:int = ui.frozen-row-count
    let constant frozen-start:int = ui.frozen-row-start
    let constant last-frozen-index:int = frozen-start + frozen-count - 1

    let constant focus-record-index:int = self.focus-record-index
    let hidden-row-added?:bool = false
    
    || 2a) First Pass
    || Ensure data present and valid and shift any
    || rows that can be efficiently shifted into position 
    || (i.e. without pulling out of box gratuitously).
    let slot-index:int = 0 
    let row-index:int = 
        {if frozen-count == 0 then
            || prevents invalidation loops: see P25178
            {max frozen-start, ui.first-scrollable-row}            
         else
            frozen-start
        }
    {while (row-index >= 0 and
            row-index < ui._data-row-count and
            slot-index < self._data-slot-count
           )
     do
        let curr-row:SkRGDataRow = {ui.get-data-row row-index}
        {curr-row.ensure-valid}
        let curr-slot:SequenceLayout = {self.data-slot slot-index}
        {if curr-slot.graphic != curr-row and
            curr-row.parent == self._vbox 
         then
            {self._vbox.swap-children curr-row, curr-slot.graphic}
        }
        {if self.hidden-row-index >= 0 and
            row-index == focus-record-index
         then
            {unset curr-row.height}
            set hidden-row-added? = true
        }
        {if row-index == last-frozen-index then
            || Ensure that we've pushed the first-scrollable-row up
            || past the freeze boundary, if necessary.
            {if last-frozen-index >= ui.first-scrollable-row then
                {ui.force-set-first-scrollable-row 
                    {if ui._data-row-count > last-frozen-index + 1 then
                        last-frozen-index + 1
                     else
                        -1
                    }
                }
            }
            set row-index = ui.first-scrollable-row
         else
            {inc row-index}
        }
        {inc slot-index}
    }
    
    || 2b) Second Pass
    || Actually place new rows in vbox, releasing old rows being removed.

    || If the grid-focus row swapped in, or we see another row
    || has gotten the grid-focus, release the final row.
    {if hidden-row-added? or
        (self.hidden-row-index >= 0 and
         self.hidden-row-index != self.focus-record-index)
     then
        let constant final-row:SequenceLayout =
            {self.data-slot self._data-slot-count}
        let constant srgdr:SkRGDataRow = final-row.graphic asa SkRGDataRow
        {final-row.detach}
        {ui.release-data-row srgdr}
        set self.hidden-row-index = -1
     elseif self.hidden-row-index >= 0 then
        || Ensure that the focus row is kept valid.
        let constant hidden-row:SkRGDataRow =
            {ui.get-data-row self.hidden-row-index}
        {hidden-row.ensure-valid}
    }
        
    set slot-index = 0 
    set row-index = 
        {if frozen-count == 0 then
            || prevents invalidation loops: see P25178
            {max frozen-start, ui.first-scrollable-row}             
         else
            frozen-start
        }
    set self._last-row-displayed = -1
    {while (row-index >= 0 and
            row-index < ui._data-row-count and
            slot-index < self._data-slot-count
           )
     do
        let curr-slot:SequenceLayout = {self.data-slot slot-index}
        let curr-row:SkRGDataRow = {ui.get-data-row row-index}
        {if curr-slot.graphic != curr-row then
            let row:SkRGDataRow = curr-slot.graphic asa SkRGDataRow
            {if row.index == focus-record-index then
                || Add the new row at the end, swap with the focus row,
                || then collapse the focus row (so that it's at the end).
                {self._vbox.add curr-row}
                {self._vbox.swap-children row, curr-row}
                set row.height = 0m
                set self.hidden-row-index = focus-record-index
             else
                {row.replace-with curr-row}
                {ui.release-data-row row}
            }
        }
        set self._last-row-displayed = row-index
        {if row-index == last-frozen-index and
            ui.first-scrollable-row >= 0
         then
            set row-index = ui.first-scrollable-row
         else
            {inc row-index}
        }
        {inc slot-index}
    }
    
    || 3) Remove any extraneous slots.
    {self.remove-data-slots (self._data-slot-count - slot-index)}
    
  }

  || Remove N slots from the end of the internal VBox.
  {method private {remove-data-slots count:int}:void
    set count = {min count, self._data-slot-count}

    let constant focus-row-index:int = self.focus-record-index
    let constant child-array:{Array-of SequenceLayout} =
        self._vbox.child-array
    let constant ca-size:int = child-array.size
    let offset:int = 1
    
    {if self.hidden-row-index >= 0 then
        {if self.hidden-row-index != focus-row-index then
            || If the hidden row is the wrong one, remove it too.
            set self.hidden-row-index = -1
            {inc count}
        
         else
            let constant row:SkRGDataRow =
                {child-array.top-of-stack}.graphic asa SkRGDataRow
            {if row.index >= 0 then
                || If there's a hidden row that's current,
                || skip it when removing rows.
                {inc offset}
             else
                || If the hidden row is invalid, remove it too.
                set self.hidden-row-index = -1
                {inc count}
            }
        }
    }
    
    {for i:int = 0 below count do
        let constant row:SkRGDataRow = 
            child-array[ca-size - i - offset].graphic asa SkRGDataRow

        {if focus-row-index != -1 and
            row.index == focus-row-index and
            self.hidden-row-index == -1
         then
            || Leave the focus row in place but collapse it.
            set self.hidden-row-index = focus-row-index
            set row.height = 0m
            {continue}
        }
        
        || Detach and cache rows that should actually be removed.
        {row.detach}
        {self._ui.release-data-row row}
    }

    set self._last-row-displayed =
        {min 
            self._last-row-displayed,
            {if self._ui.first-scrollable-row >= 0 then
                (self._ui.first-scrollable-row + 
                 self._data-slot-count - 
                 self._ui.frozen-row-count -
                 1) 
             else
                ({max 0, self._ui.first-visible-row} + 
                 self._data-slot-count - 
                 1)
            }
        }
  }
  

  {method private {add-data-slots count:int}:void
    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    let constant next-row:int = self._last-row-displayed + 1
    set count =
        {min
            count,
            ui._data-row-count - next-row - ui.frozen-row-start
        }

    {if count > 0 then
        {for i:int = 0 below count do
            let constant data-row-index:int = next-row + i
            let constant data-row:SkRGDataRow = {ui.get-data-row data-row-index}
            
            || If we would be adding the hidden row, instead uncollapse it.
            {if data-row-index == self.hidden-row-index then
                {unset data-row.height}
                set self.hidden-row-index = -1
             elseif self.hidden-row-index >= 0 then
                {self._vbox.add
                    data-row,
                    index = self._vbox.child-array.size - 1
                }
             else
                {self._vbox.add data-row}
            }
        }
        
        {self.refresh-row-contents}
    }
  }
  
  || Whether a vertical scroll would actually produce a visible change.
  || If only frozen rows are visible, or all rows are displayed fully,
  || this will return false.
  {getter package {vscroll-visible?}:bool
    {return 
        self._data-slot-count >= self._ui.frozen-row-count and
        || FIXME: not quite correct, might miss last row or so:
        (self._data-slot-count <=
         (self._ui._data-row-count - self._ui.frozen-row-start))
    }
  }
  
  ||---------------------------------------------------------------
  || Gesture Interpretation
  ||
  || Notes: 
  ||
  || -  The internal grid consumes all left pointer presses and releases.
  ||    Right presses are consumed, but right releases are passed through
  ||    to allow the generation of ContextMenuEvents
  || -  Presses can trigger selection activity on columns, rows, or regions;
  ||    Such presses grab the pointer and discard the related release.
  || -  Completing a true left "click" (press and release) on the header 
  ||    will sort the header. 
  || -  Any other release outside the column area will select nothing.
  || -  Dragging on header or resize area will trigger resize/or move.  
  ||    gesture.  These gestures are updated during pointer motion.
  ||---------------------------------------------------------------
  
  {method public open {on-pointer-press ev:PointerPress}:void
    def grid = self._ui.grid
    def old-index = grid.current-index
    {self.on-pointer-press-aux ev}
    def new-index = grid.current-index
    {if old-index != new-index then
        || Record the index.
        {grid.test-record "SetCurrentIndex", new-index} ||""
    }
  }

  {method private {on-pointer-press-aux ev:PointerPress}:void
    
    set self._pending-click-target = null
    
    || 1) No response
    {if ev.consumed? or 
        not self.enabled? or
        {self.get-resize-col-for-point ev.x, ev.y} != -1 
     then
        {super.on-pointer-press ev}
        {return}
    }
    
    {if ev.button != right-button then
        set ev.test-recorded? = true
    }

    let constant grid:RecordGrid = self._ui.grid
    let constant (target:Graphic, row-index:int, col-index:int) = 
        {self.map-point ev.x, ev.y}
    
    let constant grid-focus:#RecordGridCell = self._ui.grid-focus
    let focus-record:int = -1
    let focus-column:int = -1
    {if-non-null grid-focus then
        set focus-record = grid-focus.record-index
        {if-non-null column = grid-focus.column then
            set focus-column = 
                {self._ui.grid.columns.find column}
        }
    }
    
    let constant old-index:int = grid.current-index

    || 2)  try row selection
    {if not ev.consumed? and
        ev.click-count == 1 and
        row-index != -1 and 
        grid.record-selection-enabled? and 
        (target isa SkRGRecordSelector or 
         grid.select-current-record? or
         (grid.record-selection-enabled? and
          (ev.shift? or ev.accel?))
        ) and
        || As we are about to select a record, we should not activate
        || a cell on switching current record.
        {with self._ui._adjust-record-focus? = false,
            self._selecting? = true
         do
            {grid.request-current-record-change row-index}
        }
     then 
        let selection:RecordGridSelection = grid.selection
        
        || Initialize anchor if needed.
        {if not ev.shift? or   
            not {selection.contains-record? self._row-selection-anchor} 
         then
            {if old-index >= 0 and ev.shift? then
                set self._row-selection-anchor = old-index
             else
                set self._row-selection-anchor = row-index
            }
        }

        let continuing-row-selection?:bool = false

        {if ev.button == right-button then
            || 2a) For right click, simply ensure selection contains
            || this row. Ignore modifiers.
            {if not {selection.contains-record? row-index} then
                {grid.test-record "SelectRow", row-index} ||""
                {grid.select-record row-index, additive? = false}
            }
            
         elseif ev.shift? and grid.multiple-selection-enabled? then
            || 2b) In shift mode, select between row-index and anchor.

            set continuing-row-selection? = true
            set self._row-selection-point = row-index
            {self.check-start-continuing-row-selection}
            {self.continue-row-selection}
            
            {grid.test-record
                "ExtendRowsRange", ||""
                self._row-selection-anchor,
                row-index
            }
            {grid.select-record-range
                self._row-selection-anchor,
                row-index,
                additive? = true
            }
            
         elseif ev.accel? then
            || 2c) In ctrl-mode, toggle this row.
            {if not {selection.contains-record? row-index} then
                {grid.test-record "ExtendRow", row-index} ||""
                {grid.select-record row-index, additive? = true}
             else
                {grid.test-record "DeselectRow", row-index} ||""
                {grid.deselect-record row-index}
            }
            
         else
            || 2d) Otherwise, select this row.
            {grid.test-record "SelectRow", row-index} ||""
            {grid.select-record row-index, additive? = false}    
        }

        || Clear out any cached selection so we don't get confused.
        {if not continuing-row-selection? then
            {self.clear-cached-selection}
        }
        
        {ev.consume}
    }

    || 3) Otherwise try column selection.
    {if not ev.consumed? and
        ev.click-count == 1 and
        col-index != -1 and
        grid.column-selection-enabled? and 
        target isa SkRGColumnSelector
     then
        let column:RecordGridColumn = grid.columns[col-index]
        let selection:RecordGridSelection = grid.selection
        let contains-col?:bool = {selection.contains-column? column}
        
        || Initialize the anchor if needed.
        {if not ev.shift? or
            self._col-selection-anchor == null or 
            not {selection.contains-column?
                    {non-null self._col-selection-anchor}
                }
         then
            set self._col-selection-anchor = column
        }
        
        {if ev.button == right-button then
            || 3a) For right click, simply ensure selection contains
            || this column. Ignore modifiers.
            {if not contains-col? then
                {grid.test-record "SelectColumn", col-index} ||""
                {grid.select-column column, additive? = false}
            }
            {ev.consume}
            
         elseif ev.shift? and grid.multiple-selection-enabled? then
            || 3b) In shift mode, select between column and selection-anchor.
            {if contains-col? then
                {grid.test-record "SelectColumn", col-index} ||""
                {grid.select-column column, additive? = false}
             else
                let constant far-index:int =
                    {type-switch self._col-selection-anchor
                     case rgcg:RecordGridColumnGroup do
                        {if rgcg.first-column-index < col-index then
                            rgcg.first-column-index
                         else
                            rgcg.last-column-index
                        }
                     case rgc:RecordGridColumn do
                        {grid.columns.find rgc}
                     else
                        -1
                    }
                {grid.test-record
                    "SelectColumnsRange", ||""
                    far-index,
                    col-index
                }
                {grid.select-column-range
                    {non-null self._col-selection-anchor},
                    column,
                    additive? = false
                }
            }
            {ev.consume}
            
         elseif ev.accel? then
            || 3c) In ctrl-mode toggle this column.
            {if not contains-col? then
                {grid.test-record "ExtendColumn", col-index} ||""
                {grid.select-column column, additive? = true}
             else
                {grid.test-record "DeselectColumn", col-index} ||""
                {grid.deselect-column column}
            }
            {ev.consume}
            
         else
            || 3d) otherwise select if selecting would do something
            || (This allows repeat gesture to click )
            {if not contains-col? or
                selection.record-count > 0 or
                selection.region-count > 0 or
                selection.column-count > 1 
             then
                {grid.test-record "SelectColumn", col-index} ||""
                {grid.select-column column, additive? = false}
                {ev.consume}
            }
        }
    }
    
    || 4) Column group selection.
    {if not ev.consumed? and
        ev.click-count == 1 and
        grid.column-selection-enabled? and 
        target isa SkRGSharedColumnHeader
     then
        let constant target-header:SkRGSharedColumnHeader =
            target asa SkRGSharedColumnHeader
        let constant group:RecordGridColumnGroup = target-header.column-group

        {if not group.has-concrete-child-column? or
            (not grid.multiple-selection-enabled? and
             (group.first-column-index != group.last-column-index))
         then
            {ev.consume}

         else
            let constant first-column:RecordGridColumn = 
                grid.columns[group.first-column-index]
            let constant last-column:RecordGridColumn = 
                grid.columns[group.last-column-index]
            let selection:RecordGridSelection = grid.selection
            let contains-col?:bool = {selection.contains-column? group}
            
            || Initialize the anchor if needed.
            {if not ev.shift? or
                self._col-selection-anchor == null or 
                not {selection.contains-column?
                        {non-null self._col-selection-anchor}
                    }
             then
                set self._col-selection-anchor = group
            }
            
            {if ev.button == right-button then
                || 4a) For right click, simply ensure selection contains
                || this column. Ignore modifiers.
                {if not contains-col? then
                    {grid.test-record
                        "SelectColumnsRange", ||""
                        group.first-column-index,
                        group.last-column-index
                    }
                    {grid.select-column group, additive? = false}
                }
                {ev.consume}
                
             elseif ev.shift? and grid.multiple-selection-enabled? then
                || 4b) In shift mode, select between column and anchor.
                {if contains-col? then
                    {grid.test-record
                        "SelectColumnsRange", ||""
                        group.first-column-index,
                        group.last-column-index
                    }
                    {grid.select-column group, additive? = false}
                    
                 else
                    let near-index:int = -1
                    let far-index:int = -1
                    {type-switch self._col-selection-anchor
                     case rgcg:RecordGridColumnGroup do
                        set near-index =
                            {min
                                rgcg.first-column-index,
                                group.first-column-index
                            }
                        set far-index = 
                            {max
                                rgcg.last-column-index,
                                group.last-column-index
                            }
                     case rgc:RecordGridColumn do
                        set near-index = {grid.columns.find rgc}
                        set far-index = near-index
                    }
                    {grid.test-record
                        "SelectColumnsRange", ||""
                        near-index,
                        far-index
                    }
                    {grid.select-column-range
                        {non-null self._col-selection-anchor},
                        group,
                        additive? = false
                    }

                }
                {ev.consume}
                
             elseif ev.accel? then
                || 4c) In ctrl-mode toggle this column.
                {if not contains-col? then
                    {grid.test-record
                        "ExtendColumnsRange", ||""
                        group.first-column-index,
                        group.last-column-index
                    }
                    {grid.select-column group, additive? = true}
                 else
                    {grid.test-record
                        "DeselectColumns", ||""
                        group.first-column-index,
                        group.last-column-index
                    }
                    {grid.deselect-column group}
                }
                {ev.consume}
                
             else
                || 4d) otherwise select if selecting would do something
                || (This allows repeat gesture to click )
                {if not contains-col? or
                    selection.record-count > 0 or
                    selection.region-count > 0 or
                    selection.column-count > 1 
                 then
                    {grid.test-record
                        "SelectColumnsRange", ||""
                        group.first-column-index,
                        group.last-column-index
                    }
                    {grid.select-column group, additive? = false}
                    {ev.consume}
                }
            }
        }
    }
    
    || 5) Otherwise try region selection
    {if not ev.consumed? and
        ev.click-count == 1 and
        grid.region-selection-enabled? and
        col-index != -1 and
        row-index != -1 and 
        {with self._ui._adjust-record-focus? = false,
            self._selecting? = true
         do
            {grid.request-current-record-change row-index}
        }
     then
        let selection:RecordGridSelection = grid.selection
        let contains-cell?:bool = 
            {selection.regions-contain-cell? row-index, col-index}
        let cell-as-region:RecordGridRegion = 
            {RecordGridRegion row-index, col-index, 1, 1}
        
        || init anchor if needed.
        {if ev.shift? and
            self._region-selection-anchor == null and
            focus-record != -1 and
            focus-column != -1
         then
            set self._region-selection-anchor =
                {RecordGridRegion focus-record, focus-column, 1, 1}
            
         elseif not ev.shift? or 
            self._region-selection-anchor == null or
            not {selection.regions-contain-cell?
                    self._region-selection-anchor.first-row,
                    self._region-selection-anchor.first-column
                }
         then
            set self._region-selection-anchor = cell-as-region
        }
        
        {if ev.button == right-button then
            || 5a) For right click, simply ensure selection contains
            || this cell. Ignore modifiers.
            {if not contains-cell? then
                {grid.test-record "SelectCell", row-index, col-index} ||""
                {grid.select-region cell-as-region, additive? = false}
            }
            {ev.consume}
            
         elseif ev.shift? and grid.multiple-selection-enabled? then
            || 5b) In shift mode, select between cell and selection-anchor
            {grid.test-record
                "SelectCellsRange", ||""
                self._region-selection-anchor.first-row,
                self._region-selection-anchor.first-column,
                row-index,
                col-index
            }
            {grid.select-region
                {RecordGridRegion.from-corners
                    self._region-selection-anchor.first-row,
                    self._region-selection-anchor.first-column,
                    row-index,
                    col-index
                },
                additive?=false
            }
            {ev.consume}
            
         elseif ev.accel? then
            || 5c)  In ctrl-mode either toggle an individual cell, or select
            let constant region-count:int = selection.region-count
            {grid.deselect-region cell-as-region}
            {if region-count == selection.region-count then 
                {grid.test-record "ExtendCell", row-index, col-index} ||""
                {grid.select-region cell-as-region, additive?=true}
            }
            {ev.consume}
            
         else
            || 5d) otherwise select if selecting would do something
            || (This allows repeat gesture to click )
            {if not contains-cell? or
                selection.record-count > 0 or
                selection.column-count > 0 or
                selection.region-count > 1 
             then
                {grid.test-record "SelectCell", row-index, col-index} ||""
                {grid.select-region cell-as-region, additive?=false}
                {ev.consume}
            }
        }
    }
    
    || 6) Otherwise, initiate click, for potential recognition by release
    {if not ev.consumed? then
        set self._pending-click-target = target 
    }

    {grid.become-active}
    {ev.consume}
    {super.on-pointer-press ev}
  }

  || Start a new row selection, caching the existing selection so that
  || we can appropriately manage a new selection from the anchor.
  {method private {check-start-continuing-row-selection}:void
    def prev-rows = self._previous-row-selection
    def selection = self._ui.grid.selection
    {if not self._previous-row-selection-set? then
        {prev-rows.clear}
        {for one-row in selection.records do
            {prev-rows.append one-row}
        }
        def prev-cols = self._previous-col-selection
        {prev-cols.clear}
        {for one-col in selection.columns do
            {prev-cols.append one-col}
        }
        def prev-regions = self._previous-region-selection
        {prev-regions.clear}
        {for one-region in selection.regions do
            {prev-regions.append one-region}
        }                
    }
    set self._previous-row-selection-set? = true
  }
  
  || Update the existing row selection for the current anchor and point,
  || before actually performing the new anchor-point selection.
  {method private {continue-row-selection}:void
    def low-shift-row =
        {min self._row-selection-anchor, self._row-selection-point}
    def high-shift-row =
        {max self._row-selection-anchor, self._row-selection-point}

    def deselect-array = self._row-deselecting-array
    {deselect-array.clear}

    def grid = self._ui.grid
    def prev-rows = self._previous-row-selection
    def selection = grid.selection

    || Collect all rows outside the current selection range so that
    || we can deselect them all at once.
    {for one-row in selection.records do
        {if (one-row < low-shift-row or one-row > high-shift-row) and
            {prev-rows.find one-row} == -1
         then
            {deselect-array.append one-row}
        }
    }

    {for one-row in deselect-array do
        {grid.deselect-record one-row}
    }
  }

  || Check for a change in the cached selection.
  {getter private {cached-selection-valid?}:bool
    {if self._previous-row-selection-set? then
        def selection = self._ui.grid.selection
        {if self._previous-col-selection.size != selection.column-count or
            self._previous-region-selection.size != selection.region-count
         then
            {return false}
         else
            def min-index =
                {min self._row-selection-point, self._row-selection-anchor}
            def max-index =
                {max self._row-selection-point, self._row-selection-anchor}
            {for one-row in selection.records do
                || If the row wasn't in the previous selection...
                {if {self._previous-row-selection.find one-row} == -1 then
                    || ... and it's not in the current range or
                    || about to be deselected, then it's an unknown change. 
                    {if (one-row < min-index or one-row > max-index) and
                        {self._row-deselecting-array.find one-row} == -1
                     then
                        {return false}
                    }
                }
            }
            {for one-col in self._previous-col-selection do
                {if not {selection.contains-column? one-col} then
                    {return false}
                }
            }
            {for one-region in selection.regions do
                {if {self._previous-region-selection.find one-region} == -1 then
                    {return false}
                }
            }
        }
    }
    {return true}
  }
  
  || Clear the cached selection.
  {method private {clear-cached-selection}:void
    set self._previous-row-selection-set? = false
    {self._previous-row-selection.clear}
    {self._previous-col-selection.clear}
    {self._previous-region-selection.clear}
  }

  {method public open {on-pointer-release ev:PointerRelease}:void
    def grid = self._ui.grid
    def old-index = grid.current-index
    {self.on-pointer-release-aux ev}
    def new-index = grid.current-index
    {if old-index != new-index then
        || Record the index.
        {grid.test-record "SetCurrentIndex", new-index} ||""
    }
  }
  
  {method private {on-pointer-release-aux ev:PointerRelease}:void
    
    {if not ev.consumed? and self.enabled? then

        let constant grid:RecordGrid = self._ui.grid
        let (target:Graphic, row-index:int, col-index:int) = 
            {self.map-point ev.x, ev.y}
        let constant was-click?:bool = (target == self._pending-click-target)
        
        || 1) Respond to true single click
        {if was-click? and ev.click-count == 1 then
            {if ev.button == left-button and
                target isa SkRGColumnSelector 
             then
                || 1a) Left click on column may sort.
                let column:RecordGridColumn = grid.columns[col-index]
                {if column.field != null and
                    column.sort-spec != null 
                 then
                    let ascending?:bool = true
                    {type-switch grid.sort
                     case prev:RecordGridColumnSort do
                        set ascending? = 
                            not (prev.column == column and prev.ascending?)
                    }
                    set ev.test-recorded? = true
                    {grid.test-record "ColumnSort", col-index, ascending?} ||""
                    set grid.sort = {RecordGridColumnSort column, ascending?}
                }
                
             elseif target isa SkRGSharedColumnHeader then
                || do nothing
                
             elseif target isa SkRGRecordSelector then
                || 1b) Click on record selector will make record current
                set ev.test-recorded? = true
                {grid.test-record "ActivateRow", row-index} ||""
                set ev.test-recorded? = true
                {grid.request-current-record-change row-index}
                || Make sure the focused cell has become active.
                {if-non-null rgc = grid.ui.grid-focus then
                    {rgc.become-active}
                }
                
             elseif 
                || 1c) Single click outside current selection deselects
                (row-index == -1 or col-index == -1) or
                not {grid.selection.contains-cell? row-index, col-index}
             then
                set ev.test-recorded? = true
                {if not grid.selection.empty? then
                    {grid.test-record "DeselectAll"} ||""
                }
                {grid.select-nothing}
            }
        }

        || 2) Respond to true double click
        {if was-click? and
            ev.click-count == 2 and
            (row-index != -1 or col-index != -1)
         then
            set ev.test-recorded? = true
            {grid.test-record "Action"} ||""
            {grid.enqueue-event {Action}}
        }
        
        || Consume *all* non-right releases
        {if ev.button != right-button then 
            set ev.test-recorded? = true
            {ev.consume}
        }
    }

    set self._pending-click-target = null
    {super.on-pointer-release ev}
  }

  {method public open {on-pointer-motion ev:PointerMotion}:void
    {if self.enabled? and not ev.consumed? then 
        {if self._move-col != -1 then
            set self.cursor = cursor-hand
            
         elseif self._resize-col != -1 or
            {value
                let constant rc:int = 
                    {self.get-resize-col-for-point ev.x, ev.y}
                let constant rl:int = 
                    {self.get-resize-layer-for-point ev.x, ev.y}
                (rc != -1 and
                 (rl == 0 or
                  {self.get-resize-col-at-layer rc, rl} != -1)
                )
            }
         then
            set self.cursor = cursor-size-left-right
            
         else
            set self.cursor = null
        }        
    }
    
    {super.on-pointer-motion ev}
  }
  
  || Check if we have a valid combination of column and layer for resizing.
  || Return -1 for false when the given column would not match the
  || final index of a group at the given layer.
  || Otherwise return the column that we should use as our resize col.
  {method private {get-resize-col-at-layer 
                      base-resize-col:int,
                      layer:int
                  }:int
    {if base-resize-col >= 0 and layer > 0 then
        {if-non-null hr = {self._ui.get-header-row layer} then
            {if hr isa SkRGSharedHeaderRow then
                {if-non-null shared-header = 
                    {(hr asa SkRGSharedHeaderRow).get-header-for-column-index 
                        base-resize-col
                    }
                 then
                    {if base-resize-col == 
                        shared-header.column-group.last-column-index 
                     then
                        {return 
                            shared-header.column-group.first-column-index
                        }
                    }
                }
            }
        }
    }
    {return -1}
  }
  
  {method public open {on-drag-started ev:DragStarted}:void
    {if self.enabled? and 
        not ev.consumed? and
        ev.state-mask.button-1?
     then
        let constant ui:ProtoSkinnableRecordGridUI = self._ui
        let constant grid:RecordGrid = ui.grid
        let constant x:Distance = ev.x
        let constant y:Distance = ev.y
        
        || Potentially start resizing a column or column group.
        {if not ev.consumed? then
            set self._resize-col = {self.get-resize-col-for-point x, y}
            || See if we should be resizing a group.
            set self._anchor-layer = {self.get-resize-layer-for-point x, y}
            let constant new-col:int = 
                {self.get-resize-col-at-layer 
                    self._resize-col, 
                    self._anchor-layer
                }
            || If no valid layer was found, and we had a non-zero layer,
            || do not start a resize.
            {if self._anchor-layer > 0 then
                {if new-col == -1 then
                    set self._resize-col = -1
                    set self._anchor-layer = 0
                    set ev.test-recorded? = true
                    {ev.consume}
                 else
                    set self._resize-col = new-col
                }
            }
            {if self._resize-col != -1 then
                set self._resize-col-x = x
                set ui._disable-vscroll? = true
                set ui._disable-hscroll? = true
                set ev.test-recorded? = true
                set ev.consumed? = true
            }
        }
        
        || or dragging column
        {if not ev.consumed? then
            set self._move-col =
                {self.get-move-col-for-point x, y, start-move? = true}
            {if self._move-col != -1 then
                set self._move-col-target = self._move-col
                set ui._disable-vscroll? = true
                set ev.test-recorded? = true
                set ev.consumed? = true
            }
        }

        
        || or drag selecting regions
        {if not ev.consumed? and
            grid.region-selection-enabled? 
         then
            let constant (row:int, col:int) = 
                {self.get-select-cell-for-point 
                    x, 
                    y, 
                    start-select? = true, 
                    eager? = true
                }
            {if row != -1 and col != -1  then
                set self._drag-selecting? = true
                let region:RecordGridRegion = {RecordGridRegion row, col, 1, 1}
                || Check for a selection that came from the 
                || initial PointerPress; reuse that if possible.
                let old-region:#RecordGridRegion = null
                {for one-region in grid.selection.regions do
                    set old-region = one-region
                }
                {if-non-null old-region then
                    {if {old-region.equal? region} then
                        set self._region-selection-anchor = old-region
                    }
                }
                set self._region-selection-transient = region
                {if old-region == null or
                    self._region-selection-anchor != old-region
                 then
                    set ev.test-recorded? = true
                    {grid.test-record
                        {if ev.accel? then "ExtendCell" else "SelectCell"}, ||""
                        row,
                        col
                    }
                    {grid.select-region region, additive? = ev.accel?}
                    set self._region-selection-anchor = region
                }
                set self._row-selection-anchor = -1
                {self.clear-cached-selection}
                set ev.consumed? = true
            }
        }
        
        
        || or drag selecting mulitple rows
        {if not ev.consumed? and
            grid.multiple-selection-enabled? 
         then
            let constant select-row:int = 
                {self.get-select-row-for-point x, y, start-select?=true}
            {if select-row != -1  then
                set self._drag-selecting? = true
                set self._region-selection-anchor = null
                set ev.test-recorded? = true

                def additive? = ev.shift? or ev.ctrl?
                || If the user started dragging off of a shift-select,
                || then try to maintain the existing anchor.
                {if additive? and
                    self._previous-row-selection-set? and
                    self._row-selection-point == select-row
                 then
                    || We should already be set up, so just continue.
                    {self.continue-row-selection}
                 elseif additive? then
                    {if self._previous-row-selection-set? then
                        || The user somehow skipped outside the old range so
                        || we need to start a new selection gesture.
                        {self.clear-cached-selection}
                    }
                    set self._row-selection-anchor = select-row
                    set self._row-selection-point = select-row
                    {self.check-start-continuing-row-selection}
                    {self.continue-row-selection}
                 else
                    || Clear out anything stale and start a new gesture.
                    {self.clear-cached-selection}
                    set self._row-selection-anchor = select-row
                    set self._row-selection-point = select-row
                }
                {grid.test-record
                    {if additive? then "ExtendRow" else "SelectRow"}, ||""
                    select-row
                }
                {grid.select-record select-row, additive? = additive?}
                set ui._disable-hscroll? = true
                set ev.consumed? = true
            }
        }


        || Starting to resize or move headers nulls out any pending click.
        {if ev.consumed? then
            set self._pending-click-target = null
            {self.start-dragscroll ev}
        }
    }
  }
  
  {method public open {note-dragscroll-continued x:Distance, y:Distance}:void

    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    let constant grid:RecordGrid = ui.grid
    
    || update state for column being resized or dragged or row selection
    {if self._resize-col != -1 then
        let constant layouts:SkRGColumnLayouts = ui._col-layouts
        set x = {max x, layouts[self._resize-col].lextent}
        set x = {max x, layouts.start-visible-x}
        set self._resize-col-x = x
        {self.request-draw}

     elseif self._move-col != -1 then
        set self._move-col-target = 
            {self.get-move-col-for-point x, y, start-move? = false}
        {self.request-draw}

     elseif self._drag-selecting? then
        {if self._row-selection-anchor != -1 then
            let constant select-row:int = 
                {self.get-select-row-for-point x, y, start-select? = false}
            set self._row-selection-point = select-row
            {self.continue-row-selection}
            {grid.select-record-range
                self._row-selection-anchor,
                select-row,
                additive? = self._previous-row-selection-set?
            }

         elseif self._region-selection-anchor != null then
            let constant (row:int, col:int) = 
                {self.get-select-cell-for-point x, y, start-select? = false}
            let constant anchor:RecordGridRegion = 
                {non-null self._region-selection-anchor}
            set self._region-selection-transient =
                {RecordGridRegion.from-corners
                    anchor.first-row,
                    anchor.first-column, 
                    row,
                    col
                }
            {grid.modify-last-selected-region 
                {non-null self._region-selection-transient}
            }
        }
    }

    {super.note-dragscroll-continued x, y}
  }
  
  {method public open {note-dragscroll-ended}:void   
    
    {if self._resize-col != -1 then
        || Finish any outstanding resize operation.
        {self.end-dragscroll-resize}
        
     elseif self._move-col != -1 then
        || Finish any outstanding column move operation.
        {self.end-dragscroll-move}
        
     elseif self._drag-selecting? then
        || Finish any outstanding selection operations.
        {self.end-dragscroll-select}
    }
    
    || Ensure that we did not become deactivated while dragging.
    {self._ui.grid.become-active}
    
    || Reinitiaize all grab variables and scrolling.
    set self._resize-col = -1
    set self._resize-col-x = 0cm
    set self._move-col = -1
    set self._move-col-target = -1
    set self._anchor-layer = 0
    set self._pending-click-target = null
    set self._drag-selecting? = false
    set self._ui._disable-vscroll? = false
    set self._ui._disable-hscroll? = false
    set self._row-selection-anchor = -1
    set self._row-selection-point = -1
    set self._col-selection-anchor = null
    set self._region-selection-anchor = null
    set self._region-selection-transient = null
    {self.clear-cached-selection}
    
    {super.note-dragscroll-ended}
  }

  || Handle the completion of a dragscroll column resize.
  {method private {end-dragscroll-resize}:void
    
    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    let constant layouts:SkRGColumnLayouts = ui._col-layouts 
    let constant grid:RecordGrid = ui.grid
    let constant records:RecordView = grid.records
    let constant resize:int = self._resize-col
    let constant layer:int = self._anchor-layer
    
    {if resize >= 0 and resize < layouts.size then
        {if layer == 0 then
            || If a single concrete column is being resized,
            || simply change its width.
            let constant l:SkRGColumnLayout = layouts[resize]
            let constant del:Distance = self._resize-col-x - l.ui-rextent
            {grid.test-record "ColumnResize", resize, del} ||""
            {layouts.resize-column resize, del}
            || Fix the width option to the distance the user chose
            set grid.columns[resize].width = l._width
            
         else
            || A column group is being resized.
            || Distribute its width change over all children equally,
            || distributing unused delta from one column over others.
            || Should only need to loop when delta is large and negative
            || and some children are relatively small.
            let constant base-header:SkRGSharedHeaderRow =
                {if-non-null hr = {ui.get-header-row layer} then
                    {try
                        hr asa SkRGSharedHeaderRow
                     catch ce:CastException do
                        {return}
                    }
                 else
                    {return}
                }
            let constant group:RecordGridColumnGroup = 
                {if-non-null header = 
                    {base-header.get-header-for-column-index resize} 
                 then
                    header.column-group
                 else
                    {return}
                }
            let constant last-layout:SkRGColumnLayout = 
                layouts[group.last-column-index]
            let constant delta:Distance =
                self._resize-col-x - last-layout.ui-rextent
            {grid.test-record
                "ColumnsResize", ||""
                group.first-column-index,
                group.last-column-index,
                delta
            }
            {self.resize-column-range
                group.first-column-index,
                group.last-column-index,
                delta
            }
        }
    }
    
    {self.request-draw}
  }
  
  {method package {resize-column-range
                      start-index:int,
                      end-index:int,
                      delta:Distance
                  }:void
    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    let constant layouts:SkRGColumnLayouts = ui._col-layouts 
    let constant grid:RecordGrid = ui.grid

    let active-children:int = end-index - start-index + 1
    let delta-portion:Distance = (delta / active-children)
    set delta = 0m

    let constant resize-array:{Array-of Distance} =
        {new {Array-of Distance}, efficient-size = active-children}
    {for n = 0 below active-children do
        {resize-array.append 0m}
    }
    let array-index:int = -1
    
    {for loop = 0 to grid.max-column-depth do
        set array-index = -1
        {for i = start-index to end-index do
            {inc array-index}
            let l:SkRGColumnLayout = layouts[i]
            || Resize the column to the extent possible, recording
            || zeroed columns and unused delta.
            {if l._width == 0m and
                delta-portion < 0m
             then
                {if loop == 0 then 
                    {dec active-children}
                 else
                    {continue}
                }
                {inc delta, delta-portion}
             elseif l._width >= -1 * delta-portion then
                {inc resize-array[array-index], delta-portion}
             else
                {inc resize-array[array-index], -1 * l._width}
                {inc delta, delta-portion + l._width}
                {dec active-children}
            }
        }
        || Redistribute remaining delta or break the loop.
        {if delta == 0m or
            active-children <= 0
         then
            {break}
         else
            set delta-portion = delta / active-children
            set delta = 0m
        }
    }
    set array-index = -1
    {for i = start-index to end-index do
        {inc array-index}
        let l:SkRGColumnLayout = layouts[i]
        {layouts.resize-column 
            i, 
            resize-array[array-index],
            notify? = false
        }
        set grid.columns[i].width = l._width
    }
    || Fire notification that we suppressed above.
    {self.note-column-layout-changed}
    
  }
  
  || Handle the completion of a dragscroll column move.
  || Note that this only works for concrete column headers moved
  || along the same layer.
  {method private {end-dragscroll-move}:void
    
    let constant layouts:SkRGColumnLayouts = self._ui._col-layouts 
    let constant grid:RecordGrid = self._ui.grid
    let constant records:RecordView = grid.records
    
    let src:int = self._move-col
    let dest:int = self._move-col-target
    
    {if src >= 0 and src < layouts.size and
        dest >= 0 and dest <= layouts.size and
        src != dest and
        src != dest - 1
     then
        {grid.test-record "ColumnMove", src, dest} ||""
        {grid.move-column src, dest}
    }
    
    {self.request-draw}
  }
  
  || Handle the completion of a dragscroll selection.
  || In this case, we are only performing a test recording, having earlier
  || skipped recording individual drag events to avoid test spam.
  {method private {end-dragscroll-select}:void
    
    let constant grid:RecordGrid = self._ui.grid
    
    {if self._row-selection-anchor != -1 then
        {grid.test-record
            {if self._previous-row-selection-set? then
                "ExtendRowsRange" ||""
             else
                "SelectRowsRange" ||""
            },
            self._row-selection-anchor,
            self._row-selection-point
        }
        
     else
        {if-non-null transient = self._region-selection-transient then
            {if-non-null anchor = self._region-selection-anchor then
                || Ensure that we record the corners of the transient in the
                || correct order, so that autoscrolling can happen on playback.
                || (anchor is always one of the corners of transient)
                {grid.test-record
                    "ModifyCellsRange", ||""
                    anchor.first-row,
                    anchor.first-column,
                    {if transient.first-row == anchor.first-row then
                        transient.first-row + transient.row-count - 1
                     else
                        transient.first-row                        
                    },
                    {if transient.first-column == anchor.first-column then
                        transient.first-column + transient.column-count - 1
                     else
                        transient.first-column
                    }
                }
            }
        }
    }
  }
  
  || Prevent handling of ContextMenuEvents that correspond
  || to a different location then the last *right press*. 
  || This can occur because of "mid-click" scrolling.  
  {method open public {on-pointer-envelope-event 
                          ev:PointerEnvelopeEvent
                      }:void
    
    {if ev.consumed? then {return}}
    
    {type-switch ev.contents
     case pp:PointerPress do
        {if pp.button == right-button then
            let (g:#Graphic, row:int, column:int) = {self.map-point ev.x, ev.y}
            set self._context-row = row
            set self._context-column = column
        }
     case cme:ContextMenuEvent do
        let (g:#Graphic, row:int, column:int) = {self.map-point ev.x, ev.y}
        {if row != self._context-row or column != self._context-column then
            {ev.consume}
        }
    } 
    {super.on-pointer-envelope-event ev}
  }
  
  {method private {get-resize-col-for-point x:Distance, y:Distance}:int
    
    || If we have a header, only resize within headers area 
    {if self._has-header-slot? and y > self.header-block-descent then 
        {return -1}
    }
    
    || For header area, use a constant delta surrounding grid-line.
    || If no header area we'll have to rely on vertical grid-line
    || width to provide grab area to avoid encroaching on RecordGridCells. 
    let constant delta:Distance = 
        {if self._has-header-slot? then
            ProtoSkinnableRecordGridUI.column-drag-delta / 2
         else
            0cm
        }
    let constant grid-line-width:Distance = self._vertical-grid-line-width
    let constant layouts:SkRGColumnLayouts = self._ui._col-layouts

    || Must be visible and within delta of the grid line to right
    {if x < layouts.start-visible-x then {return -1}}
    {for layout:SkRGColumnLayout key i in layouts do 
        {if x >= layout.ui-rextent - delta then
            {if x <= layout.ui-rextent + grid-line-width + delta then
                {return 
                    {if layout._column.column-resizable? then i else -1}
                }
            }
         else
            {return -1}
        }
    }
    {return -1}
  }
  
  {method private {get-resize-layer-for-point x:Distance, y:Distance}:int
    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    {for i = 0 to self._header-slot-count - 1 do
        {if {self.header-descent i} >= y then
            {return self._header-slot-count - i - 1}
        }
    }
    {return 0}
  }
  
  {method private {get-move-col-for-point 
                      x:Distance, 
                      y:Distance,
                      start-move?:bool = true
                  }:int
    
    let layouts:SkRGColumnLayouts = self._ui._col-layouts
    
    || To start move, must be actually in a movable header 
    ||(or within column-drag-delta if no header)
    {if start-move? then
        
        let constant y-mix:Distance =
            {if self._header-slot-count > 1 then
                {self.header-y-start self._header-slot-count - 1}
             else
                0m
            }
        
        let constant y-max:Distance = 
            {max 
                self.header-block-descent, 
                ProtoSkinnableRecordGridUI.column-drag-delta
            }
        
        {if y >= y-mix and
            y <= y-max and
            x >= layouts.start-visible-x
         then
            {for layout:SkRGColumnLayout key i in layouts do 
                {if x > layout.ui-lextent and x < layout.ui-rextent then
                    {return
                        {if layout._column.column-movable? then i else -1}
                    }
                }
            }
        }
        
        {return -1}
    }
    
    || Otherwise looking for destination. Find column of our x position, 
    || returning columns for positions on far left or right.
    
    let return-col:int = -1
    
    || Normalize to visible area.
    set x = 
        {min
            {max x, layouts.start-visible-x},
            layouts.end-visible-x
        }
    let constant half-spacing:Distance = self._vertical-grid-line-width / 2
    {for layout:SkRGColumnLayout key i in layouts do  
        {if (layout.ui-lextent >= layouts.start-visible-x or
             layout.ui-rextent >= layouts.start-visible-x) and
            x >= (layout.ui-lextent - half-spacing) and 
            x < (layout.ui-rextent + half-spacing)
         then
            set return-col = 
                || Round the index to the nearest side of the column.
                {if layout.ui-rextent - x < x - layout.ui-lextent then
                    i + 1
                 else
                    i
                }
            {break}
        }
    }
    
    {if return-col == -1 and
        x >= layouts.rextent
     then
        set return-col = layouts.size
    }

    let constant columns:{Array-of RecordGridColumn} = self._ui.grid.columns
    
    || Force index away from different column groups.
    {if return-col != -1 and
        return-col < layouts.size
     then
        {if-non-null group = columns[return-col].parent-group then
            {if self._move-col == -1 or
                (self._move-col != -1 and
                 group != columns[self._move-col].parent-group)
             then
                let constant (a:int, b:int) = 
                    {self.group-exclusion-bounds
                        return-col,
                        relative-col = self._move-col
                    }
                || If the exclusion bounds are interesting, use them to
                || normalize the return column. 
                {if a != 0 or b < layouts.size - 1 then
                    let constant left:Distance = layouts[a].ui-lextent
                    let constant right:Distance = layouts[b].ui-rextent
                    set return-col = 
                        {if (x - left) <= (right - x) then a else b + 1}
                }
            }
        }
    }
    
    || Normalize within own column group.
    {if return-col != -1 and
        self._move-col != -1
     then
        {if-non-null group = columns[self._move-col].parent-group then
            {return
                {max group.first-column-index, 
                    {min group.last-column-index + 1, return-col}
                }
            }
        }
    }
    
    {return return-col}
  }
  
  || Find the maximal group bounds for some column.
  || If relative-col is non-null, then give the maximumal non-shared
  || group bounds for the column's highest non-shared group.
  {method private {group-exclusion-bounds 
                      col:int,
                      relative-col:int = -1
                  }:(a:int, b:int)
    let constant columns:{Array-of RecordGridColumn} = self._ui.grid.columns
    
    || The parent of the target column.
    let group:#RecordGridColumnGroup = columns[col].parent-group
    || The parent of the base / relative column.
    let constant relative-group:#RecordGridColumnGroup = 
        {if relative-col >= 0 then
            columns[relative-col].parent-group
         else
            null
        }
    || The lowest group shared between relative and target.
    let constant shared-parent:#RecordGridColumnGroup =
        {if-non-null group then
            {if relative-group != null then
                {group.get-first-shared-parent {non-null relative-group}}
             else
                null
            }
         else
            null
        }

    || Set group to the highest group of the target,
    || that is just under any shared parent.
    {for i = 0 to self._ui.grid.max-column-depth do
        {if-non-null new-group = group.parent-group then
            {if new-group == shared-parent then
                {break}
             else
                set group = new-group
            }
         else
            {break}
        }
    }
    
    {if-non-null group then
        {if group != relative-group then
            {return group.first-column-index, group.last-column-index}
        }
    }
    
    {return 0, columns.size - 1}
  }

  {method private {get-select-row-for-point 
                      x:Distance, 
                      y:Distance,
                      start-select?:bool = true
                  }:int
    
    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    let constant grid:RecordGrid = ui.grid
    
    {if start-select? then
        let constant (g:Graphic, rec:int, col:int) = {self.map-point x, y}
        {return 
            {if grid.record-selection-enabled? and 
                rec != -1 and
                (g isa SkRGRecordSelector or
                 grid.select-current-record?)
             then 
                rec 
             else
                -1
            }
        }
    }
    
    || Otherwise looking for destination.
    || - Find row of our y position, between first-visible and last-visible 
    || - Return rows for boundary positions on far top or bottom.  
    || - If target would be within the move range, return start of move range.
    || - Ensure y above clipped area.
    set y = {min {self.layout.get-bounds}.descent, y} 
    {for i:int = 0 below self._data-slot-count do 
        {if {self.row-descent i} > y then
            {if ui.frozen-row-count == 0 then
                {return i + ui.first-scrollable-row}
             elseif i < ui.frozen-row-count then
                {return i + ui.frozen-row-start}
             else
                {return i + ui.first-scrollable-row - ui.frozen-row-count}
            }
        }
    }
    
    {return 
        self._data-slot-count + 
        ui.first-scrollable-row - 
        ui.frozen-row-count - 
        1
    }
  }

  {method private {get-select-column-for-point 
                      x:Distance, 
                      y:Distance,
                      start-select?:bool = true
                  }:int
    
    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    let constant grid:RecordGrid = ui.grid
    let constant layouts:SkRGColumnLayouts = ui._col-layouts
    
    {if start-select? then
        let constant (g:Graphic, rec:int, col:int) = {self.map-point x, y}
        {return 
            {if grid.column-selection-enabled? and 
                col != -1 and
                g isa SkRGColumnSelector
             then 
                col
             else
                -1
            }
        }
    }
    
    || Otherwise looking for destination. Find column of our x position, 
    || returning columns for positions on far left or right.

    || Normalize to visible area.
    set x = 
        {min
            {max x, layouts.start-visible-x},
            layouts.end-visible-x
        }
    
    || assign the space between columns to the nearest column

    let constant frozen-col-count:int = ui.frozen-col-count
    
    {for layout:SkRGColumnLayout key i in layouts do 
        
        || Determine effective lextent of current layout.
        
        let effective-lextent:Distance = layout.ui-lextent
        {if i > 0 then
            let constant previous-layout:SkRGColumnLayout = {layouts.get i - 1}
            
            {if previous-layout.ui-rextent < effective-lextent then
                {dec 
                    effective-lextent, 
                    (effective-lextent - previous-layout.ui-rextent) / 2
                }
            }
            {if frozen-col-count > 0 and
                i >= frozen-col-count
             then
                set effective-lextent = 
                    {max layouts.secondary-lextent, effective-lextent}
            }
        }
        
        let effective-rextent:Distance = layout.ui-rextent
        {if i < layouts.size - 1 then
            let constant next-layout:SkRGColumnLayout = {layouts.get i + 1}
            
            {if next-layout.ui-lextent > effective-rextent then
                {inc
                    effective-rextent, 
                    (next-layout.ui-lextent - effective-rextent) / 2
                }
            }
            {if frozen-col-count > 0 and
                i >= frozen-col-count
             then
                set effective-rextent = 
                    {max layouts.secondary-lextent, effective-rextent}
             elseif i == frozen-col-count - 1 then
                {inc effective-rextent, self._vertical-grid-line-width}
            }         
        }
        
        {if effective-lextent < effective-rextent and
            x >= effective-lextent and 
            x < effective-rextent
         then
            {return i}
        }
    }
    {return layouts.size - 1}    
  }

  || when eager? is true, interstitial space will be assigned to the nearest
  || cell instead of producing an outside result
  {method private {get-select-cell-for-point 
                      x:Distance, 
                      y:Distance,
                      start-select?:bool = true,
                      eager?:bool = false
                  }:(row:int, col:int)
    
    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    let constant grid:RecordGrid = ui.grid
    let constant layouts:SkRGColumnLayouts = self._ui._col-layouts

    {if start-select? then
        let constant (g:Graphic, rec:int, col:int) = {self.map-point x, y}
        {return 
            {if grid.region-selection-enabled? and 
                rec != -1 and
                col != -1 and
                ((g isa RecordGridCell) or 
                 eager?)
             then 
                (rec, col)
             else
                (-1, -1)
            }
        }
    }
    
    {return
        {self.get-select-row-for-point x, y, start-select? = false},
        {self.get-select-column-for-point x, y, start-select? = false}
    }
  }
  
  {getter package {selecting?}:bool
    {return self._selecting? or self._drag-selecting?}
  }
  
  ||------------------------------------------------
  || Drawing methods
  ||------------------------------------------------
  
  {method public open {draw r2d:Renderer2d}:void
    {self.draw-backgrounds r2d}
    {super.draw r2d}
    {self.draw-vertical-lines r2d}
    {self.draw-horizontal-lines r2d}
    {self.draw-separators r2d}
    {self.draw-frozen-lines r2d}
    {self.draw-resize-indicator r2d}
    {self.draw-move-indicator r2d}
  }
  
  || This needs to take place on top of the standard vertical 
  || and horizontal lines to prevent a weaving effect.
  || Thus this method must be called after those methods, despite
  || the resulting potential for double-draw of relevant pixels.
  {method private {draw-frozen-lines r2d:Renderer2d}:void

    let constant layouts:SkRGColumnLayouts = self._ui._col-layouts
    
    {if (self._ui.frozen-row-count > 0 or
         self._ui.frozen-row-start > 0) and
        self._horizontal-grid-line-width > 0cm
     then     
        let constant frozen-index:int = self._ui.frozen-row-count - 1
        || If frozen only with an offset, that's handled in draw-separators.
        {if frozen-index < self._data-slot-count and
            frozen-index >= 0
         then
            {r2d.render-rectangle 
                fill-pattern = self._grid-line-frozen-color,
                0cm,
                {self.row-descent frozen-index},
                layouts.rextent,
                self._horizontal-grid-line-width
            }
        }
    }
    
    {if (self._ui.frozen-col-count > 0 or 
         self._ui.frozen-col-start > 0)and
        self._vertical-grid-line-width > 0cm
     then
        let constant frozen-index:int = 
            self._ui.frozen-col-count + self._ui.frozen-col-start - 1
        {if frozen-index < layouts.size then
            let constant total-descent:Distance = 
                self.last-row-descent + self._horizontal-grid-line-width
            let constant layout:SkRGColumnLayout = {layouts.get frozen-index}
            {if layout.ui-rextent >= layouts.start-visible-x then
                {r2d.render-rectangle 
                    fill-pattern = self._grid-line-frozen-color,
                    layout.ui-rextent, 
                    0cm, 
                    self._vertical-grid-line-width,
                    total-descent
                }
            }
        }
    }

  }
  
  {method private {draw-horizontal-lines r2d:Renderer2d}:void
    {if self._horizontal-grid-line-width <= 0cm then {return}}
    
    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    let constant map:{Array-2-of #SkRGHeaderMapElement} = ui._column-layer-map
    
    let constant layouts:SkRGColumnLayouts = ui._col-layouts
    let constant rextent:Distance = layouts.rextent
    
    let constant frozen-index:int = ui.frozen-row-count - 1
    let constant frozen-columns:int = ui.frozen-col-start + ui.frozen-col-count
    
    let constant line-width:Distance = self._horizontal-grid-line-width
    let constant v-line-width:Distance = self._vertical-grid-line-width
    
    || Draw the separator under some portions of shared header rows.
    {for slot = 0 below (self._header-slot-count - 1) do
        let constant row-descent:Distance = {self.header-descent slot}
        let constant header-row:SkRGSharedHeaderRow = 
            {self.header-slot slot}.graphic asa SkRGSharedHeaderRow
        
        let previous-col:#BaseRecordGridColumn
        
        {for x = 0 to layouts.size - 1 do
            let constant element:#SkRGHeaderMapElement =
                {map.get x, ui.grid.max-column-depth - slot}
            let constant element-below:#SkRGHeaderMapElement =
                {map.get x, ui.grid.max-column-depth - slot - 1}
            let constant close-below?:bool = 
                {if-non-null element-below then
                    {if-non-null bbc = element-below.base-col then
                        bbc.enclose-header-label?
                     else
                        false
                    }
                 else
                    false
                }
            {if close-below? or
                (element != null and
                 element.base-col != null and
                 element-below == null and
                 ui.grid.enclose-header-label?)
             then
                let constant draw-start:Distance =
                    {max
                        layouts[x].ui-lextent -
                        || Draw across the vertical separator if the last
                        || horizontal segment was also drawn and the
                        || vertical separator doesn't continue upwards.
                        {if element != null and
                            previous-col != null and
                            previous-col == element.base-col
                         then
                            v-line-width
                         else
                            0m
                        },                 
                        {if frozen-columns > 0 and
                            x >= frozen-columns
                         then
                            layouts.secondary-lextent
                         else
                            layouts.start-visible-x
                        }
                    }
                let constant draw-width:Distance =
                    (layouts[x].ui-rextent -
                     draw-start)
                {if draw-width > 0m then
                    {r2d.render-rectangle 
                        fill-pattern = self._control-color-shadow,
                        draw-start,
                        row-descent,
                        draw-width,
                        line-width
                    }
                }
                {if-non-null element then
                    set previous-col = element.base-col
                 else
                    set previous-col = null
                }
                
             else
                set previous-col = null
            }
        }
    }

    || Draw underneath each data row.
    {for i = 0 below self._data-slot-count do
        
        let constant row-descent:Distance = {self.row-descent i}
        
        {r2d.render-rectangle 
            fill-pattern = self._grid-line-color,
            0cm,
            row-descent,
            rextent,
            line-width
        }
        
        || Draw an offset block between rows at their selectors,
        || which means not under the very last row (between, not below).
        {if layouts.start-visible-x > 0cm and
            (i < self._data-slot-count - 1 or
             (self._last-row-displayed < ui._data-row-count - 1))
         then
            {r2d.render-rectangle 
                fill-pattern = self._control-color-shadow,
                0cm,
                row-descent,
                layouts.start-visible-x,
                line-width
            }
        }
    }
  }
  
  {method private {draw-vertical-lines r2d:Renderer2d}:void
    
    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    let constant layouts:SkRGColumnLayouts = ui._col-layouts
    let constant v-line-width:Distance = self._vertical-grid-line-width

    {if v-line-width <= 0cm or 
        layouts.size <= 0
     then
        {return}
    }
    
    let constant h-line-width:Distance = self._horizontal-grid-line-width

    let constant total-descent:Distance = self.last-row-descent + h-line-width
    let constant header-block-descent:Distance = self.header-block-descent
    
    let constant map:{Array-2-of #SkRGHeaderMapElement} =
        ui._column-layer-map
            
    let constant header-count:int = ui._header-rows.size

    || The x boundary that nothing should be drawn to the left of.
    let barrier:Distance = layouts.start-visible-x - v-line-width
    
    let previous-layout:SkRGColumnLayout = {layouts.get 0}
    let previous-rextent:Distance = previous-layout.ui-rextent
    
    || Draw the separators between columns.
    {for layout:SkRGColumnLayout key i in layouts do
        
        {if i == 0 then {continue}}
        
        {if previous-rextent >= barrier then
            set barrier = previous-rextent
         elseif previous-rextent < barrier then
            set previous-layout = layout
            set previous-rextent = layout.ui-rextent
            {continue}
        }
        
        || Draw data row / cell vertical separator.
        {r2d.render-rectangle 
            fill-pattern = self._grid-line-color,
            previous-rextent, 
            header-block-descent,
            v-line-width,
            total-descent - header-block-descent
        }
        
        || Draw header separators.
        {if header-count > 0 then
            
            || Find the topmost draw layer for this column junction.
            let draw-layer:int = 0
            {for layer = (header-count - 1) downto 0 do
                {if-non-null left-element = {map.get i - 1, layer} then
                    {if left-element.base-col != null and
                        left-element.last-col == i - 1
                     then
                        set draw-layer = layer
                        {break}
                    }
                }
                {if-non-null right-element = {map.get i, layer} then
                    {if right-element.base-col != null and
                        right-element.first-col == i
                     then
                        set draw-layer = layer
                        {break}
                    }                    
                }
            }
            
            || Actually draw the header in the column intersection.
            
            let constant slot:int = 
                self._header-slot-count - draw-layer - 1
            
            || Bump up draw start if we're not at header slot zero,
            || to prevent an undrawn square from forming at the
            || intersection of the horz and vert separators.
            let constant start:Distance = ||{self.header-y-start slot}
                {if slot != 0 then
                    || Use header-descent on the previous slot
                    || to match other drawing code.
                    {self.header-descent slot - 1}
                 else
                    0m
                }
            let constant height:Distance =
                {if slot != 0 then
                    header-block-descent - start + h-line-width
                 else
                    header-block-descent - start
                }
            
            {r2d.render-rectangle 
                fill-pattern = self._control-color-shadow,
                previous-rextent, 
                start,
                v-line-width,
                height
            }

        }
        
        set previous-layout = layout
        set previous-rextent = layout.ui-rextent
    }
    
    || Draw at the right of the last column.
    let final-grid-line-v-start:Distance = header-block-descent
    let final-grid-line-v-end:Distance = total-descent - header-block-descent
    {if header-count > 0 then
        {inc final-grid-line-v-start, h-line-width}
        {dec final-grid-line-v-end, h-line-width}
    }
    {r2d.render-rectangle 
        fill-pattern = self._grid-line-color,
        previous-rextent, 
        final-grid-line-v-start,
        v-line-width,
        final-grid-line-v-end
    }
    {if header-count > 0 then
        {r2d.render-rectangle 
            fill-pattern = self._control-color-shadow,
            previous-rextent, 
            0m,
            v-line-width,
            header-block-descent + h-line-width
        }
    }
    
  }
  
  {method private {draw-separators r2d:Renderer2d}:void
    
    let layouts:SkRGColumnLayouts = self._ui._col-layouts

    || under header
    {if self._horizontal-grid-line-width > 0cm then

        let header-block-descent:Distance = self.header-block-descent
        let rextent:Distance = 
            {if self._ui._display-filler-column? then
                {self.layout.get-bounds}.rextent
             else
                layouts.rextent
            }
        {if header-block-descent > 0cm then 
            {r2d.render-rectangle 
                fill-pattern = 
                    {if self._ui.frozen-row-start > 0 and
                        self._ui.frozen-row-count == 0
                     then
                        self._grid-line-frozen-color
                     else
                        self._control-color-shadow
                    },
                0cm,
                header-block-descent,
                rextent,
                self._horizontal-grid-line-width
            }     
        }
    }
    
    || after row selector "column"
    {if self._vertical-grid-line-width > 0cm and
        self._ui._row-selectors?
     then    
        {r2d.render-rectangle 
            fill-pattern =  self._control-color-shadow, 
            ProtoSkinnableRecordGridUI.row-selector-width,
            0cm,
            self._vertical-grid-line-width,
            self.last-row-descent
        }      
    }   
  }
  
  {method private {draw-resize-indicator r2d:Renderer2d}:void
    
    let layouts:SkRGColumnLayouts = self._ui._col-layouts
    
    {if self._resize-col >= 0 and 
        self._resize-col < layouts.size
     then     
        let constant draw-x:Distance = self._resize-col-x
        let color:FillPattern = 
            {if draw-x > layouts.rextent and 
                not self._ui._display-filler-column? 
             then
                FillPattern.black
             else
                self._control-color-shadow
            }
        {r2d.render-line 
            fill-pattern = color, 
            draw-x, 
            0cm,
            draw-x,
            self.last-row-descent,
            stroke-thickness = 0cm
        }
    }
  }

  {method private {draw-move-indicator r2d:Renderer2d}:void

    let layouts:SkRGColumnLayouts = self._ui._col-layouts

    {if self._move-col >= 0 and 
        self._move-col < layouts.size and
        self._move-col-target >= 0 and 
        self._move-col-target <= layouts.size
     then
        
        || Invert rectangle at left separator before target column, or
        || right edge of grid (for insertion at end)
        let psize:Distance = r2d.pixel-size
        let col-x:Distance = 0cm
        
        {if self._move-col-target != layouts.size then
            let l:SkRGColumnLayout = layouts[self._move-col-target]
            || Don't draw past the frozen boundary if target is scrolled under.
            {if self._ui.frozen-col-count > 0 and
                (self._move-col-target >= 
                 self._ui.frozen-col-count + self._ui.frozen-col-start) and
                l.ui-lextent < layouts.secondary-lextent
             then
                set col-x = layouts.secondary-lextent
             else
                set col-x = (l.ui-lextent - self._vertical-grid-line-width)
            }
         else
            set col-x = layouts.rextent
        }
        
        set col-x = {max 
                        {min col-x, layouts.end-visible-x},
                        layouts.start-visible-x
                    }
        
        || Draw over the separator and two pixels on either side.
        {with-render-properties
            draw-operation = DrawOperation.invert-destination
            on r2d 
         do
            {r2d.render-rectangle
                col-x - 2 * psize,
                0cm,
                self._vertical-grid-line-width + 4 * psize,
                self.last-row-descent
            }
        }
    }
  }
  
  {method private {draw-backgrounds r2d:Renderer2d}:void

    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    let constant layouts:SkRGColumnLayouts = ui._col-layouts
    let constant last-row-descent:Distance = self.last-row-descent
    let constant start-visible-x:Distance = layouts.start-visible-x
    let constant secondary-lextent:Distance = layouts.secondary-lextent
    let constant frozen-column-start:int = ui.frozen-col-start
    let constant frozen-column-count:int = ui.frozen-col-count
    let constant frozen-cols-at-index:int =
        {if frozen-column-start > 0 or
            frozen-column-count > 0
         then
            frozen-column-start + frozen-column-count
         else
            max-int
        }
    
    let constant rextent:Distance = 
        {if ui._display-filler-column? then
            {self.layout.get-bounds}.rextent
         else
            || Avoid case where rextent is pulled left by freeze offset.
            {max layouts.start-visible-x, layouts.rextent}
        }


    || 1) Row selector background
    {if ui._row-selectors? then
        {r2d.render-rectangle
            0cm,
            0cm,
            ProtoSkinnableRecordGridUI.row-selector-width,
            last-row-descent,
            fill-pattern = self._control-color 
        }
    }
    
    || 2) Column header background 
    let constant header-block-descent:Distance = self.header-block-descent
    {if header-block-descent > 0cm then
        {r2d.render-rectangle
            0cm,
            0cm,
            rextent,
            header-block-descent,
            fill-pattern = self._control-color
        }
    }

    || 3) Control-content-background below all columns/rows
    let constant bounds:GRect = self._scratch-draw-grect
    {bounds.resize
        -start-visible-x,
        rextent,
        -header-block-descent, 
        last-row-descent
    }      
    {self._control-content-background.draw r2d, bounds, graphic = self}
    
    || 4) Column Backgrounds
    {for l:SkRGColumnLayout key index in layouts do
        || Skip frozen-out columns.
        {if index < frozen-column-start then {continue}}
        let bg:Background = l._column.background 
        {if bg != Background.transparent then
            || Set the l and r of the bounds for each row.
            set bounds.rextent = l.ui-rextent
            set bounds.lextent = -{max l.ui-lextent, start-visible-x}
            || Clip columns in the right group to the secondary lextent.
            {if index >= frozen-cols-at-index then
                set bounds.lextent = {min bounds.lextent, -secondary-lextent}
            }
            || Render the background.
            {if bounds.width > 0cm then
                {bg.draw r2d, bounds, graphic = self}
            }
        }
    }

    || 5) Alternate & computed row backgrounds
    let constant ar-background:Background = self._alternate-row-background

    || Resize the horizontal component of the bounds
    || to match the visible rows area.
    set bounds.lextent = -start-visible-x
    set bounds.rextent = rextent

    let draw-background:#Background = null
    {for i = 0 below self._data-slot-count do
        let constant l:SequenceLayout = {self.data-slot i}
        || Paranoia:
        {if-non-null data-row = l.graphic asa #SkRGDataRow then
            let constant data-index:int = data-row.index
            {if data-index < 0 then {continue}}
            
            {if-non-null bkg = data-row.computed-row-background then
                set draw-background = bkg
             elseif (data-index mod 2) == 0 then
                set draw-background = ar-background
             else
                set draw-background = null
            }

            {if-non-null bkg = draw-background then
                || If we're drawing, first set the ascent and descent
                || from the bounds on the target row.
                let constant (row-x:Distance, row-y:Distance) =
                    {l.get-origin-in-parent}
                let constant row-bounds:GRect = {l.get-bounds}
                set bounds.ascent = row-bounds.ascent - row-y
                set bounds.descent = row-bounds.descent + row-y
                || Then draw.
                {bkg.draw r2d, bounds, graphic = self}
            }
        }
    }
    
  }
  
  ||---------------------------------------------------
  || Package methods for communicating with ui
  ||---------------------------------------------------
  
  {method package {map-point
                      x:Distance,
                      y:Distance
                  }:(target:Graphic,
                     record-index:int,
                     column-index:int
                    )
    
    let grid:RecordGrid = self._ui.grid
    let layouts:SkRGColumnLayouts = self._ui._col-layouts

    {self.validate-layout}

    || 1) Try to find cell or selector in hierarchy
    {type-switch 
        {self.find-graphic-at x, y,
            {proc {g:Graphic}:bool 
                {return
                    {type-switch g
                     case g:RecordGridCell do true
                     case g:SkRGRecordSelector do true
                     case g:SkRGColumnSelector do true
                     case g:SkRGSharedColumnHeader do true
                     else false
                    }
                }
            } 
        }
     case cell:RecordGridCell do
        {return 
            cell,
            cell.record-index, 
            {grid.columns.find {non-null cell.column}} 
        }
     case rsel:SkRGRecordSelector do
        {return
            rsel,
            (rsel.parent asa SkRGDataRow).index,
            -1
        }
     case csel:SkRGColumnSelector do
        {return
            csel,
            -1,
            {grid.columns.find csel.column}
        }
     case sch:SkRGSharedColumnHeader do
        {return
            sch,
            -1,
            -1
        }
    }
    
    || 2) Look for row or column assignment from interstitial spaces 
    || Assigns interstitial spaces equally between neighbors
    let vdelta:Distance = self._horizontal-grid-line-width / 2
    let hdelta:Distance = self._vertical-grid-line-width / 2
    
    || 2a) No row or column should be returned beyond bounds of this
    || object, or its visible content.
    let bounds:GRect = {self.layout.get-bounds}
    {if not {bounds.within? x, y} or 
        x > layouts.rextent + hdelta or 
        y > self.last-row-descent + vdelta 
     then
        {return self, -1, -1}
    }

    || 2b) Assign row, column
    let row:int = -1
    {if y > self.header-block-descent + vdelta then
        let constant frozen-row-count:int = self._ui.frozen-row-count
        {for i:int = 0 below self._data-slot-count do        
            {if y < {self.row-descent i} + vdelta then
                set row =
                {if frozen-row-count == 0 then
                    i + self._ui.first-visible-row
                 elseif i <= frozen-row-count - 1 then
                    i + self._ui.frozen-row-start
                 else
                    i + self._ui.first-scrollable-row - frozen-row-count
                }
                {break}
            }
        }
    }

    let col:int = -1
    {if x > layouts.start-visible-x - hdelta then
        {for layout key i in layouts do
            {if x < layout.ui-rextent + hdelta then
                set col = i
                {break}
            }
        }
    }
    
    
    {return self, row, col}
  }
  
  {method package {note-column-layout-changed}:void 
    {for l in self._vbox.child-array do
        {(l.graphic asa SkRGBaseRow).note-column-layout-changed}
    }
    {self.request-layout}
  }

  {method package {note-column-scrolled}:void    
    {for l in self._vbox.child-array do
        {(l.graphic asa SkRGBaseRow).note-column-scrolled}
    }
    {self.request-draw}
  }
  
  || This method must be protected from re-entrancy, because 
  || refresh-row-contents assumes a consistent state for the internal
  || vbox, but leaves that state inconsistent while it does its processing. 
  || We must protect against custom cells that make calls back into grid 
  || when they are pulled out of or added to the display.  
  {method package {refresh-display}:void

    || Track the cached selections and see if any of them have changed.
    || (This method is eventually called by react-to-state-change, which
    || is called by SelectionChanged at RecordGrid.)
    || If the previous selection has been changed by someone else,
    || then we need to trash the lot and revert to regular selection state.
    {if not self.cached-selection-valid? then
        {self.clear-cached-selection}
    }
    
    {if not self._refreshing-display? then
        {with self._refreshing-display? = true do 
            {self.refresh-row-contents}
            || Need at least one layout (new rows may need to be added.)
            {self.request-layout}
        }
     else
        {after 0s do
            {self.refresh-display}
        }
    }
  }
  
  {method package {clear-display}:void
    set self._last-row-displayed = -1
    set self._has-header-slot? = false
    set self._header-slot-count = 0
    set self.hidden-row-index = -1
    {self._vbox.clear}
  }
  
  || How many fully visible rows are in the scrolling grid
  || (or estimated capacity, if at end of data)
  {getter package {curr-page-size}:int
    let return-val:int = 0
    {if-non-null l = self.layout then
        {self.validate-layout}
        let bounds:GRect = {l.get-bounds}
        {if not self.display-vclipped? then 
            let data-height:Distance = 
                {max bounds.height - self.header-block-descent, 0cm}
            set return-val = {floor data-height / self._est-row-dim} asa int
         else
            {for i:int = self._data-slot-count - 1 downto 0 do
                {if {self.row-descent i} < bounds.height then
                    set return-val = (i + 1)
                    {break}
                }
            }   
        }
        {if self._ui.frozen-row-count != 0 then
            {dec return-val, self._ui.frozen-row-count}
        }
    }
    {return {max 0, return-val}}
  }
  
  {method package {scroll-to-reveal-row index:int}:void
    set self._ensure-visible-row = index
    {self.request-layout}
  }
  
  {getter package {last-row-displayed}:int
    {return self._last-row-displayed}
  }

  ||----------------------------------------------------------------
  || Private shortcut methods for analyzing layout
  ||
  || These methods are for use by drawing, gesture
  || interpretation, and other routines.  They should 
  || not typically be called when the layout is invalid,
  || but will trigger layout if needed. 
  ||
  || Calling methods that are not sure layout is valid 
  || (i.e. non-draw related methods) should consider calling 
  || validate-layout before invoking these methods.  In particular,
  || one should be careful about loops which call row-descent.
  || A triggered layout may alter the total number of rows, 
  || while the rows are being looped over!  See {map-point} and
  || {curr-page-size}.
  ||
  || TODO: Consider asserting that (layout-valid? = true)
  || to these methods. A "non-release" assertion construct 
  || would be useful here.
  ||----------------------------------------------------------------
  
  {method private {row-descent i:int}:Distance
    let l:Layout = {self.data-slot i} 
    let row-bounds:GRect = {l.get-cell-bounds}
    let (row-x:Distance, row-y:Distance) = {l.get-origin-in-parent}
    {return row-y + row-bounds.descent}
  }
  
  {method private {header-descent i:int}:Distance
    let l:SequenceLayout = {non-null {self.header-slot i}} 
    let row-bounds:GRect = {l.get-cell-bounds}
    let (row-x:Distance, row-y:Distance) = {l.get-origin-in-parent}
    {return row-y + row-bounds.descent}
  }
  
  {method private {header-y-start i:int}:Distance
    let l:SequenceLayout = {non-null {self.header-slot i}} 
    let (row-x:Distance, row-y:Distance) = {l.get-origin-in-parent}
    {return row-y}
  }
  
  || Returns the y start and height relative to the origin.
  {method private {header-start-height i:int}:(start:Distance, height:Distance)
    let l:SequenceLayout = {non-null {self.header-slot i}} 
    let row-bounds:GRect = {l.get-cell-bounds}
    let (row-x:Distance, row-y:Distance) = {l.get-origin-in-parent}
    {return row-y, row-bounds.descent}
  }
  
  {getter package {header-block-descent}:Distance
    {if self._header-slot-count > 0 then
        let constant l:SequenceLayout =
            self._vbox.child-array[self._header-slot-count - 1]
        let constant row-bounds:GRect = {l.get-cell-bounds}
        let constant (row-x:Distance, row-y:Distance) = 
            {l.get-origin-in-parent}
        {return row-y + row-bounds.descent}
     else
        {return 0cm}
    }
  }

  {getter private {last-row-descent}:Distance
    {return {self._vbox.layout.get-bounds}.descent}
  }
  

  || Is the data being displayed currently clipped in the vertical dimension?
  {getter private {display-vclipped?}:bool
    let child-layout:#Layout = self._vbox.layout
    let layout:#Layout = self.layout
    {if layout != null and child-layout != null then
        let child-bounds:GRect = {child-layout.get-cell-bounds} 
        let bounds:GRect = {self.layout.get-bounds}
        {return
            ((bounds.descent < child-bounds.descent) or
             (bounds.ascent < child-bounds.ascent)
            )
        }
    }
    {return false}
  }

  ||--------------------------------------------
  || Options
  ||--------------------------------------------
    
  || Return an offset color visibly different from the input color.
  {method private {get-offset-color-for-freeze 
                      source-fp:FillPattern
                  }:FillPattern
    
    let constant source-pixel:Pixel = {source-fp.to-Pixel}
    let constant (hue:FloatAngle, sat:FloatFraction, val:FloatFraction) =
        {Color.rgb-to-hsv
            source-pixel.red,
            source-pixel.green,
            source-pixel.blue
        }
    let constant new-sat:FloatFraction =
        {if sat < 0.5f then
            sat + 0.35f
         else
            {min sat - 0.35f, sat / 2f}
        }
    let constant new-val:FloatFraction =
        {if val < 0.5f then
            val + 0.35f
         else
            {min val - 0.35f, val / 2f}
        }
    let constant new-fp:FillPattern =
        {Color.from-hsv hue, new-sat, new-val}
    {return new-fp}
  }
  
  {nonlocal-option public control-color:FillPattern
    set self._control-color = control-color
    set self._control-color-shadow = {get-shadow-for self._control-color}
    set self._control-color-highlight = {get-highlight-for self._control-color}
    {self.request-draw}
  }
  
  {nonlocal-option public control-content-background:Background
    set self._control-content-background = self.control-content-background
    {self.request-draw}
  }
  
  {nonlocal-option public horizontal-grid-line-width:any
    set self._horizontal-grid-line-width = 
        {self.any-to-Distance horizontal-grid-line-width}
    set self._vbox.spacing = horizontal-grid-line-width
    {self.request-layout}
  }
  
  {nonlocal-option public vertical-grid-line-width:any
    set self._vertical-grid-line-width = 
        {self.any-to-Distance vertical-grid-line-width}
    {self.request-layout}
  }
  
  {nonlocal-option public grid-line-color:FillPattern
    set self._grid-line-color = grid-line-color
    set self._grid-line-frozen-color = 
        {self.get-offset-color-for-freeze grid-line-color}
    {self.request-draw}
  }
  
  {nonlocal-option public alternate-row-background:Background
    set self._alternate-row-background = alternate-row-background
    {self.request-draw}
  }
  
}


||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGColumnLayouts
||
|| Manages column layouts and horizontal scrolling.
||
|| Note that this is not a real Layout object, so its interactions
|| with the normal layout system are external and delicate.
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package SkRGColumnLayouts

  field private _freeze-offset:Distance = 0cm
  field private _offset:Distance = 0cm
  field private _start-visible-x:Distance = 0cm
  field private constant _ui:ProtoSkinnableRecordGridUI
  field private _layouts:{FastArray-of SkRGColumnLayout}
  || The starting horizontal distance for the secondary area.
  field private _secondary-lextent:Distance = 0cm
  
  || Store to avoid a new package getter on ui for hsp-2
  || TODO: Remove in ipswich
  field private constant _internal-grid:SkRGInternalGrid

  {constructor package {default 
                           ui:ProtoSkinnableRecordGridUI,
                           internal-grid:SkRGInternalGrid
                       }
    set self._ui = ui
    set self._internal-grid = internal-grid
    set self._layouts = {{FastArray-of SkRGColumnLayout} max-size = 0}
  }

  {getter package {offset}:Distance
    {return self._offset}
  }
  
  {setter package {offset value:Distance}:void
    set value = {max 0cm, {min value, self.max-offset}}
    {if value != self._offset then
        set self._offset = value
        {self._internal-grid.note-column-scrolled}
        {self._ui.synchronize-navigation}
    }       
  }
  
  {getter package {max-offset}:Distance
    {return 
        {max
            0cm,
            self.fixed-rextent - 
            self.start-visible-x - 
            self.frozen-out-width - 
            self.available-width 
        }
    }
  }         
  
  {getter package {available-width}:Distance
    {return 
        {max 0cm, self.end-visible-x - self.start-visible-x}
    }
  }

  {getter package {scrollable-width}:Distance
    {return 
        {if self._ui.frozen-col-count > 0 then
            {max 0cm, self.available-width - self.secondary-lextent}
         else
            self.available-width
        }
    }
  }
  
  || The width of the area frozen offscreen.
  {getter package {frozen-out-width}:Distance
    || FIXME: better conditionalization
    {return
        {max 0cm, self._freeze-offset}
||--        {if self._freeze-offset > 0cm then
||--            self._start-visible-x + self._freeze-offset
||--         else
||--            0cm
||--        }
    }
  }

  {getter package {lextent}:Distance
    {return
        {if self._layouts.size > 0 then 
            self._layouts[0].lextent
         else
            0cm
        }
    }
  }
  
  || The lextent of the secondary area.
  {getter package {secondary-lextent}:Distance
    {return self._secondary-lextent}
  }

  || The rextent of the full, scrolled contents.
  {getter package {rextent}:Distance
    
    {if self._layouts.size == 0 then {return 0cm}}

    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    let constant frozen-col-count:int = ui.frozen-col-count
    let constant frozen-col-start:int = ui.frozen-col-start
    
    {if frozen-col-start >= self._layouts.size then
        {return 0cm}
     elseif (frozen-col-count + frozen-col-start) >= self._layouts.size then
        {return {self._layouts.top-of-stack}.rextent}
     elseif (frozen-col-count > 0 or frozen-col-start > 0) then
        {return
            {self._layouts.top-of-stack}.rextent +
            {max 
                0cm,
                {self._layouts.get 
                    frozen-col-count +
                    frozen-col-start - 
                    1
                }.rextent
            } +
            ui._internal-grid._vertical-grid-line-width
        }
     else
        {return {self._layouts.top-of-stack}.rextent}
    }
  }
  
  || The full width of the layout when all columns are shown
  || (when no column freeze is in effect).
  {getter package {fixed-rextent}:Distance
    {return
        {if self._layouts.size > 0 then
            self.rextent + self._offset + self._freeze-offset
         else
            0cm
        }
    }
  }

  {getter package {start-visible-x}:Distance
    {return self._start-visible-x}
  }

  {getter package {end-visible-x}:Distance
    {return
        {if-non-null layout = self._internal-grid.layout then
            {layout.get-bounds}.width
         else
            0cm
        }
    }
  }

  {method package {get i:int}:SkRGColumnLayout
    {return self._layouts[i]}
  }
  
  {getter package {size}:int
    {return self._layouts.size}
  }
  
  {getter package {for-loop-count}:int
    {return self._layouts.size}
  }

  || Synchronize column layouts with new columns.  Reuse old
  || layouts when possible. Trigger layout if needed.
  {method package {note-column-collection-changed}:void
    let columns:{Array-of RecordGridColumn} = self._ui.grid.columns
    let layouts:{FastArray-of SkRGColumnLayout} = self._layouts
    let new-layouts:{FastArray-of SkRGColumnLayout} = 
        {{FastArray-of SkRGColumnLayout} max-size = columns.size}    
    let collection-changed?:bool = (columns.size != layouts.size)

    || (n^2 implementation is ok for columns collection).
    {for tag = outer, col in columns do 
        {for l in layouts do
            {if l._column == col then 
                {new-layouts.append l}
                {continue tag = outer}
            }
        }
        || no old layout found, build a new one.
        set collection-changed? = true
        {new-layouts.append {SkRGColumnLayout col, self}}
    }

    set self._layouts = new-layouts
    {self.recompute-column-flags}
    {if collection-changed? then 
        {self.layout-columns}
     else
        {self.reposition-columns}
    }
  }
  
  || Update the cached column flags on an appropriate change.
  {method package {recompute-column-flags}:void
    let constant frozen-col-after-index:int = 
        self._ui.frozen-col-start + self._ui.frozen-col-count - 1
    {for one-layout key i in self._layouts do
        {if frozen-col-after-index >= 0 then
            {if i > frozen-col-after-index then
                set one-layout._secondary? = true
                set one-layout._scrolling? = true
             else
                set one-layout._secondary? = false
                set one-layout._scrolling? = false
            }
         else
            set one-layout._secondary? = false
            set one-layout._scrolling? = true
        }
    }    
  }
  
  || Negotiate column layout width and reposition.
  {method package {layout-columns}:void
    
    let constant ui:ProtoSkinnableRecordGridUI = self._ui
    let constant layouts:{FastArray-of SkRGColumnLayout} = self._layouts
    let constant vertical-grid-line-width:Distance =
        {ui.any-to-Distance ui.vertical-grid-line-width}
    
    || 1) Abort if no column width yet avaiable
    {if self.available-width <= 0cm then
        {return}
    }
    
    || 2) Layout
    || Calc start position 
    set self._start-visible-x =
        {if ui._row-selectors? then 
            ProtoSkinnableRecordGridUI.row-selector-width +
            vertical-grid-line-width
         else
            0cm
        }

    || Generate/convert origin elastics
    let constant pref-elastics:{FastArray-of Elastic} =
        {{FastArray-of Elastic} max-size = layouts.size}
    {for layout:SkRGColumnLayout in layouts do
        {pref-elastics.append 
            {self.get-width-as-elastic layout._column}
        }
    }

    || Calculate width available for divvying up. 
    || Remove room for grid lines as well as future ScrollBar
    || (so we don't induce spurious horizontal scroll if vertical scrollbar
    || later appears).
    let available-width:Distance = 
        self.available-width - (layouts.size * vertical-grid-line-width)
    {if not ui._vscroll.display? then 
        {dec available-width, 
            {any-to-Distance ui._vscroll.contents.thickness}
        }
    }

    || Calculate *minimum* required for each column
    let tot:Distance = 0cm
    {for e in pref-elastics do
        {inc tot, {e.unpack-as-stretchy-elastic}} || first val is minimum.
    }

||PROTO
    || If no surplus, just assign columns the minimum
    {if tot > available-width then
        {for layout:SkRGColumnLayout key i in layouts do
            set layout._width = {pref-elastics[i].unpack-as-stretchy-elastic}
||--            {dump i, layout._width/1pt}
        }
     else
        || If there is a surplus do elastic calculations to divide it
        
        || rest-elastics will store the combined elastics of all the
        || elastics which "follow" a given elastic. Assume an extra 
        || elastic at far right to absorb extra space when columns are
        || specified rigidly.  The stretch-order of this extra elastic
        || --25 -- is a critical threshold that is less stretchy than
        || proportional-stretch-order (30) but more stretchy than
        || rigid-stretch-order (20)
        let constant rest-elastics:{FastArray-of Elastic} =
            {{FastArray-of Elastic}.from-size 
                pref-elastics.size,
                unstretchable-zero-length-elastic
            }
        let rest:Elastic = {make-elastic
                               minimum-size = 0cm,
                               preferred-size = 0cm,
                               stretch-order = 25,
                               compress-order = compliant-stretch-order
                           }
        
        {for i:int = rest-elastics.size - 1 downto 0 do
            set rest-elastics[i] = rest
            set rest = {rest.add pref-elastics[i]}
        } 

        {for layout key i in layouts do
            let grant:Distance = 
                {pref-elastics[i].divide rest-elastics[i], available-width}
            {dec available-width, grant}
            set layout._width = grant
        }
    }
    
    {self.reposition-columns}
  }   
  
  || Reposition layout origins after layouts widths have
  || been changed or layouts have been shuffled.
  {method package {reposition-columns}:void

    let constant vertical-grid-line-width:Distance =
        {self._ui.any-to-Distance self._ui.vertical-grid-line-width}
    
    let constant frozen-end-after-index:int = 
        self._ui.frozen-col-start + self._ui.frozen-col-count - 1
    
    let current-extent:Distance = self._start-visible-x

    || Set the frozen offset if necessary.
    let current-freeze-offset:Distance = 0cm
    {for layout:SkRGColumnLayout key i in self._layouts do
        {if i >= self._ui.frozen-col-start then {break}}
        {inc current-freeze-offset,
            layout._width + vertical-grid-line-width
        }
    }
    
    set self._freeze-offset = current-freeze-offset
    {dec current-extent, current-freeze-offset}
    
    let secondary-set?:bool = false
    
    || Set origins, from left to right
    {for layout:SkRGColumnLayout key i in self._layouts do
        set layout._origin = current-extent
        {inc 
            current-extent, 
            layout._width + vertical-grid-line-width
        }
        {if i == frozen-end-after-index then
            set self._secondary-lextent = current-extent
            set current-extent = 0cm
            set secondary-set? = true
        }
    }
    
    || Clean up the secondary lextent cache.
    {if not secondary-set? then
        set self._secondary-lextent = self.rextent
    }
    
    {self.clip-current-offset}
    {self._internal-grid.note-column-layout-changed}    
  }

  || Resize a column, and shift all columns to the right as needed.
  || Notify the UI unless that keyword is false (for bulk updates).
  {method package {resize-column 
                      column:int, 
                      delta:Distance,
                      notify?:bool = true
                  }:void
    
    let constant layouts:{FastArray-of SkRGColumnLayout} = self._layouts
    let constant frozen-col-count:int = self._ui.frozen-col-count
    let constant frozen-col-start:int = self._ui.frozen-col-start
    let constant frozen-col-total:int = frozen-col-start + frozen-col-count
    
    set delta = {max -layouts[column]._width, delta}
    
    || Resize this column
    {inc layouts[column]._width, delta}
    
    || Adjust origin of columns to the right
    {for i:int = (column + 1) below layouts.size do
        {if column < frozen-col-total and
            i >= frozen-col-total
         then
            {break}
        }
        {inc layouts[i]._origin, delta}
    }    
    
    || Recalculate the frozen offset if necessary (offset increases left).
    {if frozen-col-start > 0 and
        column < frozen-col-start
     then
        {inc self._freeze-offset, delta}
    }
    
    || Decrease the offset if we have more than necessary now.
    {if delta < 0m and
        self.end-visible-x > self.rextent and
        self.offset > 0m
     then
        set self.offset = {max 0m, self.offset + delta}
    }
    
    || Recalculate the secondary lextent cache and ensure we're in view.
    {if (frozen-col-start > 0 or
         frozen-col-count > 0) and
        column < frozen-col-total
     then
        {if layouts.size > frozen-col-total then
            set self._secondary-lextent = 
                ({layouts.get frozen-col-total - 1}.rextent +
                 {self._ui.any-to-Distance self._ui.vertical-grid-line-width})
         else
            set self._secondary-lextent = self.rextent
        }
    }
    
    {self.clip-current-offset}
    {if notify? then
        {self._internal-grid.note-column-layout-changed}
    }
  }

  {method package {clip-current-offset}:void
    set self.offset = {min self.max-offset, self.offset}
  }
  
  {method package {scroll-to-reveal index:int}:void
    || Ensure that index is valid. Somewhat paranoid.
    let constant size:int = self.size
    {if size == 0 then 
        {return}
     elseif index >= size then
        set index = size - 1
     elseif index < 0 then
        set index = 0
    }
    || If the index is in the frozen region, we can't scroll -- return.
    {if index < (self._ui.frozen-col-count + self._ui.frozen-col-start) then
        {return}
    }

    || Left scroll or right scroll as necessary.
    || Cell's left shouldn't scroll out of bounds due to this adjustment.
    let constant layout:SkRGColumnLayout = self[index] 

    let constant start-x:Distance = 
        {if self._ui.frozen-col-start > 0 or
            self._ui.frozen-col-count > 0
         then
            self.secondary-lextent
         else
            self.start-visible-x
        }
    let constant left-gap:Distance = start-x - layout.ui-lextent  
    {if left-gap > 0m then 
        {dec self.offset, left-gap}
     elseif left-gap < 0m then
        || Don't allocate more rightwards scroll than we had available
        || to the left edge of the visible area.
        let constant right-gap:Distance =
            {min layout.ui-rextent - self.end-visible-x, -left-gap}
        {if right-gap > 0m then
            {inc self.offset, right-gap}
        }
    }

  }

  {method private {get-width-as-elastic column:RecordGridColumn}:Elastic
    
    {if not ({option-set-by-name? column, "width"} asa bool) then ||""
        {return ProtoSkinnableRecordGridUI.default-column-width}
    }
    
    let constant dc:DisplayContext = {self._ui.get-display-context}
    let spec:any = column.width
    
    || Quantize any non-elastic distance specifiation
    {type-switch spec
     case e:Elastic do
        || do-nothing
     case d:Dimension do
        set spec = {dc.quantize-size d.preferred-size}  
     else
        {if {type-of spec} isa NumericType then
            set spec = 
                {dc.quantize-size 
                    {any-to-Distance display-context = dc, spec}
                }
        }
    }
    
    || Change to elastic, via implicit cast to Dimension
    {return {dimension-to-elastic (spec asa Dimension)}} 
  }

}


||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGColumnLayout
||
|| A single horizontal column layout bundle maintained by the
|| SkRGColumnLayouts object.
||
|| Note that the origin fields are 0 based, with respect
|| to the start of the SkRGInnerRow's layout area.
||
|| The rextent/lextent getters give the
|| position in the containing SkRGInnerRow's coordinate system, 
|| taking account of the current scroll position.
||
|| The ui-xxx getters return those coordinated transformed to
|| the start of the column area.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package SkRGColumnLayout

  field package _origin:Distance = 0cm
  field package _width:Distance = 0cm
  field package _column:RecordGridColumn
  field private _parent:SkRGColumnLayouts
  
  || State of the layout's position in the logical hierarchy.
  field package _scrolling?:bool = true
  field package _secondary?:bool = false

  {constructor package {default 
                           column:RecordGridColumn, 
                           parent:SkRGColumnLayouts
                       }
    set self._column = column
    set self._parent = parent
  }
  
  || The lextent relative to the containing SequenceBox (SkRGInnerRow).
  {getter package {lextent}:Distance
    {if self._scrolling? then
        {return self._origin - self._parent.offset}
     else
        {return self._origin}
    }
  }
  
  || The lextent relative to the start of the column layout area.
  {getter package {ui-lextent}:Distance
    {if self._secondary? then
        {return self.lextent + self._parent.secondary-lextent}
     else
        {return self.lextent}
    }
  }
  
  || The rextent relative to the containing SequenceBox (SkRGInnerRow).
  {getter package {rextent}:Distance
    {return self.lextent + self._width}
  }
  
  || The rextent relative to the start of the column layout area.
  {getter package {ui-rextent}:Distance
    {if self._secondary? then
        {return self.rextent + self._parent.secondary-lextent}
     else
        {return self.rextent}
    }
  }
  
}


|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGBaseRow
||
|| Any row in the SkRGInternalGrid.
||
|| Contains two inner rows that hold actual cells or cell-like
|| Graphics.
||
|| The primary inner row is leftmost and always active.
|| When columns are frozen, they are locked in place within the
|| primary inner row.
||
|| The secondary inner row is rightmost and exists only to allow
|| a left/right disconnection when freeze frame functionality is
|| active. When no columns are frozen, it is empty and
|| should not be notified of events.
||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package abstract shared SkRGBaseRow {inherits HBox}
  
  field package constant _ui:ProtoSkinnableRecordGridUI
  
  field package constant _primary-row:SkRGBaseInnerRow
  field package constant _secondary-row:SkRGBaseInnerRow
  field package _primary-active?:bool = true
  field package _secondary-active?:bool = false
  
  {constructor package {default 
                           ui:ProtoSkinnableRecordGridUI,
                           selector:#Graphic,
                           inner-row:SkRGBaseInnerRow
                       }
    
    set self._ui = ui
    set self._primary-row = inner-row
    set self._secondary-row = {inner-row.copy-for-secondary}
    
    {if-non-null selector then
        set selector.width = ProtoSkinnableRecordGridUI.row-selector-width
        {construct-super
            selector, 
            inner-row,
            spacing = ui.vertical-grid-line-width
        }
     else
        {construct-super
            inner-row,
            spacing = ui.vertical-grid-line-width
        }
    }
    
    set self.vorigin = 0.0
    
    || Stretch children so that they are all the same height.
    || Otherwise, inner rows may be unequal height when there are
    || multiple inner rows (freeze frame).
    set self.framelike-stretch? = true
    set self.vstretch? = true
    
    || Sync the primary and secondary inner row contents.
    {self.note-frozen-column-count-changed}
    
  }
  
  {secondary-constructor package {default
                                     ui:ProtoSkinnableRecordGridUI,
                                     selector:#Graphic,
                                     inner-row:SkRGBaseInnerRow
                                 }
    || Do nothing.
  }
    
  ||---------------------------------------
  || Define get to access inner graphics
  ||----------------------------------------
  
  {method package {get i:int}:Graphic
    let constant primary-size:int = self._primary-row.child-array.size
    {if i < primary-size then
        {return self._primary-row.child-array[i].graphic}
     else
        {return self._secondary-row.child-array[i - primary-size].graphic}
    }
  }
  
  {getter package {for-loop-count}:int
    {return 
        self._primary-row.child-array.size + 
        self._secondary-row.child-array.size
    }
  }
  
  ||----------------------
  || Other methods
  ||----------------------
  
  {method package {note-column-layout-changed}:void
    {if self._primary-active? then
        {self._primary-row.request-layout}
    }
    {if self._secondary-active? then
        {self._secondary-row.request-layout}
    }
  }

  {method package {note-column-scrolled}:void
    {if self._secondary-active? then
        {self._secondary-row.note-column-scrolled}
     else
        {self._primary-row.note-column-scrolled}
    }
  }

  
  {method package {note-frozen-column-count-changed}:void
    
    || Mark width caches invalid.
    
    set self._primary-row.width-valid? = false
    set self._secondary-row.width-valid? = false

    || Resort the primary and secondary inner rows.
    
    let constant frozen-col-count:int = 
        self._ui.frozen-col-start + self._ui.frozen-col-count
    
    {if frozen-col-count == 0 then
        
        || Ensure that the primary inner row is active.
        {if not self._primary-active? then
            {self.add-at-index
                self._primary-row,
                {if self._ui._row-selectors? then 1 else 0}
            }
            set self._primary-active? = true
        }
        
        || Detach the secondary inner row.
        {self._secondary-row.detach}
        set self._secondary-active? = false
        
     else
        
        || Attach or detach the primary inner row as necessary.
        {if self._ui.frozen-col-count == 0 then
            {if self._primary-active? then
                {self._primary-row.detach}
                set self._primary-active? = false
            }
         else
            {if not self._primary-active? then
                {self.add-at-index
                    self._primary-row,
                    {if self._ui._row-selectors? then 1 else 0}
                }
                set self._primary-active? = true
            }
        }
        
        || Ensure that the secondary inner row is active.
        {if self._secondary-row.parent != self then
            {self.add self._secondary-row}
        }
        set self._secondary-active? = true
    }
    
  }
  
  {method package {destroy}:void}

  {method package {ensure-valid}:void}
  
}


||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGBaseHeaderRow
||
|| Any header row (in the header block and not Record-linked).
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package abstract SkRGBaseHeaderRow {inherits SkRGBaseRow}

  || The layer of this header, with zero as the individual, concrete
  || column headers, and increasing upwards from there.
  field package layer-index:int
  
  {constructor package {default
                           ui:ProtoSkinnableRecordGridUI,
                           layer-index:int,
                           selector:#Graphic,
                           inner-row:SkRGBaseInnerRow
                       }
    set self.layer-index = layer-index
    {construct-super ui, selector, inner-row}
    set self.active-traversal-container = null

    {self.trampoline-non-local-options}
  }
  
  {method package abstract {get i:int}:SkRGBaseColumnHeader}
  
  {method package {ensure-valid}:void
    {for col-header in self do
        {col-header.ensure-valid}
    }
  } 
  
  || Trampoline non-local options from header-options
  {method private {trampoline-non-local-options}:void
    let constant header-options:RecordGridRowOptions =
        self._ui.grid.header-options
    let constant local-options:{Array-of OptionItem} =
        {{Array-of OptionItem}}
    
    || Copy all options
    {header-options.clone-options
        self,
        copy = 
            {proc {oi:OptionItem}:OptionItem
                let (tmp:#OptionItem, local?:bool) =
                    {header-options.option-lookup-here oi.key, true}
                {if local? then
                    {local-options.append oi}
                }
                {return {oi.clone-option}}
            }
    }
    || Go back and remove local options
    {for oi in local-options do
        {self.remove-option oi.key}
    }
  }
  
}


|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGSharedHeaderRow
||
|| A superheader row, with members above one or more concrete
|| columns, and potentially above other such header rows.
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package SkRGSharedHeaderRow {inherits SkRGBaseHeaderRow}
    
  {constructor package {default
                           ui:ProtoSkinnableRecordGridUI,
                           layer-index:int
                       }
    
    {if layer-index <= 0 then {error "internal layout error"}} ||""
    
    let constant children:{FastArray-of Graphic} = 
        {{FastArray-of Graphic} max-size = ui.grid.columns.size}
    let constant col-array:{Array-of BaseRecordGridColumn} =
        {if-non-null ca = {ui.get-columns-at-layer layer-index} then
            ca
         else
            {error "internal layout error"} ||""
        }
    {for one-col in col-array do
        {type-switch one-col
         case rgcg:RecordGridColumnGroup do
            {children.append {SkRGSharedColumnHeader rgcg}}
        }
    }
    
    let constant inner-row:SkRGSharedHeaderInnerRow =
        {SkRGSharedHeaderInnerRow ui, self, children}

    {construct-super 
        ui,
        layer-index,
        {if ui._row-selectors? then {Fill} else null},
        inner-row
    }

  }
    
  {method package {get i:int}:SkRGSharedColumnHeader
    {return {super.get i} asa SkRGSharedColumnHeader}
  }
  
  {method package {note-frozen-column-count-changed}:void
    
    {super.note-frozen-column-count-changed}
    
    let constant frozen-col-count:int = 
        self._ui.frozen-col-start + self._ui.frozen-col-count
    
    {if frozen-col-count == 0 then
        
        {for i = 1 to self._secondary-row.child-array.size do
            {self._primary-row.add 
                self._secondary-row.child-array[0].graphic
            }
        }
        
     else
        
        let header-handled?:bool = false
        
        || Make sure not to use indices that may shift midstream.
        let constant header-array:{FastArray-of SkRGSharedColumnHeader} =
            {new {FastArray-of SkRGSharedColumnHeader},
                max-size = self.for-loop-count
            }
        let constant unfreeze-array:{FastArray-of SkRGSharedColumnHeader} =
            {new {FastArray-of SkRGSharedColumnHeader},
                max-size = self.for-loop-count
            }
        {for one-header in self do
            {header-array.append one-header}
        }
        
        {for one-header in header-array do

            let constant group:RecordGridColumnGroup = one-header.column-group
            
            || Possibly move a header from secondary to primary.
            {if group.first-column-index < frozen-col-count and
                group.last-column-index < frozen-col-count
             then
                {if one-header.parent != self._primary-row then
                    {self._primary-row.add one-header}
                }
                set header-handled? = true
            }
            
            || Possibly move a header from primary to secondary.
            {if group.first-column-index >= frozen-col-count and
                group.last-column-index >= frozen-col-count
             then
                {if one-header.parent != self._secondary-row then
                    {unfreeze-array.append one-header}
                }                
                set header-handled? = true
            }
            
            {if not header-handled? then
                {error "internal layout error"} ||""
            }
            
        }
        {unfreeze-array.reverse}
        {for one-header in unfreeze-array do
            {self._secondary-row.add 
                one-header,
                index = "first" ||""
            }            
        }
    }
    
  }
  
  || Find the child corresponding to the given column.
  {method package {get-header-for-column-index col:int}:#SkRGSharedColumnHeader
    {for one-header in self do
        {if one-header.column-group.first-column-index <= col and
            one-header.column-group.last-column-index >= col
         then
            {return one-header}
        }
    }
    {return null}
  }
  
}


||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGRow
||
|| Any single, concrete column row (header or data)
|| in the SkRGInternalGrid.
||
|| Contains one graphic for each concrete column.
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class abstract package SkRGRow {inherits SkRGBaseRow}

  {constructor package {default
                           ui:ProtoSkinnableRecordGridUI,
                           selector:#Graphic,
                           inner-row:SkRGInnerRow
                       }
    {construct-super ui, selector, inner-row}
||xx    set self.height = 0pt ||PROTO
  }
  
  {method package {note-frozen-column-count-changed}:void
    
    {super.note-frozen-column-count-changed}
    
    let constant frozen-col-count:int = 
        self._ui.frozen-col-start + self._ui.frozen-col-count
    let constant primary-size:int = self._primary-row.child-array.size
    let constant secondary-size:int = self._secondary-row.child-array.size
    
    {if frozen-col-count == 0 then
        
        {for i = 1 to secondary-size do
            {self._primary-row.add 
                self._secondary-row.child-array[0].graphic
            }
        }
        
     else
        
        {if primary-size < frozen-col-count then
            
            let constant move-rows:int = 
                {min frozen-col-count - primary-size, secondary-size}
            {for i = 1 to move-rows do
                {self._primary-row.add 
                    self._secondary-row.child-array[0].graphic
                }
            }            
            
         elseif primary-size > frozen-col-count then
            
            {for i = (primary-size - 1) downto frozen-col-count do
                {self._secondary-row.add
                    self._primary-row.child-array[i].graphic,
                    index = "first" ||""
                }
            }
            
        }
        
    }
    
  }

  {method package {destroy}:void
    {self.detach}
  }

}


|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGDataRow
||
|| A concrete data row, linked to an actual record index.
||
|| The row index ui's row collection needs to be maintained
|| exogenously by any code than manipulates this object.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package SkRGDataRow {inherits SkRGRow}
  
  || This is the data epoch in the associated 
  || grid ui, which this row is considered valid for.
  field private _data-epoch:int = -1
  field private _index:int
  field private _cached-selected?:bool = false
  field private _cached-current?:bool = false

  field package computed-row-background:#Background

  {constructor package {default 
                           ui:ProtoSkinnableRecordGridUI,
                           index:int
                       }
    
    || create inner row of cells
    let cells:{FastArray-of Graphic} = 
        {{FastArray-of Graphic} max-size = ui.grid.columns.size}
    {for col:RecordGridColumn in ui.grid.columns do
        let cell:RecordGridCell = {ui.get-cell col}
        set cell.record-index = index
        {cells.append cell}
    }
    let inner-row:SkRGInnerRow = {SkRGInnerRow ui, cells, false}
    
    || create selector if needed
    let selector:#Graphic = 
        {if ui._row-selectors? then
            {SkRGRecordSelector}
||--            {SizeNotifier 
||--                background = "yellow",
||--                index, true, {SkRGRecordSelector}
||--            }
         else
            null
        }
    
    {construct-super ui, selector, inner-row}
    
    set self.index = index
  }
  
  ||------------------------
  || Main properties
  ||------------------------
  
  {getter package {index}:int {return self._index}}
  {setter package {index value:int}:void 
    {if self._index != value then
        set self._index = value
        set self._data-epoch = -1
    }
    {for cell in self do
        set cell.record-index = value
    }
    {self.refresh-computed-row-background}
  }
  
  {getter package {current?}:bool
    {return 
        self.index == self._ui.grid.current-index
    }
  }
  
  {getter package {selected?}:bool
    {return 
        {self._ui.grid.selection.contains-record? self.index}
    }
  }

  ||-----------------------------
  || Implementation of SkRGRow
  ||-----------------------------
  
  {method package {get i:int}:RecordGridCell
    {return {super.get i} asa RecordGridCell}
  }

  {method package {destroy}:void
    {for rgc in self do
        set rgc.record-index = -1
        {self._ui.release-cell rgc}
    }
    {super.destroy}
  }

  {method package {ensure-valid}:void
    let sel?:bool = self.selected?
    let curr?:bool = self.current? 

    || FIXME: cwstern 2006-05-10 issue 25393 - temporary deoptimization
    || commented out to allow selection changes to show
||--    || Ensure data validity. If the current state, selection state, 
||--    || or data-epoch has changed, refresh cells and selector.
||--    {if self._data-epoch < self._ui._data-epoch or
||--        self._cached-current? != curr? or
||--        self._cached-selected? != sel?
||--     then
        {for rgc in self do
            set rgc.record-index = self.index
            {if not rgc.has-grid-focus? or
                (self._data-epoch < self._ui._data-epoch or
                 self._cached-current? != curr? or
                 self._cached-selected? != sel?)
             then
                {rgc.refresh-data}
             else
                {rgc.refresh-appearance}
            }
        }
        
        {if-non-null sel = self.selector then
            set sel.draw-current? = curr?
            set sel.draw-selected? = sel?
        }
        
        set self._data-epoch = self._ui._data-epoch
        set self._cached-selected? = sel?
        set self._cached-current? = curr? 
||--    }
    {self.refresh-computed-row-background}
  }
  
  || Set the computed row background from the relevant option.
  || Perform changes on the subrows, and don't include the selector.
  {method package {refresh-computed-row-background}:void
    let constant grid:RecordGrid = self._ui.grid
    let constant index:int = self.index
    let new-background:#Background = null
    {if-non-null p = grid.row-background-spec then
        {if index >= 0 and index < grid.records.size then
            def bkg = {p grid, grid.records[index], index}
            {if bkg != self.background then
                set new-background = bkg
            }
        }
    }
    {if new-background != self.computed-row-background then
        set self.computed-row-background = new-background
        {grid.request-draw}
    }
  }
  
  ||-----------------------------
  || Misc
  ||-----------------------------
  
  || NOTE: the following could be done more safely.
  {getter package {selector}:#SkRGRecordSelector
    {return
        {if self.child-array.size > 
            ({if self._secondary-active? then 1 else 0} +
             {if self._primary-active? then 1 else 0})
         then
            self.child-array[0].graphic asa #SkRGRecordSelector

||--            ||PROTO (not needed if SkRGRecordSelector inherits SizeNotifier
||--            {type-switch self.child-array[0].graphic
||--             case sn:SizeNotifier do
||--                sn.child.graphic asa #SkRGRecordSelector
||--             else
||--                self.child-array[0].graphic asa #SkRGRecordSelector
||--            }
         else
            null
        }
    }
  }
  
}


||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGHeaderRow
||
|| The single row of individual concrete column headers.
||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package SkRGHeaderRow {inherits SkRGRow, SkRGBaseHeaderRow}
  
  {constructor package {default ui:ProtoSkinnableRecordGridUI}
    
    || compute inner row of cells
    let headers:{FastArray-of Graphic} = 
        {{FastArray-of Graphic} max-size = ui.grid.columns.size}
    {for col:RecordGridColumn in ui.grid.columns do 
        {headers.append {SkRGColumnSelector col}} 
    }
    let constant inner-row:SkRGInnerRow = {SkRGInnerRow ui, headers, true}
    
    {construct-super.SkRGRow
        ui,
        {if ui._row-selectors? then {Fill} else null},
        inner-row
    }
    {construct-super.SkRGBaseHeaderRow ui, 0, null, inner-row}
    
  }

  {method package {get i:int}:SkRGColumnSelector
    {return {super.get i} asa SkRGColumnSelector}
  }
  
}


||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGBaseInnerRow
||
|| A sequence box that will:
|| 
|| 1) Layout its children in fixed widths columns specified 
||    exogenously by its ui's column-bounds array. 
||
|| 2) Scroll its children according to it ui's column-offset
||
|| 3) Potentially not treat its children as option childen (for
|| regular rows containing RecordGridCells).
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package abstract SkRGBaseInnerRow {inherits SequenceBox}
  
  field package constant _height-elastic:OriginElastic  
  field package  _width-elastic:OriginElastic
  field package width-valid?:bool = false
  field package constant _has-option-children?:bool
  field package constant _ui:ProtoSkinnableRecordGridUI
  field package _cached-offset:Distance = 0cm
  field package _secondary?:bool

  {constructor package {default 
                           ui:ProtoSkinnableRecordGridUI,
                           children:#{FastArray-of Graphic},
                           has-option-children?:bool,
                           secondary?:bool = false
                       }
    set self._ui = ui
    set self._has-option-children? = has-option-children? 
    {if-non-null children then
        {for child in children do
            {self.add-at-index child, "last"} ||""
        }
    }
    set self._height-elastic = unstretchable-zero-length-origin-elastic
    set self._width-elastic = {make-origin-elastic
                                  first = unstretchable-zero-length-elastic,
                                  last = {make-elastic}
                              }
    set self._secondary? = secondary?
  }
  
  {getter protected open {option-register-proc}:#{proc-type {OptionKey}:void}
    {return
        {if self._has-option-children? then
            super.option-register-proc
         else
            null
        }
    }
  }

  ||-------------------------------------------------------------
  || Copying
  || 
  || + Methods for copying the fundamentals of an SkRGInnerRow for
  ||   use in the secondary region of an SkRGRow.
  ||-------------------------------------------------------------
  
  {method package abstract {copy-for-secondary}:SkRGBaseInnerRow}
  
  ||-------------------------------------------------------------
  || Layout
  ||
  || + This object specifies its origin to be the top left corner
  || + Its children's horizontal layout is determined by the columns 
  ||   of its ui.  The children's vertical layout is fixed to be 
  ||   the row height, which results from negotiation.
  || + It is rigid in the horizontal direction, but more
  ||   flexible in the vertical direction.
  || + Negotiation with children is always width first, regardless
  ||   of negotiation with parent.
  ||-------------------------------------------------------------  
  
  {method protected open {allocate-layout-object}:SequenceLayout
    {return {SequenceLayout}}
  }

  {method public open {get-width-preference lc:LayoutContext}:Dimension
    
    || FIXME: this isn't working. Was it ever really valid? Efficiency issues?
||--    {if self.width-valid? then
||--        {return self._width-elastic}
||--    }
    
    let constant col-layouts:SkRGColumnLayouts = self._ui._col-layouts
    let constant frozen-start:int = self._ui.frozen-col-start
    let constant frozen-count:int = self._ui.frozen-col-count
    let constant frozen-total:int = frozen-start + frozen-count 
    
    let constant last-elastic:Elastic =
        || If we're primary and frozen and there's a secondary:
        {if not self._secondary? and
            frozen-total > 0 and
            frozen-total < col-layouts.size
         then
            {make-elastic
                minimum-size = 
                    {if frozen-count == 0 then
                        0cm
                     else
                        ({col-layouts.get frozen-total - 1}.rextent -
                         {if frozen-start > 0 then
                             {col-layouts.get frozen-start}.lextent
                          else
                             col-layouts.lextent   
                         })
                    }
            }
        
            || Else if we're secondary and primary is frozen:
            || (this will become zero width if secondary is empty)
         elseif self._secondary? then
            {make-elastic
                minimum-size = 
                    (col-layouts.fixed-rextent -
                     col-layouts.secondary-lextent -
                     {if frozen-start > 0 and
                         frozen-start < col-layouts.size
                      then
                         col-layouts[frozen-start].lextent -
                         col-layouts[0].lextent
                      else
                         0m
                     }),
                stretch-order = proportional-stretch-order + 1
            }
            
            || Otherwise, we're primary and want the full width.
         else
            {make-elastic
                minimum-size =
                    col-layouts.rextent - col-layouts.lextent
            }
        }
    
    set self._width-elastic = {make-origin-elastic last = last-elastic}

    set self.width-valid? = true
    {return self._width-elastic}
  }
  
  {method public open {get-height-preference lc:LayoutContext}:Dimension
    
    || Do a width first negotiation with children
    {self.set-child-widths lc}
    
    let he:OriginElastic = self._height-elastic
    {if self.child-array.size == 0 then
        set he = {he.set 0m}
    }
    {for i:int = 0 below self.child-array.size do
        let l:SequenceLayout = self.child-array[i] 
        let h:Elastic = {l.get-height-preference lc, constrained? = true}
        {if i == 0 then
            set he = {he.set-last h}
         else
            set he = {he.max-last h, dest = he} 
        }
    }
        
    {return he}
  }
  
  {method public open {set-size lc:LayoutContext, bounds:GRect}:void
    
    || We assume bounds granted have top-left origin, as requested.
    || If not, (or if not enough space granted horizontally) children
    || are simply going to be clipped.
    
    || ensure children have had their width laid out
    {self.set-child-widths lc}
    
    || layout height based on height granted and finish layout
    {for l:SequenceLayout in self.child-array do   
        {if l.invalid-epoch >= lc.epoch then {return}}
        
        let oe:OriginElastic = {l.get-height-preference lc, constrained? = true}
        let origin:Distance = {oe.place-origin bounds.height}
        {l.set-height lc, origin, origin, bounds.height - origin}
        {l.finish-layout lc}
    }   
    {super.set-size lc, bounds}
  }
  
  {method package abstract {set-child-widths lc:LayoutContext}:void}
  
  ||----------------------------------------------------------
  || Option handling. Only the selectors are option children.
  ||----------------------------------------------------------

  {method public open {notify-option-children 
                          item:OptionItem, 
                          removed?:bool
                      }:void
    {if self._has-option-children? then
        {super.notify-option-children 
            item,
            removed?
        }
    }
  }
  
  ||------------------------------------------------------
  || Scrolling
  || Transform pointer events, drawing to scrolled position.
  ||--------------------------------------------------------
  
  {method package {note-column-scrolled}:void
    let delta:Distance = self._cached-offset - self._ui._col-layouts.offset
    {if delta != 0cm then
        {for l in self.child-array do
            {l.shift-x-origin delta}
        }
        set self._cached-offset = self._ui._col-layouts.offset
    }
  }
  
}


||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGSharedHeaderInnerRow
||
|| The internal layout element of a SkRGSharedHeaderRow.
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package SkRGSharedHeaderInnerRow 
  {inherits SkRGBaseInnerRow}
  
  || Track the last layout epoch that we've set child widths on.
  field private _width-set-epoch:int

  field private _outer-row:SkRGSharedHeaderRow
  
  {constructor package {default
                           ui:ProtoSkinnableRecordGridUI,
                           outer-row:SkRGSharedHeaderRow,
                           children:#{FastArray-of Graphic},
                           secondary?:bool = false
                       }
    set self._outer-row = outer-row
    {construct-super 
        ui,
        children, 
        true, 
        secondary? = secondary?
    }
  }
  
  {method package {copy-for-secondary}:SkRGSharedHeaderInnerRow
    {return
        {SkRGSharedHeaderInnerRow
            self._ui,
            self._outer-row,
            null,
            secondary? = true
        }
    }
  }
  
  || Scale child widths to column widths.  If already computed
  || in this negotiation, don't compute again.
  {method package {set-child-widths lc:LayoutContext}:void

    let constant col-layouts:SkRGColumnLayouts = self._ui._col-layouts
    
    {if self._width-set-epoch >= lc.epoch then {return}}
    
    let col-layout-index:int = 0
    let pending-layout-index:int = -1
    {if self._secondary? then 
        {inc col-layout-index, self._ui.frozen-col-count}
    }
    
    || Note that the child count will not necessarily, or even probably,
    || match the count of SkRGColumnLayouts.
    {for i:int = 0 below self.child-array.size do
        
        let constant l:SequenceLayout = self.child-array[i]
        let constant oe:OriginElastic = {l.get-width-preference 
                                            lc, 
                                            constrained? = false
                                        }
        
        || Bump up the child width to account for shared headers.
        || Add in all column layout widths but the first.
        let child-width:Distance = 0m
        {type-switch l.graphic
         case sch:SkRGSharedColumnHeader do
            let constant group:RecordGridColumnGroup = sch.column-group
            {if group.first-column-index != -1 then
                set col-layout-index = group.first-column-index
                set pending-layout-index = group.last-column-index
                {for x = (group.first-column-index + 1) to 
                    group.last-column-index
                 do
                    {inc 
                        child-width, 
                        col-layouts[x]._width + 
                        self._ui._internal-grid._vertical-grid-line-width
                    }
                }
            }
        }
        
        || Query and add in in the first (or only) column layout.
        let constant col-dim:SkRGColumnLayout = col-layouts[col-layout-index]
        {inc child-width, col-dim._width}
        let constant child-origin:Distance = {oe.place-origin child-width}
        
        || Actually emplace the child header.
        {l.set-width
            lc, 
            {if not self._secondary? then
                (col-dim.lextent - col-layouts.start-visible-x) + child-origin
             else
                col-dim.lextent + child-origin                
            },
            child-origin,
            child-width - child-origin
        }
        
        || Adjust the concrete column index.
        {if pending-layout-index != -1 then
            set col-layout-index = pending-layout-index + 1
            set pending-layout-index = -1
         else
            {inc col-layout-index}
        }
    }
    
    set self._cached-offset = col-layouts.offset
    set self._width-set-epoch = lc.epoch
  }

}


|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGInnerRow.
||
|| A layout object for concrete column elements --
|| concrete row cells and header selectors.
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package SkRGInnerRow {inherits SkRGBaseInnerRow}

  || Track the last layout epoch that we've set child widths on.
  field private _width-set-epoch:int

  {constructor package {default 
                           ui:ProtoSkinnableRecordGridUI,
                           children:#{FastArray-of Graphic},
                           has-option-children?:bool,
                           secondary?:bool = false
                       }
    {construct-super 
        ui, 
        children, 
        has-option-children?, 
        secondary? = secondary?
    }
  }

  {method package {copy-for-secondary}:SkRGInnerRow
    {return
        {SkRGInnerRow
            self._ui,
            null,
            self._has-option-children?,
            secondary? = true
        }
    }
  }
  
  || Scale child widths to column widths.  If already computed
  || in this negotiation, don't compute again.
  {method package {set-child-widths lc:LayoutContext}:void
    
    let constant col-layouts:SkRGColumnLayouts = self._ui._col-layouts
    
    {if self._width-set-epoch >= lc.epoch then {return}}
    
    {for i:int = 0 below self.child-array.size do
        
        || Account for freeze frame in the column layout index.
        let j:int = {if self._secondary? then
                        self._ui.frozen-col-count + self._ui.frozen-col-start
                     else
                        0
                    } + i

        let constant l:SequenceLayout = self.child-array[i]
        let constant oe:OriginElastic = 
            {l.get-width-preference lc, constrained?=false}
        let constant col-dim:SkRGColumnLayout = col-layouts[j]
        let constant child-origin:Distance = {oe.place-origin col-dim._width}
        
        {l.set-width
            lc, 
            {if not self._secondary? then
                (col-dim.lextent - col-layouts.start-visible-x) + child-origin
             else
                col-dim.lextent + child-origin                
            },
            child-origin,
            col-dim._width - child-origin
        }
    }
    
    set self._cached-offset = col-layouts.offset
    set self._width-set-epoch = lc.epoch
  }

}


|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| Header Cells
|| 
|| Any cells that are in the header block and not Record-linked.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

|| An abstract parent for headers; mostly just an option bundle.
{define-class abstract package SkRGBaseColumnHeader {inherits ClipFrame}
  
  {constructor package {default ...}
    {construct-super ...}
    set self.opaque-to-events? = true
    set self.vclip? = false
    set self.hstretch? = false  
    set self.vstretch? = false
  }
  
  {method package {ensure-valid}:void}
  
}


|| Any header "cell" shared by multiple concrete columns.
{define-class package SkRGSharedColumnHeader {inherits SkRGBaseColumnHeader}
  
  field package constant column-group:RecordGridColumnGroup
  
  {constructor package {default column-group:RecordGridColumnGroup}
    
    {construct-super
        font-weight = FontWeight.bold,
        text-breakable? = false,
        horigin = 0.0,
        vorigin = 1.0,
        margin = 2px,
        valign = 0.5
    }
    
    set self.column-group = column-group
    
    let constant header:Graphic = 
        {if-non-null spec = column-group.header-spec then
            || 1) Custom header -- generate from proc, or cast to graphic
            {type-switch spec
             case brgc-proc:{proc-type {BaseRecordGridColumn}:Graphic} do
                {brgc-proc column-group}
             case rgc-proc:{proc-type {RecordGridColumn}:Graphic} do
                column-group.caption
             else
                spec asa Graphic
            }
         else
            column-group.caption
        }
    
    {self.add-internal header}

  }
  
  {method package {ensure-valid}:void
    {if-non-null grid = self.column-group.grid then
        let constant header:RecordGridRowOptions = grid.header-options
        set self.background = header.background
        set self.halign = 
            {if {set? header.halign} then
                header.halign
             else
                self.column-group.halign
            }
        set self.valign = 
            {if {set? header.valign} then
                header.valign
             else
                self.column-group.valign
            }
    }
  }
  
}


|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGColumnSelector
|| 
|| This widget shows a sort triangle next to the header
|| label, applies some default graphical options to the 
|| bundle (non-breakable, bold) and a default alignment.
||
|| Alignment on this object is manually pulled from the 
|| header-options, and the column (header-options prevail).
|| However, if the "origin" alignment is specified,  the header 
|| will actually be left, bottom align.  True origin  alignnent
|| is not supported in the vertical dimension because of technical
|| reasons (we probably need internal grids) and in the horizontal
|| dimension, because grid doesn't support column origins. 
|| Bottom, alignment is usually what you want, especially for
|| non-breakable text, However we might do better here.
||
|| Background is also pulled from the header options. 
||
|| TODO: implement valign = "origin"
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package SkRGColumnSelector {inherits SkRGBaseColumnHeader}

  field private constant _sort-graphic:SkRGSortGraphic
  field package constant column:RecordGridColumn

  {constructor package {default column:RecordGridColumn}
    set self._sort-graphic = {SkRGSortGraphic}
    set self.column = column
    {construct-super}
    let constant header:Graphic = 
        {if-non-null spec = column.header-spec then
            || 1) Custom header -- generate from proc, or cast to graphic
            {type-switch spec
             case brgc-proc:{proc-type {BaseRecordGridColumn}:Graphic} do
                {brgc-proc column}
             case rgc-proc:{proc-type {RecordGridColumn}:Graphic} do
                {rgc-proc column}
             else
                spec asa Graphic
            }
         else
            || 2) Generate header
            {if-non-null fld = column.field then 
                fld.caption   
             else 
                column.field-name
            }
        }

    {self.add-internal 
        {HBox 
            font-weight = FontWeight.bold,
            text-breakable? = false,
            || Align in bottom left of frame, by default:
            horigin = 0.0,
            || (This makes the frames default vorigin 1.0 also):
            vorigin = 1.0,
            margin = 2px,
            || Center triangle against label
            valign = 0.5,
            spacing = 3px,
            header,
            self._sort-graphic
        }
    }
  }
  
  {nonlocal-option public selected-color:FillPattern
    {self.ensure-valid}
  }

  {nonlocal-option public selected-background:Background
    {self.ensure-valid}
  }

  {method package {ensure-valid}:void

    {if-non-null grid = self.column.grid then
        let constant header:RecordGridRowOptions = grid.header-options
        let constant column:RecordGridColumn = self.column
        let sel?:bool = {grid.selection.contains-column? column} 
        {if sel? then
            set self.background = self.selected-background
            set self.color = self.selected-color
         else
            set self.background = header.background
            {unset self.color}
        }
        
        {type-switch grid.sort
         case sort:RecordGridColumnSort do 
            set self._sort-graphic.display? = (sort.column == column)
            set self._sort-graphic.ascending? = sort.ascending?
         else
            set self._sort-graphic.display? = false
        }
        
        set self.halign = 
            {if {set? header.halign} then
                header.halign
             else
                column.halign
            }
        set self.valign = 
            {if {set? header.valign} then
                header.valign
             else
                column.valign
            }
    }
  }

}


||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGHeaderMapElement
||
|| A logical grouping tracking column spans.
|| Used for determining the arrangement of headers.
|| first-col and last-col are indices for concrete data columns.
||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package SkRGHeaderMapElement
  
  field package base-col:#BaseRecordGridColumn
  field package first-col:int = -1
  field package last-col:int = -1
  
  {constructor package {default
                           base-col:#BaseRecordGridColumn,
                           first-col:int,
                           last-col:int
                       }
    set self.base-col = base-col
    set self.first-col = first-col
    set self.last-col = last-col
  }
  
  {constructor package implicit {from-group rgcg:RecordGridColumnGroup}
    set self.base-col = rgcg
    set self.first-col = rgcg.first-column-index
    set self.last-col = rgcg.last-column-index
  }
                          
}


|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|| SRGRecordSelector
||
|| Used to represent the display-record-selectors? option.
||
|| A graphical widget for selecting a record, and showing
|| if the record is the {ctext current-record} of its grid.
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
||--{define-class package SkRGRecordSelector {inherits Fill}
{define-class package SkRGRecordSelector {inherits SizeNotifier}

  field private _triangle-pixmap:#Pixmap = null
  field private _draw-selected?:bool = false
  field private _draw-current?:bool = false
  
  {constructor package {default}
    {construct-super true}
    set self.opaque-to-events? = true
  }
  
  {nonlocal-option public color:FillPattern
    set self._triangle-pixmap = null
    {self.request-draw}
  }
  
  {nonlocal-option public disabled-color:FillPattern
    set self._triangle-pixmap = null
    {self.request-draw}
  }
  
  {nonlocal-option public enabled?:bool
    set self._triangle-pixmap = null
    {self.request-draw}
  }

  {nonlocal-option public selected-color:FillPattern
    {if self._draw-selected? then
        {self.refresh-selected-colors}
    }
  }

  {nonlocal-option public selected-background:Background
    {if self._draw-selected? then
        {self.refresh-selected-colors}
    }
  }

  {setter package {draw-current? value:bool}:void             
    {if self._draw-current? != value then
        set self._draw-current? = value
        {self.request-draw}
    }
  }    

  {setter package {draw-selected? value:bool}:void             
    {if self._draw-selected? != value then
        set self._draw-selected? = value
        {self.refresh-selected-colors}
    }
  }

  {method private {refresh-selected-colors}:void
    {if self._draw-selected? then
        set self.background = self.selected-background
        set self.color = self.selected-color
     else
        {unset self.background}
        {unset self.color}
    }
  }
  
  {method private {create-triangle pixmap-width:int}:Pixmap
    
    let ret:Pixmap = 
        {Pixmap
            pixmap-width, 
            (2 * pixmap-width) - 1, 
            initial-value = {Pixel.from-uint8 0, 0, 0, alpha = 0}
        }

    let triangle-pixel:Pixel = 
        {if self.enabled? then
            {self.color.to-Pixel}
         else
            {self.disabled-color.to-Pixel}
        }
    let skip:int = 0
    {for col=0 below ret.width do
        {for row=skip below ret.height - skip do
            set ret[col, row] = triangle-pixel
        }
        {inc skip}
    }
    {return ret}
  }
  
  {method public open {draw r2d:Renderer2d}:void
    
    {super.draw r2d}
    
    || Draw triangle if current
    {if self._draw-current? then  
        || ensure we have the appropriate pixmap
        let pixel-size:Distance = r2d.pixel-size 
        let bounds:GRect = {self.layout.get-bounds}
        let pixmap-width:int = 
            {max 
                1, 
                (((bounds.width / pixel-size) * 0.50) asa int)
            }
        {if self._triangle-pixmap == null or 
            pixmap-width != self._triangle-pixmap.width 
         then
            set self._triangle-pixmap = {self.create-triangle pixmap-width}
        }
        let constant pm:Pixmap = {non-null self._triangle-pixmap}
        
        || draw the pixmap centered
        {r2d.render-pixmap 
            (bounds.width - (pm.width * pixel-size)) / 2 - bounds.lextent,
            (bounds.height - (pm.height * pixel-size)) / 2 - bounds.ascent,
            pm.width * pixel-size,
            pm.height * pixel-size,
            pm
        }
    }   
  }
  
}


||||||||||||||||||||||||||||||||||||||||||||||||||
|| SkRGSortGraphic
||
|| A graphical indicator used by column headers.
||||||||||||||||||||||||||||||||||||||||||||||||||
{define-class package SkRGSortGraphic {inherits Graphic}
  
  let package pixel-height:int = 6
  
  field private _up-map:#Pixmap = null
  field private _down-map:#Pixmap = null
  field private _display?:bool = false
  field private _ascending?:bool = true
  
  {nonlocal-option public control-actuator-color:FillPattern
    set self._up-map = null
    set self._down-map = null
    {self.request-draw}
  }
  
  {getter package {display?}:bool
    {return self._display?}
  }
  {setter package {display? value:bool}:void
    {if self._display? != value then
        set self._display? = value
        {self.request-layout}
    }
  }
  
  {getter package {ascending?}:bool
    {return self._ascending?}
  }
  {setter package {ascending? value:bool}:void
    {if self._ascending? != value then
        set self._ascending? = value
        {self.request-draw}
    }
  }
  
  {method public open {get-width-preference lc:LayoutContext}:Dimension
    {return
        {if not self.display? then
            unstretchable-zero-length-elastic
         else
            lc.layout-display-context.pixel-size * 
            ((SkRGSortGraphic.pixel-height * 2) - 1)
        }
    }
  }
  
  {method public open {get-height-preference lc:LayoutContext}:Dimension
    {return
        lc.layout-display-context.pixel-size * 
        SkRGSortGraphic.pixel-height
    }
  }
  
  || Return triangle with proper shading
  {method private {create-pixmap up?:bool}:Pixmap
    let constant ret:Pixmap =
        {Pixmap
            (SkRGSortGraphic.pixel-height * 2) - 1,
            SkRGSortGraphic.pixel-height,
            initial-value = {Pixel.from-uint8 0, 0, 0, alpha = 0}
        }
    
    let constant act-color:FillPattern = self.control-actuator-color
    let constant act-pix:Pixel = {act-color.to-Pixel}
    let constant highlight-pix:Pixel = 
        {{get-highlight-for {get-highlight-for act-color}}.to-Pixel}
    let constant shadow-pix:Pixel = 
        {{get-shadow-for {get-shadow-for act-color}}.to-Pixel}
    
    || Shadow left, color body, highlight right 
    {for row:int = 1 below ret.height do
        let constant left-edge:int = row
        let constant right-edge:int = ret.width - 1 - row
        set ret[left-edge, row] = shadow-pix
        {for i:int = left-edge + 1 below right-edge do
            set ret[i, row] = act-pix
        }
        set ret[right-edge, row] = highlight-pix
    }

    || Shadow or highlight long edge
    {for col:int = 0 below ret.width do
        set ret[col, 0] = {if up? then highlight-pix else shadow-pix}
    }
    
    {if up? then {ret.flip-vertical}} 
    {return ret}
  }
  
  {getter private {down-map}:Pixmap
    {if self._down-map == null then  
        set self._down-map = {self.create-pixmap false}
    }
    {return {non-null self._down-map}}
  }
  
  {getter private {up-map}:Pixmap
    {if self._up-map == null then  
        set self._up-map = {self.create-pixmap true}
    }
    {return {non-null self._up-map}}
  }
  
  {method public open {draw r2d:Renderer2d}:void
    {super.draw r2d}
    {if self.display? then  
        let constant pm:Pixmap = 
            {if self.ascending? then self.up-map else self.down-map}
        
        let constant bounds:GRect = {self.layout.get-bounds}
        let constant pixel-size:Distance = r2d.pixel-size
        
        {r2d.render-pixmap 
            (bounds.width - (pm.width * pixel-size)) / 2 - bounds.lextent,
            (bounds.height - (pm.height * pixel-size)) / 2 - bounds.ascent,
            pm.width * pixel-size,        
            pm.height * pixel-size,        
            pm
        }
    }   
  }    
}


||||||||||||||||||||||||||||||||||||||||||||||||||
|| RecordGridSkin and RecordGridFeel
||
||||||||||||||||||||||||||||||||||||||||||||||||||

{doc-next
    {purpose
        A {docref ControlSkin} to be used with
        {docref ProtoSkinnableRecordGridUI}.
    }
    {since 7.0}
}
{define-class public open ProtoRecordGridSkin {inherits ControlSkin}
  
  {setter protected open {ui-object new-ui:#SkinnableControlUI}:void
    {if new-ui isa #ProtoSkinnableRecordGridUI then
        set super.ui-object = new-ui
     else
        {throw
            {SkinnableAttachmentTypeException
                self,
                {non-null new-ui},
                #ProtoSkinnableRecordGridUI
            }
        }
    }
  }

}


{doc-next
    {purpose
        A {docref ControlFeel} to be used with
        {docref ProtoSkinnableRecordGridUI}.
    }
    {since 7.0}
}
{define-class public open ProtoRecordGridFeel {inherits ControlFeel}
  
  {setter protected open {ui-object new-ui:#SkinnableControlUI}:void
    {if new-ui isa #ProtoSkinnableRecordGridUI then
        set super.ui-object = new-ui
     else
        {throw
            {SkinnableAttachmentTypeException
                self,
                {non-null new-ui},
                #ProtoSkinnableRecordGridUI
            }
        }
    }
  }
}

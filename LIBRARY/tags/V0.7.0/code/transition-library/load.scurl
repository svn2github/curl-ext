||| Copyright (C) 1998-2011, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An Open Curl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{curl 7.0, 8.0 package}
{curl-file-attributes character-encoding = "windows-latin-1"}
{package COM.CURL.EXT.TRANSITION-LIBRARY,
    {compiler-directives careful? = true}
}

{import * from CURL.GUI.STANDARD}
{import * from CURL.GRAPHICS.SCENE}


{doc-next
    {purpose
        Specifies the direction of the motion in a {docref TransitionEffect}
        that supports different directions of motion.
    }
}
{define-enum public EffectDirection
    up,
    down,
    left,
    right
}

{doc-next
    {purpose
        Specifies the horizontal or vertical orientation of a {docref TransitionEffect}
        that can support both orientations.
    }
}
{define-enum public EffectOrientation
    horizontal,
    vertical
}


{doc-next
    {purpose
        Abstract superclass for animating the initial or final appearance
        of a {docref TransitionFrame} during a transition between screens.
    }
    {details
        This class is a superclass for values that can be returned by the
        {docref TransitionEffect.make-out-transition-overlay} and
        {docref TransitionEffect.make-in-transition-overlay} methods.
        Concrete instances of this class typically inherit from
        {docref PixmapTransitionOverlay},
        which manages a {docref Pixmap} that represents the
        initial or final {docref TransitionFrame} appearance that is to
        be animated.
    }
}
{define-class public abstract TransitionOverlay {inherits BaseFrame}
  
  {doc-next
    {purpose
        Construct a {docref TransitionOverlay} object.
    }
    {parameter ...,
        The call may contain keyword arguments which,
        if present, are forwarded to the {docref Graphic.default} constructor.
    }
  }
  {constructor protected {default ...}
    {construct-super ...}
  }
  
  {doc-next
    {purpose
        Set the fraction of the transition that is currently completed.
    }
    {details
        This setter is called with an argument between 0.0 and 1.0,
        representing the fraction of the transition that is completed.
        At 0.0, the appearance of this {docref TransitionOverlay}
        should be the same as that of the {docref TransitionFrame}
        before the transition began,
        while at 1.0, the appearance should be the same as the final
        {docref TransitionFrame} appearance.
        
        For a {docref TransitionOverlay} returned by
        {docref TransitionEffect.make-out-transition-overlay},
        typically this means that at 0.0 the {docref TransitionOverlay}
        is opaque and equals the initial appearance of the {docref TransitionFrame},
        while at 1.0 the {docref TransitionOverlay} is transparent
        or does not draw any pixels.
        Intermediate completion fractions yield intermediate appearances,
        depending on the style of the transition.
        When an {quote in} transition is also used
        ({docref TransitionEffect.make-in-transition-overlay} is also called),
        this rule may be modified because the {quote in} {docref TransitionOverlay}
        will be stacked on top of this one.
        
        For a {docref TransitionOverlay} returned by
        {docref TransitionEffect.make-in-transition-overlay},
        at 0.0 the {docref TransitionOverlay} should be transparent or
        not draw any pixels,
        while at 1.0 the {docref TransitionOverlay}
        should be opaque and should equal the final appearance
        of the {docref TransitionFrame}.
    }
  }
  {setter public abstract {completion c:double}:void}
  
  {doc-next
    {purpose
        Indicate whether this {docref TransitionOverlay} needs a pixmap
        that shows the final appearance after the transition.
    }
    {details
        Some {docref TransitionOverlay}s, particularly those that use 3D graphics,
        require a {docref Pixmap} for the appearance at the end of the transition,
        as well as a {docref Pixmap} for the appearance at the beginning of the transition.
        Those {docref TransitionOverlay}s return true as the value of this getter,
        indicating that the {docref Pixmap} showing the appearance at the end of the
        transition should be specified by a call to the
        {docref-abbr TransitionOverlay.set-in-pixmap} method.
    }
    {override
        The base definition of this getter always returns false.
        It can be overridden to return true in subclasses that need that treatment.
    }
  }
  {getter public {uses-in-pixmap?}:bool
    {return false}
  }
  
  {doc-next
    {purpose
        Specify the pixmap
        that shows the final appearance after the transition.
    }
    {parameter pmap,
        The {docref Pixmap} that shows the final appearance after the transition.
    }
    {details
        Some {docref TransitionOverlay}s, particularly those that use 3D graphics,
        require a {docref Pixmap} for the appearance at the end of the transition,
        as well as a {docref Pixmap} for the appearance at the beginning of the transition.
        Those {docref TransitionOverlay}s return true as the value of the
        {docref-abbr TransitionOverlay.uses-in-pixmap?} getter,
        indicating that the {docref Pixmap} showing the appearance at the end of the
        transition should be specified by a call to this method.
    }
    {override
        The base definition of this method does nothing.
        It should be overridden in subclasses that override
        {docref-abbr TransitionOverlay.uses-in-pixmap?} to return true.
    }
  }
  {method public {set-in-pixmap pmap:Pixmap}:void
  }
}


{doc-next
    {purpose
        Abstract superclass for {docref TransitionOverlay}s that are implemented
        using a {docref Pixmap}.
    }
    {notes
        This class provides a field for storing the {docref Pixmap}
        and a default constructor that initializes the {docref Pixmap} properly.
        It also provides layout methods that specify
        the {docref Pixmap}'s size as the preferred layout size for this object.
    }
}
{define-class public abstract PixmapTransitionOverlay {inherits TransitionOverlay}
  
  {doc-next
    {purpose
        The {docref Pixmap} that records the {docref TransitionFrame} appearance
        that should be animated.
    }
  }
  field protected pixmap:Pixmap
  
  {doc-next
    {purpose
        Construct a {docref PixmapTransitionOverlay} object.
    }
    {parameter pixmap,
        The {docref Pixmap} that records the {docref TransitionFrame} appearance
        that should be animated.
    }
    {notes
        This constructor saves the {docref Pixmap} in the
        {docref-abbr PixmapTransitionOverlay.pixmap} field
        and also sets the {docref Pixmap.ignore-alpha?} property to false
        to enable animation effects that depend on partial transparency.
    }
  }
  {constructor protected {default pixmap:Pixmap}
    set self.pixmap = pixmap
    set self.pixmap.ignore-alpha? = false
    {construct-super}
  }
  
  {method private {compute-width-preference lc:LayoutContext}:Dimension
    def pixmap-width = self.pixmap.width
    def pixel-size = lc.layout-display-context.pixel-size
    {return pixmap-width * pixel-size}
  }
  
  {method private {compute-height-preference lc:LayoutContext}:Dimension
    def pixmap-height = self.pixmap.height
    def pixel-size = lc.layout-display-context.pixel-size
    {return pixmap-height * pixel-size}
  }
  
  {method public {get-width-preference lc:LayoutContext}:Dimension
    {super.get-width-preference lc}
    {return {self.compute-width-preference lc}}
  }
  
  {method public {get-height-preference lc:LayoutContext}:Dimension
    {super.get-height-preference lc}
    {return {self.compute-height-preference lc}}
  }
  
  {method public {constrain-width
                     lc:LayoutContext,
                     lextent:Distance,
                     rextent:Distance}:Dimension
    {super.constrain-width lc, lextent, rextent}
    {return {self.compute-height-preference lc}}
  }
  
  {method public {constrain-height
                     lc:LayoutContext,
                     ascent:Distance,
                     descent:Distance}:Dimension
    {super.constrain-width lc, ascent, descent}
    {return {self.compute-width-preference lc}}
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that displays a steady, fully opaque, {docref Pixmap}.
    }
    {notes
        This class is used by {docref GrowTransitionEffect} and {docref ImplodeTransitionEffect}
        to steadily display the old {docref TransitionFrame} appearance while the new
        appearance builds into place on top of it.
    }
}
{define-class public SteadyPixmap {inherits PixmapTransitionOverlay}
  
  {doc-next
    {purpose
        Construct a {docref SteadyPixmap} object.
    }
    {parameter pixmap,
        The {docref Pixmap} that should be displayed by this object.
    }
  }
  {constructor public {default pixmap:Pixmap}
    {construct-super pixmap}
    set self.background = self.pixmap
  }
  
  {setter public {completion c:double}:void
    || Does nothing!
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that gradually fades from fully opaque to fully transparent.
    }
    {notes
        This class is used by {docref CrossFadeTransitionEffect}.
    }
}
{define-class public FadingPixmap {inherits PixmapTransitionOverlay}
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref PixmapTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap}
    {construct-super pixmap}
    set self.background = self.pixmap
  }
  
  {setter public {completion c:double}:void
    def ealpha = ({max 0.0, {min 1.0, 1.0 - c}} * 255) asa uint8
    {for-pixel p:Pixel in self.pixmap do
        set p = {Pixel.from-uint8 p.red-as-uint8, p.green-as-uint8, p.blue-as-uint8, alpha = ealpha}
    }
    {self.request-draw}
  }
}

{doc-next
    {purpose
        Abstract superclass for {docref TransitionOverlay}s that include
        a specified {docref EffectDirection}.
    }
    {notes
        This class provides
        {docref-abbr DirectionPixmapTransitionOverlay.vertical?} and
        {docref-abbr DirectionPixmapTransitionOverlay.sign} fields
        based on the specified {docref EffectDirection}.
    }
}
{define-class public abstract DirectionPixmapTransitionOverlay {inherits PixmapTransitionOverlay}
  {doc-next
    {purpose
        Record whether the specified {docref EffectDirection} moves in a
        vertical or a horizontal direction.
    }
    {notes
        The {docref-abbr EffectDirection.up} and {docref-abbr EffectDirection.down}
        directions yield a value of true;
        the {docref-abbr EffectDirection.left} and {docref-abbr EffectDirection.right}
        directions yield a value of false.
    }
  }
  field protected constant vertical?:bool
  
  {doc-next
    {purpose
        The sign of the {docref EffectDirection} that was specified
        when this class instance was created.
    }
    {notes
        The {docref-abbr EffectDirection.right} and {docref-abbr EffectDirection.down}
        directions yield a sign value of 1;
        the {docref-abbr EffectDirection.left} and {docref-abbr EffectDirection.up}
        directions yield a sign value of {en-dash}1.
    }
  }
  field protected constant sign:int
  
  {doc-next
    {purpose
        The most recent value supplied to this class's
        {docref-abbr TransitionEffect.completion} setter.
    }
  }
  field protected-get private-set _completion:double = 0.0
  
  {doc-next
    {purpose
        Construct a {docref DirectionPixmapTransitionOverlay} object.
    }
    {parameter pixmap,
        The {docref Pixmap} that records the {docref TransitionFrame} appearance
        that should be animated.
    }
    {parameter direction,
        The {docref EffectDirection} that describes the direction in
        which the transition effect moves.
    }
    {notes
        This constructor sets the
        {docref-abbr DirectionPixmapTransitionOverlay.vertical?} and
        {docref-abbr DirectionPixmapTransitionOverlay.sign} fields
        based on the specified {param direction}.
    }
  }
  {constructor public {default pixmap:Pixmap, direction:EffectDirection = EffectDirection.right}
    set self.vertical? =
        (direction == EffectDirection.up or direction == EffectDirection.down)
    set self.sign =
        {if direction == EffectDirection.right or direction == EffectDirection.down then 1 else -1}
    {construct-super pixmap}
  }
  
  {setter public {completion c:double}:void
    set self._completion = c
    {self.request-draw}
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that becomes transparent along a moving
        horizontal or vertical wipe line.
    }
    {notes
        This class is used by {docref WipeTransitionEffect}.
    }
}
{define-class public WipePixmap {inherits DirectionPixmapTransitionOverlay}
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref DirectionPixmapTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap, direction:EffectDirection = EffectDirection.right}
    {construct-super pixmap, direction = direction}
  }
  
  {method public {draw r2d:Renderer2d}:void
    def pixel-size = r2d.pixel-size
    def pw = self.pixmap.width
    def ph = self.pixmap.height
    def w = pw * pixel-size
    def h = ph * pixel-size
    {if self.vertical? then
        def ph1 = (self._completion * ph) asa int
        def h1 = ph1 * pixel-size
        def (y0, sy0) = {if self.sign > 0 then (h1, ph1) else (0m, 0)}
        {r2d.render-pixmap
            0m, y0,
            w, h - h1,
            self.pixmap,
            src-x = 0, src-y = sy0,
            src-width = pw, src-height = ph - ph1
        }
     else
        def pw1 = (self._completion * pw) asa int
        def w1 = pw1 * pixel-size
        def (x0, sx0) = {if self.sign > 0 then (w1, pw1) else (0m, 0)}
        {r2d.render-pixmap
            x0, 0m,
            w - w1, h,
            self.pixmap,
            src-x = sx0, src-y = 0,
            src-width = pw - pw1, src-height = ph
        }
    }
  }
}

{doc-next
    {purpose
        Abstract superclass for {docref ExplodePixmap} and {docref ImplodePixmap}.
    }
    {notes
        This class provides the common mechanism for the {quote explode} and
        {quote implode} effects,
        which differ only in the direction of motion as the completion fraction
        changes from 0 to 1.
        The common mechanism is implemented in the
        {docref-abbr ExplodeImplodePixmap.draw-aux} method.
    }
}
{define-class package abstract ExplodeImplodePixmap {inherits PixmapTransitionOverlay}
  field protected _completion:double = 0.0
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref PixmapTransitionOverlay.default} for further information.
    }
  }
  {constructor package {default pixmap:Pixmap}
    {construct-super pixmap}
  }
  
  {setter public {completion c:double}:void
    set self._completion = c
    {self.request-draw}
  }
  
  {doc-next
    {purpose
        Common drawing method for the {quote explode} and {quote implode} effects.
    }
    {parameter r2d,
        The {docref Renderer2d} to use for rendering.
    }
    {parameter c,
        The current amount of separation between the fragments that are exploding
        or imploding, expressed as a fraction from 0 to 1.
        When {param c} is 0, the fragments are fully joined to each other,
        and when {param c} is 1, they are separated so that all fragments are
        just beyond the limits of this object's graphical bounds.
    }
    {usage
        This method performs all the rendering operations that should be
        performed as part of the {docref-abbr Graphic.draw} method of these classes,
        so a subclass's {docref-abbr Graphic.draw} method need only
        calculate the proper value of {param c} and then call this method.
    }
  }
  {method protected {draw-aux r2d:Renderer2d, c:double}:void
    def pixel-size = r2d.pixel-size
    def pw = self.pixmap.width
    def ph = self.pixmap.height
    def half-pw = pw div 2
    def half-ph = ph div 2
    def w = pw * pixel-size
    def h = ph * pixel-size
    def half-w = half-pw * pixel-size
    def half-h = half-ph * pixel-size
    def pxoffset = (c * half-pw) asa int
    def pyoffset = (c * half-ph) asa int
    def xoffset = pxoffset * pixel-size
    def yoffset = pyoffset * pixel-size
    {r2d.render-pixmap
        0m, 0m,
        half-w - xoffset, half-h - yoffset,
        self.pixmap,
        src-x = pxoffset, src-y = pyoffset,
        src-width = half-pw - pxoffset, src-height = half-ph - pyoffset
    }
    {r2d.render-pixmap
        0m, half-h + yoffset,
        half-w - xoffset, h - (half-h + yoffset),
        self.pixmap,
        src-x = pxoffset, src-y = half-ph,
        src-width = half-pw - pxoffset, src-height = ph - (half-ph + pyoffset)
    }
    {r2d.render-pixmap
        half-w + xoffset, 0m,
        w - (half-w + xoffset), half-h - yoffset,
        self.pixmap,
        src-x = half-pw, src-y = pyoffset,
        src-width = pw - (half-pw + pxoffset), src-height = half-ph - pyoffset
    }
    {r2d.render-pixmap
        half-w + xoffset, half-h + yoffset,
        w - (half-w + xoffset), h - (half-h + yoffset),
        self.pixmap,
        src-x = half-pw, src-y = half-ph,
        src-width = pw - (half-pw + pxoffset), src-height = ph - (half-ph + pyoffset)
    }
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that breaks its content into four rectangles
        and slides them out toward the corners of the frame.
    }
    {notes
        This class is used by {docref ExplodeTransitionEffect}.
    }
}
{define-class public ExplodePixmap {inherits ExplodeImplodePixmap}
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref PixmapTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap}
    {construct-super pixmap}
  }
  
  {method public {draw r2d:Renderer2d}:void
    {self.draw-aux r2d, self._completion}
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that breaks its content into four rectangles
        and slides them in from the corners of the frame.
    }
    {notes
        This class is used by {docref ImplodeTransitionEffect}.
    }
}
{define-class public ImplodePixmap {inherits ExplodeImplodePixmap}
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref PixmapTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap}
    {construct-super pixmap}
  }
  
  {method public {draw r2d:Renderer2d}:void
    {self.draw-aux r2d, 1.0 - self._completion}
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that starts with the pixmap fully
        displayed and then slides it out of the frame in the specified direction.
    }
    {notes
        This class is used by {docref SlideOutTransitionEffect} and {docref PushTransitionEffect}.
    }
}
{define-class public SlideOutPixmap {inherits DirectionPixmapTransitionOverlay}
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref DirectionPixmapTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap, direction:EffectDirection = EffectDirection.right}
    {construct-super pixmap, direction = direction}
  }
  
  {method public {draw r2d:Renderer2d}:void
    def pixel-size = r2d.pixel-size
    def pw = self.pixmap.width
    def ph = self.pixmap.height
    def w = pw * pixel-size
    def h = ph * pixel-size
    {if self.vertical? then
        def ph1 = (self._completion * ph) asa int
        def h1 = ph1 * pixel-size
        def (y0, sy0) = {if self.sign > 0 then (h1, 0) else (0m, ph1)}
        {r2d.render-pixmap
            0m, y0,
            w, h - h1,
            self.pixmap,
            src-x = 0, src-y = sy0,
            src-width = pw, src-height = ph - ph1
        }
     else
        def pw1 = (self._completion * pw) asa int
        def w1 = pw1 * pixel-size
        def (x0, sx0) = {if self.sign > 0 then (w1, 0) else (0m, pw1)}
        {r2d.render-pixmap
            x0, 0m,
            w - w1, h,
            self.pixmap,
            src-x = sx0, src-y = 0,
            src-width = pw - pw1, src-height = ph
        }
    }
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that starts with the pixmap out of view
        and then slides it into the frame in the specified direction.
    }
    {notes
        This class is used by {docref SlideInTransitionEffect} and {docref PushTransitionEffect}.
    }
}
{define-class public SlideInPixmap {inherits DirectionPixmapTransitionOverlay}
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref DirectionPixmapTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap, direction:EffectDirection = EffectDirection.right}
    {construct-super pixmap, direction = direction}
  }
  
  {method public {draw r2d:Renderer2d}:void
    def pixel-size = r2d.pixel-size
    def pw = self.pixmap.width
    def ph = self.pixmap.height
    def w = pw * pixel-size
    def h = ph * pixel-size
    {if self.vertical? then
        def ph1 = (self._completion * ph) asa int
        def h1 = ph1 * pixel-size
        def (y0, sy0) = {if self.sign > 0 then (0m, ph - ph1) else (h - h1, 0)}
        {r2d.render-pixmap
            0m, y0,
            w, h1,
            self.pixmap,
            src-x = 0, src-y = sy0,
            src-width = pw, src-height = ph1
        }
     else
        def pw1 = (self._completion * pw) asa int
        def w1 = pw1 * pixel-size
        def (x0, sx0) = {if self.sign > 0 then (0m, pw - pw1) else (w - w1, 0)}
        {r2d.render-pixmap
            x0, 0m,
            w1, h,
            self.pixmap,
            src-x = sx0, src-y = 0,
            src-width = pw1, src-height = ph
        }
    }
  }
}

{doc-next
    {purpose
        Abstract superclass for {docref TransitionOverlay}s that include
        a specified {docref EffectOrientation}.
    }
    {notes
        This class provides a
        {docref-abbr DirectionPixmapTransitionOverlay.vertical?} field
        based on the specified {docref EffectOrientation}.
    }
}
{define-class public abstract OrientationPixmapTransitionOverlay {inherits PixmapTransitionOverlay}
  {doc-next
    {purpose
        Record whether the specified {docref EffectOrientation} specifies a
        vertical or a horizontal orientation.
    }
  }
  field protected constant vertical?:bool
  
  {doc-next
    {purpose
        The most recent value supplied to this class's
        {docref-abbr TransitionEffect.completion} setter.
    }
  }
  field protected-get private-set _completion:double = 0.0
  
  {doc-next
    {purpose
        Construct a {docref DirectionPixmapTransitionOverlay} object.
    }
    {parameter pixmap,
        The {docref Pixmap} that records the {docref TransitionFrame} appearance
        that should be animated.
    }
    {parameter orientation,
        The {docref EffectOrientation} that describes the direction in
        which the transition effect moves.
    }
    {notes
        This constructor sets the
        {docref-abbr DirectionPixmapTransitionOverlay.vertical?} field
        based on the specified {param orientation}.
    }
  }
  {constructor public {default pixmap:Pixmap, orientation:EffectOrientation = EffectOrientation.horizontal}
    set self.vertical? = (orientation == EffectOrientation.vertical)
    {construct-super pixmap}
  }
  
  {setter public {completion c:double}:void
    set self._completion = c
    {self.request-draw}
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that starts with the pixmap fully
        displayed and then splits it in half along a sawtooth-shaped boundary
        and slides the two halves out of the frame in the specified direction.
    }
    {notes
        This class is used by {docref SplitSlideTransitionEffect}.
    }
}
{define-class public SplitSlidePixmap {inherits OrientationPixmapTransitionOverlay}
  field private _rpixmap:Pixmap
  field private length-percent:double
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref OrientationPixmapTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap, orientation:EffectOrientation = EffectOrientation.horizontal}
    {construct-super pixmap, orientation = orientation}
    set self._rpixmap = {pixmap.clone}
    def pw = pixmap.width
    def ph = pixmap.height
    def (zzw, zzh, x0, x1, offset) =
        {if self.vertical? then
            {self.calculate-sizes ph, pw}
         else
            {self.calculate-sizes pw, ph}
        }
    def vertical? = self.vertical?
    {for-pixel pl, pr at x, y in pixmap in self._rpixmap do
        let (xx:int, yy:int) = {if vertical? then (y, x - (zzh div 2)) else (x, y)}
        set yy = yy - offset
        {if xx >= x0 then
            let zapl?:bool = true
            {if xx <= x1 then
                def xn = (xx - x0) / zzw
                let yn:double = (yy mod zzh) / zzh
                {if yn > 0.5 then set yn = 1.0 - yn}
                {if xn < 2 * yn then set zapl? = false}
            }
            {if zapl? then
                set pl = {Pixel.from-uint8 0, 0, 0, alpha = 0}
             else
                set pr = {Pixel.from-uint8 0, 0, 0, alpha = 0}
            }
         else
            set pr = {Pixel.from-uint8 0, 0, 0, alpha = 0}
        }
    }
  }
  
  {method private {calculate-sizes plength:int, pbreadth:int}:(zzl:int, zzb:int, len0:int, len1:int, offset:int)
    def zzb-over-zzl = 2 * {tan 30deg}
    let zzl:int = plength div 14
    let zzb:int = (zzl * zzb-over-zzl) asa int
    {if zzb * 3 > pbreadth then
        set zzb = pbreadth div 3
        set zzl = (zzb / zzb-over-zzl) asa int
     elseif zzb * 12 < pbreadth then
        set zzb = pbreadth div 12
        set zzl = (zzb / zzb-over-zzl) asa int
        {if zzl * 3 > plength then
            set zzl = plength div 3
            set zzb = (zzl * zzb-over-zzl) asa int
        }
    }
    def zzn = {round pbreadth, zzb} asa int
    set zzb = pbreadth div zzn
    set zzl = (zzb / zzb-over-zzl) asa int
    
    def len0 = (plength - zzl) div 2
    def len1 = (plength + zzl) div 2
    set self.length-percent = len1 / plength
    
    def offset = (pbreadth - zzb * zzn) div 2
    {return zzl, zzb, len0, len1, offset}
  }
  
  {method public {draw r2d:Renderer2d}:void
    def pixel-size = r2d.pixel-size
    def pw = self.pixmap.width
    def ph = self.pixmap.height
    def w = pw * pixel-size
    def h = ph * pixel-size
    {if self.vertical? then
        def ph1 = (self.length-percent * self._completion * ph) asa int
        def h1 = ph1 * pixel-size
        {r2d.render-pixmap
            0m, 0m,
            w, h - h1,
            self.pixmap,
            src-x = 0, src-y = ph1,
            src-width = pw, src-height = ph - ph1
        }
        {r2d.render-pixmap
            0m, h1,
            w, h - h1,
            self._rpixmap,
            src-x = 0, src-y = 0,
            src-width = pw, src-height = ph - ph1
        }
     else
        def pw1 = (self.length-percent * self._completion * pw) asa int
        def w1 = pw1 * pixel-size
        {r2d.render-pixmap
            0m, 0m,
            w - w1, h,
            self.pixmap,
            src-x = pw1, src-y = 0,
            src-width = pw - pw1, src-height = ph
        }
        {r2d.render-pixmap
            w1, 0m,
            w - w1, h,
            self._rpixmap,
            src-x = 0, src-y = 0,
            src-width = pw - pw1, src-height = ph
        }
    }
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that starts with the pixmap fully
        displayed and then splits it in half along a straight-line boundary
        and squeezes each half against the side of the frame in a way that
        resembles a door opening.
    }
    {notes
        This class is used by {docref DoorOpenTransitionEffect}.
    }
}
{define-class public DoorOpenPixmap {inherits OrientationPixmapTransitionOverlay}
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref OrientationPixmapTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap, orientation:EffectOrientation = EffectOrientation.horizontal}
    {construct-super pixmap, orientation = orientation}
  }
  
  {method public {draw r2d:Renderer2d}:void
    def pixel-size = r2d.pixel-size
    def pw = self.pixmap.width
    def ph = self.pixmap.height
    def w = pw * pixel-size
    def h = ph * pixel-size
    def c = 1.0 - {cos self._completion * 90deg}
    {if self.vertical? then
        def half-ph = ph div 2
        def half-h = half-ph * pixel-size
        def ph1 = (c * half-ph) asa int
        def h1 = ph1 * pixel-size
        {r2d.render-pixmap
            0m, 0m,
            w, half-h - h1,
            self.pixmap,
            src-x = 0, src-y = 0,
            src-width = pw, src-height = half-ph
        }
        {r2d.render-pixmap
            0m, half-h + h1,
            w, h - (half-h + h1),
            self.pixmap,
            src-x = 0, src-y = half-ph,
            src-width = pw, src-height = ph - half-ph
        }
     else
        def half-pw = pw div 2
        def half-w = half-pw * pixel-size
        def pw1 = (c * half-pw) asa int
        def w1 = pw1 * pixel-size
        {r2d.render-pixmap
            0m, 0m,
            half-w - w1, h,
            self.pixmap,
            src-x = 0, src-y = 0,
            src-width = half-pw, src-height = ph
        }
        {r2d.render-pixmap
            half-w + w1, 0m,
            w - (half-w + w1), h,
            self.pixmap,
            src-x = half-pw, src-y = 0,
            src-width = pw - half-pw, src-height = ph
        }
    }
  }
}

{doc-next
    {purpose
        Abstract superclass for {docref TransitionOverlay}s that include
        a specified rotation angle and vanishing point.
    }
}
{define-class public abstract VanishingPixmapTransitionOverlay {inherits PixmapTransitionOverlay}
  {doc-next
    {purpose
        The rotation angle through which the object turns in the course
        of the transition effect.
    }
  }
  field protected constant rotation:Angle
  
  {doc-next
    {purpose
        The x position of the {quote vanishing point} from which a growing image emerges
        or into which a shrinking image disappears.
    }
    {notes
        This value is specified as a fractional value between 0 and 1,
        with 0 at the left edge of the frame and 1 at the right.
    }
  }
  field protected constant x-percent:double
  
  {doc-next
    {purpose
        The y position of the {quote vanishing point} from which a growing image emerges
        or into which a shrinking image disappears.
    }
    {notes
        This value is specified as a fractional value between 0 and 1,
        with 0 at the top edge of the frame and 1 at the bottom.
    }
  }
  field protected constant y-percent:double
  
  {doc-next
    {purpose
        The most recent value supplied to this class's
        {docref-abbr TransitionEffect.completion} setter.
    }
  }
  field protected-get private-set _completion:double = 0.0
  
  {doc-next
    {purpose
        Construct a {docref DirectionPixmapTransitionOverlay} object.
    }
    {parameter pixmap,
        The {docref Pixmap} that records the {docref TransitionFrame} appearance
        that should be animated.
    }
    {parameter rotation,
        The rotation angle through which the object turns in the course
        of the transition effect.
    }
    {parameter (x-percent, y-percent),
        The {quote vanishing point} from which a growing image emerges
        or into which a shrinking image disappears.
        These two arguments are specified as fractional values between 0 and 1,
        with (0,0) at the top left corner of the frame and (1,1)
        at the bottom right.
    }
    {notes
        This constructor sets the
        {docref-abbr VanishingPixmapTransitionOverlay.rotation},
        {docref-abbr VanishingPixmapTransitionOverlay.x-percent}, and
        {docref-abbr VanishingPixmapTransitionOverlay.y-percent} fields
        based on the specified arguments.
    }
  }
  {constructor public {default
                          pixmap:Pixmap,
                          rotation:Angle = 0deg,
                          x-percent:Fraction = 0.5,
                          y-percent:Fraction = 0.5
                      }
    set self.rotation = rotation
    set self.x-percent = x-percent
    set self.y-percent = y-percent
    {construct-super pixmap}
  }
  
  {setter public {completion c:double}:void
    set self._completion = c
    {self.request-draw}
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that spins its image through a specified
        rotation angle while shrinking it until it finally disappears at
        a specified vanishing point.
    }
    {notes
        This class is used by {docref ShrinkTransitionEffect}.
    }
}
{define-class public ShrinkPixmap {inherits VanishingPixmapTransitionOverlay}
  
  {doc-next
    {purpose
        Construct a new {docref ShrinkPixmap} object.
    }
    {parameter pixmap,
        The {docref Pixmap} that records the {docref TransitionFrame} appearance
        that should be animated.
    }
    {parameter rotation,
        The angle through which the pixmap rotates before disappearing completely.
    }
    {parameter (x-percent, y-percent),
        The position within the frame
        (expressed as fractions between 0 and 1)
        where the old screen ultimately vanishes.
        The center of the shrinking screen moves evenly along a line
        from the middle of the frame to the specified point
        as the transition effect progresses.
    }
  }
  {constructor public {default
                          pixmap:Pixmap,
                          rotation:Angle = 0deg,
                          x-percent:Fraction = 0.5,
                          y-percent:Fraction = 0.5
                      }
    {construct-super pixmap, rotation = rotation, x-percent = x-percent, y-percent = y-percent}
  }
  
  {method public {draw r2d:Renderer2d}:void
    def scale = (1 - self._completion) * (1 - self._completion)
    def rotation = self._completion * self.rotation
    def pixel-size = r2d.pixel-size
    def pw = self.pixmap.width
    def ph = self.pixmap.height
    def w = pw * pixel-size
    def h = ph * pixel-size
    def cx = w * (scale * 0.5 + (1.0 - scale) * self.x-percent)
    def cy = h * (scale * 0.5 + (1.0 - scale) * self.y-percent)
    def rwidth = w * scale
    def rheight = h * scale
    def xo = -rwidth / 2
    def yo = -rheight / 2
    {with-render-properties
        translation = {Distance2d cx, cy},
        rotation = rotation
     on r2d do
        {r2d.render-pixmap
            xo, yo,
            rwidth, rheight,
            self.pixmap,
            src-x = 0, src-y = 0,
            src-width = pw, src-height = ph
        }
    }
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that spins its image through a specified
        rotation angle while growing from an initial appearance at
        a specified vanishing point to a final appearance where it fills the frame.
    }
    {notes
        This class is used by {docref GrowTransitionEffect}.
    }
}
{define-class public GrowPixmap {inherits VanishingPixmapTransitionOverlay}
  
  {doc-next
    {purpose
        Construct a new {docref GrowPixmap} object.
    }
    {parameter pixmap,
        The {docref Pixmap} that records the {docref TransitionFrame} appearance
        that should be animated.
    }
    {parameter rotation,
        The angle through which the pixmap rotates during the effect.
    }
    {parameter (x-percent, y-percent),
        The position within the frame
        (expressed as fractions between 0 and 1)
        where the pixmap initially appears.
        The center of the shrinking screen moves evenly along a line
        from this point to the middle of the frame
        as the transition effect progresses.
    }
  }
  {constructor public {default
                          pixmap:Pixmap,
                          rotation:Angle = 0deg,
                          x-percent:Fraction = 0.5,
                          y-percent:Fraction = 0.5
                      }
    {construct-super pixmap, rotation = rotation, x-percent = x-percent, y-percent = y-percent}
  }
  
  {method public {draw r2d:Renderer2d}:void
    def scale = self._completion * self._completion
    def rotation = (self._completion - 1.0) * self.rotation
    def pixel-size = r2d.pixel-size
    def pw = self.pixmap.width
    def ph = self.pixmap.height
    def w = pw * pixel-size
    def h = ph * pixel-size
    def cx = w * (scale * 0.5 + (1.0 - scale) * self.x-percent)
    def cy = h * (scale * 0.5 + (1.0 - scale) * self.y-percent)
    def rwidth = w * scale
    def rheight = h * scale
    def xo = -rwidth / 2
    def yo = -rheight / 2
    {with-render-properties
        translation = {Distance2d cx, cy},
        rotation = rotation
     on r2d do
        {r2d.render-pixmap
            xo, yo,
            rwidth, rheight,
            self.pixmap,
            src-x = 0, src-y = 0,
            src-width = pw, src-height = ph
        }
    }
  }
}



{doc-next
    {purpose
        Abstract superclass for {docref TransitionFrame} transition effects.
    }
    {details
        This class is a superclass of all values that can be specified for
        the {docref TransitionFrame.transition-effect} option.
        Concrete instances of this class include information about
        the duration of the transition as well as the graphical processing
        that happens during the transition.
    }
}
{define-class public abstract TransitionEffect
  
  {doc-next
    {purpose
        The duration of this {docref TransitionEffect}.
    }
    {override
        This abstract getter is overridden in subclasses of {docref TransitionEffect}
        to return a {docref Time} value that specifies the duration of a transition.
    }
  }
  {getter public abstract {duration}:Time}
  
  {doc-next
    {purpose
        A procedure that can be used to warp the time scale of a transition.
    }
    {details
        If non-null, this procedure is applied to an argument between 0 and 1
        that indicates the fraction of the total transition duration that has
        already elapsed.
        The returned value from this procedure should be between 0 and 1
        and controls the percentage of progress in the transition effect
        that should be displayed.
        This procedure should return 0 when the argument is 0
        and should return 1 when the argument is 1,
        and the procedure's value should increase monotonically between those
        two points.
        
        If this getter returns null,
        the result is the same as if the identity function
        {no-break {ctext {proc {x:double}:double {return x}}}}
        had been specified.
    }
  }
  {getter public abstract {pacing}:#{proc-type {double}:double}}
  
  {doc-next
    {purpose
        Notify a {docref TransitionEffect} that a transition is about to begin.
    }
    {details
        This method is called just before a {docref TransitionFrame} that is using
        this {docref TransitionEffect} begins a new transition.
    }
    {override
        The base version of this method does nothing,
        but subclasses can override it if there is bookkeeping to do when a
        transition begins, for example if the transition has a random element
        such as the (x, y) coordinates where the transition begins,
        which should be newly decided every time a transition starts.
        
        If a subclass does override this method to set some internal state
        variables, users of that subclass should be warned not to attach the
        same subclass instance to multiple {docref TransitionFrame}s,
        because doing so risks confusing the operation of the subclass by
        changing its state variables midway through a transition in the case
        where transitions in the multiple {docref TransitionFrame}s overlap
        in time.
    }
  }
  {method public {begin-transition}:void
    || Default method does nothing.
  }
  
  {doc-next
    {purpose
        Notify a {docref TransitionEffect} that a transition has just ended.
    }
    {details
        This method is called just after a {docref TransitionFrame} that is using
        this {docref TransitionEffect} completes a transition.
    }
    {override
        The base version of this method does nothing,
        but subclasses can override it if there is bookkeeping to do when a
        transition ends.
        
        This method would usually be used in conjunction with
        {docref TransitionEffect.begin-transition};
        please see the documentation of that method for further information.
    }
  }
  {method public {end-transition}:void
    || Default method does nothing.
  }
  
  {doc-next
    {purpose
        Create a {docref TransitionOverlay} that animates the disappearance of
        a {docref TransitionFrame}'s initial look during the course of a transition.
    }
    {parameter pmap,
        The {docref Pixmap} that represents the look of the {docref TransitionFrame}
        at the beginning of the transition.
    }
    {return-vals
        The desired {docref TransitionOverlay} object.
    }
    {override
        This abstract method must be overridden in every concrete subclass
        of {docref TransitionEffect}.
||++    This method is called only if
||++    {ctext self.{docref-abbr TransitionEffect.uses-in-out-transition-overlay?}}
||++    returns false.
||++         
||++    The base implementation of this method throws an error if called.
||++    It does not need to be overridden if
||++    {docref-abbr TransitionEffect.uses-in-out-transition-overlay?} is overridden
||++    to return true.
    }
  }
  {method public abstract {make-out-transition-overlay pmap:Pixmap}:TransitionOverlay}
  
  {doc-next
    {purpose
        Indicate whether the {docref-abbr TransitionEffect.make-in-transition-overlay} method
        of this {docref TransitionEffect} should be called.
    }
    {details
        This getter returns true if this {docref TransitionEffect} uses a
        {docref TransitionOverlay} that animates the appearance of the final look that the
        {docref TransitionFrame} will have at the end of the transition.
    }
    {override
        The base implementation of this getter returns false;
        subclasses that provide a {docref-abbr TransitionEffect.make-in-transition-overlay} method
        should override this getter to return true.
    }
  }
  {getter public {uses-in-transition-overlay?}:bool
    {return false}
  }
  
  {doc-next
    {purpose
        Create a {docref TransitionOverlay} that animates the appearance of
        a {docref TransitionFrame}'s final look during the course of a transition.
    }
    {parameter pmap,
        The {docref Pixmap} that represents the look that the {docref TransitionFrame}
        should have at the end of the transition.
    }
    {return-vals
        The desired {docref TransitionOverlay} object.
    }
    {override
        This method is called only if
        {ctext self.{docref-abbr TransitionEffect.uses-in-transition-overlay?}}
        returns true.
        Therefore, if this method is overridden,
        {docref-abbr TransitionEffect.uses-in-transition-overlay?} should also be overridden.
        
        The base implementation of this method throws an error if called.
        It does not need to be overridden unless
        {docref-abbr TransitionEffect.uses-in-transition-overlay?} is overridden
        to return true.
    }
  }
  {method public {make-in-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {uninitialized-value-for-type TransitionOverlay}}
  }
}

{doc-next
    {purpose
        Abstract superclass for {docref TransitionEffect}s with controllable durations.
    }
    {details
        This class builds on {docref TransitionEffect} and adds fields for holding the
        duration and pacing for the effect, implements the {docref-abbr TransitionEffect.duration}
        getter to return that duration, and provides a default constructor
        that sets the duration from a keyword argument.
    }
}
{define-class public abstract StandardTransitionEffect {inherits TransitionEffect}
  
  || The fields that hold the specified duration and pacing:
  field private constant _duration:Time
  field private constant _pacing:#{proc-type {double}:double}
  
  {getter public {duration}:Time
    {return self._duration}
  }
  
  {getter public {pacing}:#{proc-type {double}:double}
    {return self._pacing}
  }
  
  {doc-next
    {purpose
        Construct a new {docref StandardTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
        This is the value that will be returned by the {docref-abbr TransitionEffect.duration} getter
        for this object.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
  }
  {constructor protected {default
                             duration:Time = 0.3s,
                             pacing:#{proc-type {double}:double} = null
                         }
    set self._duration = duration
    set self._pacing = pacing
  }
}

{doc-next
    {purpose
        A cross-fade effect that causes a {docref TransitionFrame}'s old screen to fade smoothly
        into the new screen.
    }
}
{define-class public CrossFadeTransitionEffect {inherits StandardTransitionEffect}
  
  {doc-next
    {purpose
        Construct a new {docref CrossFadeTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
  }
  {constructor public {default
                          duration:Time = 0.3s,
                          pacing:#{proc-type {double}:double} = null
                      }
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {FadingPixmap pmap}}
  }
}

{doc-next
    {purpose
        An {quote explode} effect that causes a {docref TransitionFrame}'s old screen
        to slide out to the four corners of the {docref TransitionFrame}.
    }
}
{define-class public ExplodeTransitionEffect {inherits StandardTransitionEffect}
  
  {doc-next
    {purpose
        Construct a new {docref ExplodeTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
  }
  {constructor public {default
                          duration:Time = 0.3s,
                          pacing:#{proc-type {double}:double} = null
                      }
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {ExplodePixmap pmap}}
  }
}

{doc-next
    {purpose
        An {quote implode} effect that causes a {docref TransitionFrame}'s new screen
        to slide in from the four corners of the {docref TransitionFrame}.
    }
}
{define-class public ImplodeTransitionEffect {inherits StandardTransitionEffect}
  
  {doc-next
    {purpose
        Construct a new {docref ImplodeTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
  }
  {constructor public {default
                          duration:Time = 0.3s,
                          pacing:#{proc-type {double}:double} = null
                      }
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {SteadyPixmap pmap}}
  }
  
  {getter public {uses-in-transition-overlay?}:bool
    {return true}
  }
  
  {method public {make-in-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {ImplodePixmap pmap}}
  }
}

{doc-next
    {purpose
        A wipe effect that causes a {docref TransitionFrame}'s new screen
        to appear behind a line that moves across the frame.
    }
}
{define-class public WipeTransitionEffect {inherits StandardTransitionEffect}
  field private direction:EffectDirection
  
  {doc-next
    {purpose
        Construct a new {docref WipeTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
    {parameter direction,
        The direction in which the wipe line travels.
    }
  }
  {constructor public {default
                          duration:Time = 0.3s,
                          pacing:#{proc-type {double}:double} = null,
                          direction:EffectDirection = EffectDirection.up
                      }
    set self.direction = direction
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {WipePixmap pmap, direction = self.direction}}
  }
}

{doc-next
    {purpose
        An effect that causes a {docref TransitionFrame}'s old screen
        to slide out in a specified direction.
    }
}
{define-class public SlideOutTransitionEffect {inherits StandardTransitionEffect}
  field private direction:EffectDirection
  
  {doc-next
    {purpose
        Construct a new {docref SlideOutTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
    {parameter direction,
        The direction in which the old screen slides out.
    }
  }
  {constructor public {default
                          duration:Time = 0.3s,
                          pacing:#{proc-type {double}:double} = null,
                          direction:EffectDirection = EffectDirection.down
                      }
    set self.direction = direction
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {SlideOutPixmap pmap, direction = self.direction}}
  }
}

{doc-next
    {purpose
        An effect that causes a {docref TransitionFrame}'s new screen
        to slide in in a specified direction.
    }
}
{define-class public SlideInTransitionEffect {inherits StandardTransitionEffect}
  field private direction:EffectDirection
  
  {doc-next
    {purpose
        Construct a new {docref SlideInTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
    {parameter direction,
        The direction in which the new screen slides in.
    }
  }
  {constructor public {default
                          duration:Time = 0.3s,
                          pacing:#{proc-type {double}:double} = null,
                          direction:EffectDirection = EffectDirection.down
                      }
    set self.direction = direction
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {WipePixmap pmap, direction = self.direction}}
  }
  
  {getter public {uses-in-transition-overlay?}:bool
    {return true}
  }
  
  {method public {make-in-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {SlideInPixmap pmap, direction = self.direction}}
  }
}

{doc-next
    {purpose
        An effect that causes a {docref TransitionFrame}'s new screen
        to slide in, {quote pushing} the old screen to slide out,
        in a specified direction.
    }
}
{define-class public PushTransitionEffect {inherits StandardTransitionEffect}
  field private direction:EffectDirection
  
  {doc-next
    {purpose
        Construct a new {docref PushTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
    {parameter direction,
        The direction in which the screens slide.
    }
  }
  {constructor public {default
                          duration:Time = 0.3s,
                          pacing:#{proc-type {double}:double} = null,
                          direction:EffectDirection = EffectDirection.down
                      }
    set self.direction = direction
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {SlideOutPixmap pmap, direction = self.direction}}
  }
  
  {getter public {uses-in-transition-overlay?}:bool
    {return true}
  }
  
  {method public {make-in-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {SlideInPixmap pmap, direction = self.direction}}
  }
}

{doc-next
    {purpose
        An effect that causes a {docref TransitionFrame}'s old screen
        to split along a sawtooth line and slide out,
        revealing the new screen.
    }
}
{define-class public SplitSlideTransitionEffect {inherits StandardTransitionEffect}
  field private orientation:EffectOrientation
  
  {doc-next
    {purpose
        Construct a new {docref SplitSlideTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
    {parameter orientation,
        The orientation of the split line
        (horizontal or vertical).
    }
  }
  {constructor public {default
                          duration:Time = 0.5s,
                          pacing:#{proc-type {double}:double} = null,
                          orientation:EffectOrientation = EffectOrientation.horizontal
                      }
    set self.orientation = orientation
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {SplitSlidePixmap pmap, orientation = self.orientation}}
  }
}

{doc-next
    {purpose
        An effect that causes a {docref TransitionFrame}'s old screen
        to split as if painted on an opening door,
        revealing the new screen.
    }
}
{define-class public DoorOpenTransitionEffect {inherits StandardTransitionEffect}
  field private orientation:EffectOrientation
  
  {doc-next
    {purpose
        Construct a new {docref DoorOpenTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
    {parameter orientation,
        The orientation of the split line
        (horizontal or vertical).
    }
  }
  {constructor public {default
                          duration:Time = 0.5s,
                          pacing:#{proc-type {double}:double} = null,
                          orientation:EffectOrientation = EffectOrientation.horizontal
                      }
    set self.orientation = orientation
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {DoorOpenPixmap pmap, orientation = self.orientation}}
  }
}

{doc-next
    {purpose
        An effect that causes a {docref TransitionFrame}'s old screen
        to shrink and disappear,
        revealing the new screen.
    }
    {notes
        The shrinking screen can optionally rotate while shrinking,
        and the position where it ultimately vanishes can be specified.
    }
}
{define-class public ShrinkTransitionEffect {inherits StandardTransitionEffect}
  field protected rotation:Angle
  field protected x-percent:double
  field protected y-percent:double
  
  {doc-next
    {purpose
        Construct a new {docref ShrinkTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
    {parameter rotation,
        The angle through which the old screen rotates before disappearing completely.
    }
    {parameter (x-percent, y-percent),
        The position within the {docref TransitionFrame}
        (expressed as fractions between 0 and 1)
        where the old screen ultimately vanishes.
        The center of the shrinking screen moves evenly along a line
        from the middle of the {docref TransitionFrame} to the specified point
        as the transition effect progresses.
    }
  }
  {constructor public {default
                          duration:Time = 0.5s,
                          pacing:#{proc-type {double}:double} = null,
                          rotation:Angle = 0deg,
                          x-percent:Fraction = 0.5,
                          y-percent:Fraction = 0.5
                      }
    set self.rotation = rotation
    set self.x-percent = x-percent
    set self.y-percent = y-percent
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {ShrinkPixmap pmap, rotation = self.rotation, x-percent = self.x-percent, y-percent = self.y-percent}}
  }
}

{doc-next
    {purpose
        An effect that causes a {docref TransitionFrame}'s new screen
        to grow from nothing until it completely covers the old screen.
    }
    {notes
        The growing screen can optionally rotate while growing,
        and the position where it initially appears can be specified.
    }
}
{define-class public GrowTransitionEffect {inherits StandardTransitionEffect}
  field protected rotation:Angle
  field protected x-percent:double
  field protected y-percent:double
  
  {doc-next
    {purpose
        Construct a new {docref GrowTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
    {parameter rotation,
        The angle through which the new screen rotates as it moves into place.
    }
    {parameter (x-percent, y-percent),
        The position within the {docref TransitionFrame}
        (expressed as fractions between 0 and 1)
        from which the new screen grows.
        The center of the growing screen moves evenly along a line
        from the specified point
        to the middle of the {docref TransitionFrame}
        as the transition effect progresses.
    }
  }
  {constructor public {default
                          duration:Time = 0.5s,
                          pacing:#{proc-type {double}:double} = null,
                          rotation:Angle = 0deg,
                          x-percent:Fraction = 0.5,
                          y-percent:Fraction = 0.5
                      }
    set self.rotation = rotation
    set self.x-percent = x-percent
    set self.y-percent = y-percent
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {SteadyPixmap pmap}}
  }
  
  {getter public {uses-in-transition-overlay?}:bool
    {return true}
  }
  
  {method public {make-in-transition-overlay pmap:Pixmap}:TransitionOverlay
    {return {GrowPixmap pmap, rotation = self.rotation, x-percent = self.x-percent, y-percent = self.y-percent}}
  }
}

{doc-next
    {purpose
        Abstract superclass for {docref TransitionOverlay}s that
        use 3D effects.
    }
    {notes
        This class provides
        {docref-abbr Pixmap3dTransitionOverlay.scene-graphic} and
        {docref-abbr Pixmap3dTransitionOverlay.scene} fields,
        and a {docref-abbr Pixmap3dTransitionOverlay.make-scene} method
        for initializing them.
    }
}
{define-class public abstract Pixmap3dTransitionOverlay {inherits PixmapTransitionOverlay}
  
  {doc-next
    {purpose
        The {docref SceneGraphic} within which the transition will be displayed.
    }
  }
  field protected scene-graphic:#SceneGraphic = null
  
  {doc-next
    {purpose
        The {docref Scene} within which the transition will be displayed.
    }
  }
  field protected scene:#Scene = null
  
  {doc-next
    {purpose
        The cotangent of the field of view angle in the 3D scene that displays
        the transition.
    }
    {notes
        This value controls how extreme the perspective effects in the 3D view are.
        When this value is smaller, the perspective is more extreme;
        when this value is larger, the perspective is more flattened.
    }
  }
  field protected constant fov-cotangent:double = 3.0
  
  {doc-next
    {purpose
        Construct a {docref Pixmap3dTransitionOverlay} object.
    }
    {parameter pixmap,
        The {docref Pixmap} that records the {docref TransitionFrame} appearance
        that should be animated.
    }
    {notes
        See {docref PixmapTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap}
    {construct-super pixmap}
  }
  
  {getter public {uses-in-pixmap?}:bool
    {return true}
  }
  
  {doc-next
    {purpose
        Make the {docref Scene} and {docref SceneGraphic} that will
        be used to display this transition.
    }
    {return-vals
        The required {docref Scene} and {docref SceneGraphic} objects,
        which will also have been stored into the
        {docref-abbr Pixmap3dTransitionOverlay.scene} and
        {docref-abbr Pixmap3dTransitionOverlay.scene-graphic} fields.
    }
    {details
        This method creates the necessary {docref Scene}-related objects
        and connects them together.
        The {docref-abbr Pixmap3dTransitionOverlay.scene} and
        {docref-abbr Pixmap3dTransitionOverlay.scene-graphic} fields are initialized,
        and the {docref SceneGraphic} is added to the graphic hierarchy
        of this {docref Pixmap3dTransitionOverlay} object.
    }
  }
  {method protected {make-scene}:(Scene, SceneGraphic)
    def camera =
        {Camera.create-perspective-camera
            position = {Distance3d 0m, 0m, 1m * self.fov-cotangent},
            near-clipping-plane = 0.1m,
            far-clipping-plane = 100m,
            field-of-view = 2.0 * {atan 0.5 / self.fov-cotangent}
        }
    def scene =
        {Scene
            camera = camera
        }
    def scene-graphic =
        {SceneGraphic
            background = "gray",
            camera-motion-mode = "none",
            scene
        }
    {self.add-internal scene-graphic}
    set self.scene-graphic = scene-graphic
    set self.scene = scene
    {return scene, scene-graphic}
  }
  
  {doc-next
    {purpose
        Compute various useful parameters for 3D transition effects.
    }
    {parameter pmap,
        The full {docref Pixmap} that contains the {quote from} or {quote to}
        version of the {docref TransitionFrame} contents.
        The height and width of {param pmap} are used to determine
        the size parameters that are returned,
        and the Pixmap contents are used to create the {docref FillPattern}
        that is returned.
    }
    {parameter quad-scale,
        The size of the 3D object that should be created to display
        {param pmap},
        along the shorter dimension of the Pixmap.
        If {param pmap} has a {quote landscape} orientation, this will
        be the height of the Pixmap;
        otherwise it will be the width.
    }
    {return-vals
        Four values are returned:
        {enumerate
            {item The width for the 3D object.}
            {item The height for the 3D object.}
            {item The z coordinate at which to place the 3D object.}
            {item A {docref FillPattern} that will render the contents of {param pmap}.}
        }
        If a quad is sized and placed as specified by the first three return values,
        it will exactly fill the bounds of the {docref SceneGraphic} object
        and will have the correct aspect ratio for {param pmap}.
    }
  }
  {method protected {get-3d-sizes
                        pmap:Pixmap, quad-scale:Distance
                    }:(quad-width:Distance, quad-height:Distance, z:Distance, fill-pattern:FillPattern)
    def fill-pattern = {FillPattern.from-pixmap pmap}
    def z = (1m - quad-scale) * self.fov-cotangent
    def pw = pmap.width
    def ph = pmap.height
    {if pw >= ph then
        def quad-height = quad-scale
        def quad-width = (quad-scale * pw) / ph
        {return quad-width, quad-height, z, fill-pattern}
     else
        def quad-width = quad-scale
        def quad-height = (quad-scale * ph) / pw
        {return quad-width, quad-height, z, fill-pattern}
    }
  }
  
  {doc-next
    {purpose
        Create a 3D quad that renders a given {docref Pixmap}
        and place it in the current 3D {docref Scene}.
    }
    {parameter pmap,
        The full {docref Pixmap} that contains the
        content to be viewed in the {docref Scene}.
    }
    {parameter quad-scale,
        The size (in the 3D scene) of the quad that should be created to display
        {param pmap},
        along the shorter dimension of the Pixmap.
        If {param pmap} has a {quote landscape} orientation, this will
        be the height of the Pixmap;
        otherwise it will be the width.
    }
    {return-vals
        The resulting {docref Quad} object is returned,
        after having already been added to {ctext self.scene}.
    }
  }
  {method protected {make-simple-quad pmap:Pixmap, quad-scale:Distance}:Quad
    def (quad-width, quad-height, z, fill-pattern) = {self.get-3d-sizes pmap, quad-scale}
    def quad =
        {Quad
            fill-pattern = fill-pattern,
            z = z,
            -0.5 * quad-width, -0.5 * quad-height, quad-width, quad-height
        }
    {self.scene.add-object quad}
    {return quad}
  }
  
  {doc-next
    {purpose
        Create a 3D quad that renders a portion of a given {docref Pixmap}
        and place it in the current 3D {docref Scene}.
    }
    {parameter pmap,
        The full {docref Pixmap} that contains the
        content to be viewed in the {docref Scene}.
    }
    {parameter quad-scale,
        The size (in the 3D scene) of the quad that would display
        {param pmap} in full,
        measured along the shorter dimension of the Pixmap.
        If {param pmap} has a {quote landscape} orientation, this will
        be the height of the Pixmap;
        otherwise it will be the width.
    }
    {parameter (s0, s1, t0, t1),
        Texture coordinates that indicate the portion of {param pmap}
        that should be included in the {docref Quad} that is created
        by this method call.
        {no-break ({param s0}, {param t0})} gives the texture coordinates
        of the upper left corner of the area to be included, and
        {no-break ({param s1}, {param t1})} gives the texture coordinates
        of the lower right corner.
        The default values of these arguments are
        {no-break (0, 0)} for the upper left corner and
        {no-break (1, 1)} for the lower right corner,
        which will cause the entire Pixmap to be included.
        Specifying values between 0 and 1 for these arguments
        will designate a smaller area to be included.
    }
    {return-vals
        The resulting {docref Quad} object is returned,
        after having already been added to {ctext self.scene}.
        The {docref Quad} will have been placed in the scene
        at a position that corresponds to its texture coordinates,
        so if this method is called repeatedly with different
        texture coordinates to create a set of {docref Quad}s
        that collectively cover {param pmap},
        the {docref Quad}s will be arranged in the scene so that
        the appearance is the same as if just one {docref Quad}
        had been created for the entire Pixmap.
    }
  }
  {method protected {make-partial-quad
                      pmap:Pixmap,
                      quad-scale:Distance,
                      s0:Fraction = 0.0,
                      s1:Fraction = 1.0,
                      t0:Fraction = 0.0,
                      t1:Fraction = 1.0
                  }:Quad
    def (quad-width, quad-height, z, fill-pattern) = {self.get-3d-sizes pmap, quad-scale}
    def quad =
        {PartialQuad
            s0 = s0, s1 = s1, t0 = t0, t1 = t1,
            fill-pattern = fill-pattern,
            z = z,
            (s0 - 0.5) * quad-width,
            (t0 - 0.5) * quad-height,
            (s1 - s0) * quad-width,
            (t1 - t0) * quad-height
        }
    {self.scene.add-object quad}
    {return quad}
  }
  
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that 
        rotates the old screen by 90 degrees in 3D, revealing the new screen.
    }
    {notes
        This class is used by {docref Spin3dTransitionEffect}.
    }
}
{define-class public Spin3dPixmap {inherits Pixmap3dTransitionOverlay}
  
  field private quad:#Quad = null
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref Pixmap3dTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap}
    {construct-super pixmap}
  }
  
  {method public {set-in-pixmap pmap:Pixmap}:void
    {if self.scene-graphic == null then
        || Create the SceneGraphic if necessary.
        set self.completion = 0.0
    }
    {self.make-simple-quad pmap, 10m}
  }
  
  {setter public {completion c:double}:void
    def scene-graphic =
        {if-non-null sc = self.scene-graphic then
            sc
         else
            def (scene, scene-graphic) = {self.make-scene}
            def quad = {self.make-simple-quad self.pixmap, 1m}
            set self.quad = quad
            scene-graphic
        }
    
    def xform = {Transformation3d}
    {xform.local-rotate angle = c * 90deg}
    set self.quad.transformation = xform
    {scene-graphic.update-drawable}
    {self.request-draw}
  }
}

{doc-next
    {purpose
        An effect that causes a {docref TransitionFrame}'s old screen
        to rotate by 90 degrees in 3D, revealing the new screen.
    }
    {details
        The old screen rotates by 90 degrees from its initial position
        until it is edge-on to the viewer and hence becomes invisible,
        and at that point the transition effect ends.
    }
}
{define-class public Spin3dTransitionEffect {inherits StandardTransitionEffect}
  
  {doc-next
    {purpose
        Construct a new {docref Spin3dTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
  }
  {constructor public {default
                          duration:Time = 0.5s,
                          pacing:#{proc-type {double}:double} = null
                      }
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay out-pmap:Pixmap}:TransitionOverlay
    {return {Spin3dPixmap out-pmap}}
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that 
        rotates the old screen by 180 degrees in 3D,
        revealing the new screen as the back side of the old screen.
    }
    {notes
        This class is used by {docref Spin180TransitionEffect}.
    }
}
{define-class public Spin180Pixmap {inherits Pixmap3dTransitionOverlay}
  
  field private out-quad:#Quad = null
  field private in-quad:#Quad = null
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref Pixmap3dTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap}
    {construct-super pixmap}
  }
  
  {method public {set-in-pixmap pmap:Pixmap}:void
    {if self.scene-graphic == null then
        || Create the SceneGraphic if necessary.
        set self.completion = 0.0
    }
    set self.in-quad = {self.make-simple-quad pmap, 1m}
  }
  
  {setter public {completion c:double}:void
    def scene-graphic =
        {if-non-null sc = self.scene-graphic then
            sc
         else
            def (scene, scene-graphic) = {self.make-scene}
            def quad = {self.make-simple-quad self.pixmap, 1m}
            set self.out-quad = quad
            scene-graphic
        }
    
    def out-xform = {Transformation3d}
    {out-xform.local-rotate angle = c * 180deg}
    {out-xform.local-translate 0m, 0m, 0.1mm}
    set self.out-quad.transformation = out-xform
    {if-non-null in-quad = self.in-quad then
        def in-xform = {Transformation3d}
        {in-xform.local-rotate angle = (1.0 + c) * 180deg}
        {in-xform.local-translate 0m, 0m, 0.1mm}
        set in-quad.transformation = in-xform
    }
    {scene-graphic.update-drawable}
    {self.request-draw}
  }
}

{doc-next
    {purpose
        An effect that causes a {docref TransitionFrame}'s old screen
        to rotate by 180 degrees in 3D, revealing the new screen
        as the back side of the old screen.
    }
    {details
        The old screen rotates by 180 degrees from its initial position
        and after it has rotated by 90 degrees, the new screen is seen
        to be on the back side of the old screen.
        After the 180-degree rotation is complete, the new screen is
        fully installed.
    }
}
{define-class public Spin180TransitionEffect {inherits StandardTransitionEffect}
  
  {doc-next
    {purpose
        Construct a new {docref Spin180TransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
  }
  {constructor public {default
                          duration:Time = 0.5s,
                          pacing:#{proc-type {double}:double} = null
                      }
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay out-pmap:Pixmap}:TransitionOverlay
    {return {Spin180Pixmap out-pmap}}
  }
}

{doc-next
    {purpose
        A {docref Quad} that allows texture coordinates to be specified in its
        constructor call.
    }
    {usage
        By specifying texture coordinates to the constructor of this class,
        a programmer can cause just a portion of a given {docref FillPattern}
        to be mapped onto the surface of the {docref PartialQuad}.
    }
}
{define-class package PartialQuad {inherits Quad}
  
  field private s0:Fraction
  field private s1:Fraction
  field private t0:Fraction
  field private t1:Fraction
  
  {doc-next
    {purpose
        Construct a {docref PartialQuad} object.
    }
    {parameter (s0, t0),
        The texture coordinates to use for the top left corner of the quad.
    }
    {parameter (s1, t1),
        The texture coordinates to use for the bottom right corner of the quad.
    }
    {parameter ...,
        Any other keyword and positional arguments may be supplied, if they
        are acceptable to the {docref Quad.default} constructor.
    }
  }
  {constructor package {default
                           s0:Fraction = 0.0,
                           s1:Fraction = 1.0,
                           t0:Fraction = 0.0,
                           t1:Fraction = 1.0,
                           ...
                       }
    set self.s0 = s0
    set self.s1 = s1
    set self.t0 = t0
    set self.t1 = t1
    {with-compiler-directives allow-slow-spliced-arguments? = true do
        {construct-super ...}
    }
  }
  
  {method open public {paint renderer:Renderer3d, viewport-width:Distance, viewport-height:Distance}:void
    {with 
        renderer.texture = {self.fill-pattern.to-Texture},
        renderer.lighting-enabled? = self.lighting-enabled?,
        renderer.ambient-material-color = self.ambient-color,
        renderer.diffuse-material-color = self.diffuse-color,
        renderer.specular-material-color = self.specular-color,
        renderer.specular-material-shininess = self.shininess
     do
        let ax:Distance = self.x
        let ay:Distance = self.y
        let az:Distance = self.z
        let bx:Distance = ax + self.width
        let by:Distance = ay + self.height
        {render-primitive
            p:Primitive,
            type = Primitive.quads
            on renderer do
            {p.normal3fv {FloatDirection3d 0, 0, 1}}
            {p.texture-coord2 self.s0, self.t1}
            {p.vertex3 ax, ay, az}
            {p.texture-coord2 self.s1, self.t1}
            {p.vertex3 bx, ay, az}
            {p.texture-coord2 self.s1, self.t0}
            {p.vertex3 bx, by, az}
            {p.texture-coord2 self.s0, self.t0}
            {p.vertex3 ax, by, az}
        }
    }
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that implements
        an effect that looks like a stiff page is being turned in a book,
        revealing the new screen as the next double-page spread in the book.
    }
    {notes
        This class is used by {docref StiffPageTurnTransitionEffect}.
    }
}
{define-class public StiffPageTurnPixmap {inherits Pixmap3dTransitionOverlay}
  
  field private out-quad:#Quad = null
  field private in-quad:#Quad = null
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref Pixmap3dTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap}
    {construct-super pixmap}
  }
  
  {method public {set-in-pixmap pmap:Pixmap}:void
    {if self.scene-graphic == null then
        || Create the SceneGraphic if necessary.
        set self.completion = 0.0
    }
    set self.in-quad = {self.make-partial-quad pmap, 1m}
    {self.make-partial-quad pmap, 1m, s1 = 0.5}
    {self.make-partial-quad self.pixmap, 1m, s0 = 0.5}
  }
  
  {setter public {completion c:double}:void
    def scene-graphic =
        {if-non-null sc = self.scene-graphic then
            sc
         else
            def (scene, scene-graphic) = {self.make-scene}
            def quad = {self.make-partial-quad self.pixmap, 1m}
            set self.out-quad = quad
            scene-graphic
        }
    
    def out-xform = {Transformation3d}
    {out-xform.local-rotate angle = c * 180deg}
    {out-xform.local-translate 0m, 0m, 0.1mm}
    set self.out-quad.transformation = out-xform
    {if-non-null in-quad = self.in-quad then
        def in-xform = {Transformation3d}
        {in-xform.local-rotate angle = (1.0 + c) * 180deg}
        {in-xform.local-translate 0m, 0m, 0.1mm}
        set in-quad.transformation = in-xform
    }
    {scene-graphic.update-drawable}
    {self.request-draw}
  }
}

{doc-next
    {purpose
        An effect that looks like a stiff page is being turned in a book,
        revealing the new screen as the next double-page spread in the book.
    }
    {details
        The {quote spine} of the book is a vertical line in the middle
        of the screen.
        The page turn looks like a 180-degree turn of a stiff page anchored
        at that spine.
    }
}
{define-class public StiffPageTurnTransitionEffect {inherits StandardTransitionEffect}
  
  {doc-next
    {purpose
        Construct a new {docref StiffPageTurnTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
  }
  {constructor public {default
                          duration:Time = 0.5s,
                          pacing:#{proc-type {double}:double} = null
                      }
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay out-pmap:Pixmap}:TransitionOverlay
    {return {StiffPageTurnPixmap out-pmap}}
  }
}

{doc-next
    {purpose
        Calculate the distance from a point to a line in (u, v) texture space.
    }
    {parameter point,
        The coordinates of the point.
    }
    {parameter (from, to),
        The coordinates of a pair of points that determine the line.
    }
    {return-vals
        The distance from the point to the line.
        This value is positive if the point lies to the left of the line,
        viewed as going from {param from} to {param to}.
        This value is negative if the point lies to the right of the line.
    }
}
{define-proc public {texture-distance-from-line
                        point:FloatFraction2d,
                        from:FloatFraction2d,
                        to:FloatFraction2d
                    }:float
    def line-vec = to - from
    def point-vec = point - from
    {return {cross-product point-vec, line-vec} / {sqrt {dot-product line-vec, line-vec}}}
}

{doc-next
    {purpose
        Determine whether a point lies to the right of a line in (u, v) space.
    }
    {parameter point,
        The coordinates of the point.
    }
    {parameter (from, to),
        The coordinates of a pair of points that determine the line.
    }
    {return-vals
        True if the point lies to the right of the line,
        viewed as going from {param from} to {param to};
        false if the point lies to the right of the line.
    }
}
{define-proc public {texture-point-right-of-line?
                        point:FloatFraction2d,
                        from:FloatFraction2d,
                        to:FloatFraction2d
                    }:bool
    def line-vec = to - from
    def point-vec = point - from
    {return {cross-product point-vec, line-vec} < 0}
}

{doc-next
    {purpose
        An auxiliary procedure for {docref QuadSpec.xyz-to-uv} that
        expresses a vector as a linear combination of two given basis vectors.
    }
    {parameter vertex,
        The origin of the three vectors considered in this method.
    }
    {parameter (p1, p2),
        The endpoints of the two basis vectors.
        The vectors themselves are defined as
        {no-break {ctext p1 - vertex}} and {no-break {ctext p2 - vertex}}.
    }
    {parameter p,
        The endpoint of the vector that is to be expressed as a linear
        combination of the two basis vectors.
        The vector itself is defined as {no-break {ctext p - vertex}}.
    }
    {return-vals
        A pair of scalar coefficients {param c1} and {param c2}
        such that
        {no-break {ctext p - vertex == c1 * (p1 - vertex) + c2 * (p2 - vertex)}}.
    }
}
{define-proc package {xyz-weights
                         vertex:FloatDistance3d, p1:FloatDistance3d, p2:FloatDistance3d,
                         p:FloatDistance3d
                     }:(c1:float, c2:float)
    def d1 = p1 - vertex
    def d2 = p2 - vertex
    def d = p - vertex
    def det-vec = {cross-product d1, d2}
    def detsq = {dot-product det-vec, det-vec}
    def c1-vec = {cross-product d, d2}
    def c2-vec = {cross-product d1, d}
    {return
        ({dot-product c1-vec, det-vec} / detsq) asa float,
        ({dot-product c2-vec, det-vec} / detsq) asa float
    }
}

{doc-next
    {purpose
        A representation of a texture-mapped quad that may need to be
        clipped along one or more lines in (u, v) texture space.
    }
}
{define-value-class public final QuadSpec
  
  {doc-next
    {purpose
        An array of texture coordinates for a {docref PolygonSet} of type {ctext quads}.
    }
  }
  field public constant texture-coords:{Array-of FloatFraction2d}
  
  {doc-next
    {purpose
        An array of vertex coordinates for a {docref PolygonSet} of type {ctext quads}.
    }
  }
  field public constant vertex-list:{Array-of FloatDistance3d}
  
  {doc-next
    {purpose
        The index in {docref-abbr QuadSpec.texture-coords}
        and {docref-abbr QuadSpec.vertex-list} where
        the information for the quad that is described by
        this {docref QuadSpec} begins.
    }
  }
  field public constant index:int
  
  {doc-next
    {purpose
        Construct a {docref QuadSpec} object.
    }
    {parameter texture-coords,
        An array of texture coordinates for a {docref PolygonSet} of type {ctext quads}.
    }
    {parameter vertex-list,
        A corresponding array of vertex coordinates
        for a {docref PolygonSet} of type {ctext quads}.
    }
    {parameter index,
        The index in {param texture-coords} and {param vertex-list} where
        the information for the quad that is to be described by
        this {docref QuadSpec} begins.
    }
  }
  {constructor public {default
                          texture-coords:{Array-of FloatFraction2d},
                          vertex-list:{Array-of FloatDistance3d},
                          index:int
                      }
    set self.texture-coords = texture-coords
    set self.vertex-list = vertex-list
    set self.index = index
  }
  
  {doc-next
    {purpose
        Give the texture coordinates in this quad that correspond to
        the given (x, y, z) point.
    }
    {parameter xyz,
        The (x, y, z) point of interest.
    }
    {return-vals
        The (u, v) texture coordinates that would be mapped to the
        point {param xyz} in the quad specified by this {docref QuadSpec}.
    }
  }
  {method public {xyz-to-uv xyz:FloatDistance3d}:FloatFraction2d
    || This isn't completely right because it doesn't guard against the possibility
    || that two of the chosen vertices are at the same point or extremely close.
    def xyz0 = self.vertex-list[self.index]
    def xyz1 = self.vertex-list[self.index + 1]
    def xyz2 = self.vertex-list[self.index + 2]
    {assert xyz0 != xyz1}
    {assert xyz1 != xyz2}
    {assert xyz2 != xyz0}
    def (c1, c2) = {xyz-weights xyz0, xyz1, xyz2, xyz}
    def uv0 = self.texture-coords[self.index]
    def uv1 = self.texture-coords[self.index + 1]
    def uv2 = self.texture-coords[self.index + 2]
    {return
        uv0 + c1 * (uv1 - uv0) + c2 * (uv2 - uv0)
    }
  }
  
  {doc-next
    {purpose
        Auxiliary method for {docref-abbr QuadSpec.intersect-two-sides} to
        calculate the texture and vertex coordinates of the point
        where an edge should be clipped.
    }
    {parameter (i0, i1),
        The indices in {docref-abbr QuadSpec.texture-coords}
        and {docref-abbr QuadSpec.vertex-list} of the two vertices
        that define the edge to be clipped.
        It is expected that one of these vertices is on each
        side of the clipping line.
    }
    {parameter (from, to),
        The two points in texture-coordinate space that determine the
        clipping line.
        The area that lies to the right as you move from {param from} to
        {param to} is clipped out.
    }
    {return-vals
        The first return value is the texture coordinate value
        where the edge crosses the clipping line.
        The second return value is the (x, y, z) coordinate value
        where the edge crosses the clipping line.
    }
  }
  {method private {intersect-edge
                      i0:int, i1:int,
                      from:FloatFraction2d,
                      to:FloatFraction2d
                  }:(uv01:FloatFraction2d, xyz01:FloatDistance3d)
    def uv0 = self.texture-coords[i0]
    def uv1 = self.texture-coords[i1]
    def d0 = uv0 - from
    def d1 = uv1 - from
    def dto = to - from
    def cp0 = {cross-product d0, dto}
    def cp1 = {cross-product d1, dto}
    def t = -cp0 / (cp1 - cp0)
    def uv-cut = uv0 + t * (uv1 - uv0)
    def xyz0 = self.vertex-list[i0]
    def xyz1 = self.vertex-list[i1]
    def xyz-cut = xyz0 + t * (xyz1 - xyz0)
    {return uv-cut, xyz-cut}
  }
  
  {doc-next
    {purpose
        Auxiliary method for {docref-abbr QuadSpec.clip-at-texture-line} to
        generate a quad with two vertices clipped out.
    }
    {parameter (i1, i2, i3, i0),
        The indices in {docref-abbr QuadSpec.texture-coords}
        and {docref-abbr QuadSpec.vertex-list} of the vertices of the
        original quad.
        The vertices corresponding to {param i2} and {param i3}
        should be kept in the final quad,
        while the vertices corresponding to {param i0} and {param i1}
        should be clipped out.
        The values {param i0}, {param i1}, {param i2}, and {param i3}
        give the indices of vertices of the original quad in counterclockwise order.
    }
    {parameter (from, to),
        The two points in texture-coordinate space that determine the
        clipping line.
        The area that lies to the right as you move from {param from} to
        {param to} is clipped out.
    }
    {details
        This method replaces the texture and vertex
        coordinate values of the original quad, in place,
        with new coordinate values that represent the quad that
        results from the clipping operation.
    }
  }
  {method private {intersect-two-sides
                      i1:int, i2:int, i3:int, i0:int,
                      from:FloatFraction2d,
                      to:FloatFraction2d
                  }:void
    || i2 and i3 are on the right side of the line, i0 and i1 are on the wrong side.
    def (uv12, xyz12) = {self.intersect-edge i1, i2, from, to}
    def (uv03, xyz03) = {self.intersect-edge i0, i3, from, to}
    def uv2 = self.texture-coords[i2]
    def xyz2 = self.vertex-list[i2]
    def uv3 = self.texture-coords[i3]
    def xyz3 = self.vertex-list[i3]
    set self.texture-coords[self.index] = uv12
    set self.texture-coords[self.index + 1] = uv2
    set self.texture-coords[self.index + 2] = uv3
    set self.texture-coords[self.index + 3] = uv03
    set self.vertex-list[self.index] = xyz12
    set self.vertex-list[self.index + 1] = xyz2
    set self.vertex-list[self.index + 2] = xyz3
    set self.vertex-list[self.index + 3] = xyz03
  }
  
  {doc-next
    {purpose
        Auxiliary method for {docref-abbr QuadSpec.clip-at-texture-line} to
        handle the case where at least three vertices are clipped out.
    }
    {parameter (i0, i1, i2),
        The indices in {docref-abbr QuadSpec.texture-coords}
        and {docref-abbr QuadSpec.vertex-list} of the vertices that
        definitely need to be clipped out.
    }
    {parameter i3,
        The indices of a vertex that may or may not need to be clipped out.
        The values {param i0}, {param i1}, {param i2}, and {param i3}
        give the indices of vertices of the quad in counterclockwise order.
    }
    {parameter out3?,
        A boolean indicating whether the vertex at
        {param i3} will need to be clipped out.
    }
    {parameter (from, to),
        The two points in texture-coordinate space that determine the
        clipping line.
        The area that lies to the right as you move from {param from} to
        {param to} is clipped out.
    }
    {return-vals
        The index of the first slot in the texture and vertex coordinate arrays
        that does not contain information pertaining to this quad
        at the end of the clipping operation.
    }
    {details
        This method updates the texture and vertex coordinate arrays
        to contain zero or more quad specifications that together
        describe the result of the clipping operation,
        as described for the {docref-abbr QuadSpec.clip-at-texture-line}
        method.
    }
  }
  {method private {clip1
                      i3:int, out3?:bool,
                      i0:int, i1:int, i2:int,
                      from:FloatFraction2d,
                      to:FloatFraction2d
                  }:int
    {if out3? then
        || All four vertices are on the wrong side of the line, so prune the
        || quad out completely.
        {self.texture-coords.remove self.index, length = 4}
        {self.vertex-list.remove self.index, length = 4}
        {return self.index}
    }
    {self.intersect-two-sides i2, i3, i3, i0, from, to}
    {return self.index + 4}
  }
  
  {doc-next
    {purpose
        Auxiliary method for {docref-abbr QuadSpec.clip-at-texture-line} to
        handle the case where at least two vertices are clipped out.
        Note that these two vertices must always be adjacent to each other.
    }
    {parameter (i0, i1),
        The indices in {docref-abbr QuadSpec.texture-coords}
        and {docref-abbr QuadSpec.vertex-list} of the vertices that
        definitely need to be clipped out.
    }
    {parameter (i2, i3),
        The indices of vertices that may or may not need to be clipped out.
        The values {param i0}, {param i1}, {param i2}, and {param i3}
        give the indices of vertices of the quad in counterclockwise order.
    }
    {parameter (out2?, out3?),
        Booleans indicating whether the vertices at
        {param i2}, and {param i3} will need to be clipped out.
    }
    {parameter (from, to),
        The two points in texture-coordinate space that determine the
        clipping line.
        The area that lies to the right as you move from {param from} to
        {param to} is clipped out.
    }
    {return-vals
        The index of the first slot in the texture and vertex coordinate arrays
        that does not contain information pertaining to this quad
        at the end of the clipping operation.
    }
    {details
        This method updates the texture and vertex coordinate arrays
        to contain zero or more quad specifications that together
        describe the result of the clipping operation,
        as described for the {docref-abbr QuadSpec.clip-at-texture-line}
        method.
    }
  }
  {method private {clip2
                      i2:int, out2?:bool, i3:int, out3?:bool,
                      i0:int, i1:int,
                      from:FloatFraction2d,
                      to:FloatFraction2d
                  }:int
    {if out2? then
        {return {self.clip1 i3, out3?, i0, i1, i2, from, to}}
    }
    {if out3? then
        {return {self.clip1 i2, out2?, i3, i0, i1, from, to}}
    }
    || Both i2 and i3 are on the right side of the line, so compute new quad.
    {self.intersect-two-sides i1, i2, i3, i0, from, to}
    {return self.index + 4}
  }
  
  {doc-next
    {purpose
        Auxiliary method for {docref-abbr QuadSpec.clip-at-texture-line} to
        handle the case where at least one vertex is clipped out.
    }
    {parameter i0,
        The index in {docref-abbr QuadSpec.texture-coords}
        and {docref-abbr QuadSpec.vertex-list} of the vertex that
        definitely needs to be clipped out.
    }
    {parameter (i1, i2, i3),
        The indices of vertices that may or may not need to be clipped out.
        The values {param i0}, {param i1}, {param i2}, and {param i3}
        give the indices of vertices of the quad in counterclockwise order.
    }
    {parameter (out1?, out2?, out3?),
        Booleans indicating whether the vertices at
        {param i1}, {param i2}, and {param i3} will need to be clipped out.
    }
    {parameter (from, to),
        The two points in texture-coordinate space that determine the
        clipping line.
        The area that lies to the right as you move from {param from} to
        {param to} is clipped out.
    }
    {return-vals
        The index of the first slot in the texture and vertex coordinate arrays
        that does not contain information pertaining to this quad
        at the end of the clipping operation.
    }
    {details
        This method updates the texture and vertex coordinate arrays
        to contain zero or more quad specifications that together
        describe the result of the clipping operation,
        as described for the {docref-abbr QuadSpec.clip-at-texture-line}
        method.
    }
  }
  {method private {clip3
                      i1:int, out1?:bool, i2:int, out2?:bool, i3:int, out3?:bool,
                      i0:int,
                      from:FloatFraction2d,
                      to:FloatFraction2d
                  }:int
    {if out1? then
        {return {self.clip2 i2, out2?, i3, out3?, i0, i1, from, to}}
    }
    {if out3? then
        {return {self.clip2 i1, out1?, i2, out2?, i3, i0, from, to}}
    }
    {assert not out2?}
    || If one of the vertices is very close to the line, simplify things by treating it as out.
    {if {texture-distance-from-line self.texture-coords[i1], from, to} < 1e-4 then
        {return {self.clip2 i2, out2?, i3, out3?, i0, i1, from, to}}
    }
    {if {texture-distance-from-line self.texture-coords[i3], from, to} < 1e-4 then
        {return {self.clip2 i1, out1?, i2, out2?, i3, i0, from, to}}
    }
    def uv1 = self.texture-coords[i1]
    def xyz1 = self.vertex-list[i1]
    def uv2 = self.texture-coords[i2]
    def xyz2 = self.vertex-list[i2]
    def uv3 = self.texture-coords[i3]
    def xyz3 = self.vertex-list[i3]
    {self.intersect-two-sides i0, i1, i3, i0, from, to}
    {self.texture-coords.insert uv1, self.index + 4}
    {self.texture-coords.insert uv2, self.index + 5}
    {self.texture-coords.insert uv2, self.index + 6}
    {self.texture-coords.insert uv3, self.index + 7}
    {self.vertex-list.insert xyz1, self.index + 4}
    {self.vertex-list.insert xyz2, self.index + 5}
    {self.vertex-list.insert xyz2, self.index + 6}
    {self.vertex-list.insert xyz3, self.index + 7}
    {return self.index + 8}
  }
  
  {doc-next
    {purpose
        Clip this quad at the line determined by two texture coordinates.
    }
    {parameter (from, to),
        The two points in texture-coordinate space that determine the
        clipping line.
        The area that lies to the right as you move from {param from} to
        {param to} is clipped out.
    }
    {return-vals
        The index of the first slot in the texture and vertex coordinate arrays
        that does not contain information pertaining to this quad
        at the end of the clipping operation.
    }
    {details
        This method updates the texture and vertex coordinate arrays
        to contain zero or more quad specifications that together
        describe the result of the clipping operation.
        If the entire quad lies to the right of the clipping line,
        then zero quad specifications will result.
        If the entire quad lies to the left of the clipping line,
        then the originally existing quad specification will be left
        untouched.
        In other cases, the original quad specification may be modified,
        or in some cases the result of the clipping operation is a
        pentagon that needs to be represented using two quad specifications.
        
        If zero quad specifications result, then the initial quad
        information is removed from the texture and vertex coordinate
        arrays
        (with the gap being closed up so those arrays become shorter)
        and {ctext self.index} is returned as the return value.
        If one quad specification results,
        then the quad specification is modified in place if necessary,
        and {no-break {ctext self.index + 4}} is returned.
        If two quad specifications result,
        then the added quad specification is inserted into the
        texture and vertex coordinate arrays immediately after
        the original quad specification
        (which possibly will also be modified in place),
        and {no-break {ctext self.index + 8}} is returned.
    }
    {notes
        This method assumes that the quad is convex and the edges
        do not cross each other.
        
        The vertices of each quad are given by four consecutive elements
        of the {docref-abbr QuadSpec.texture-coords}
        and {docref-abbr QuadSpec.vertex-list} arrays.
        Within each group of four elements,
        the vertices of the quad appear in counterclockwise order.
    }
  }
  {method {clip-at-texture-line from:FloatFraction2d, to:FloatFraction2d}:int
    || Clips off the area that's to the right of the line that goes from "from" to "to".
    || The coordinate space of texture coordinates is such that (0, 0) corresponds to
    || the upper left corner of a texture and (1, 1) corresponds to the bottom right.
    def i0 = self.index
    def i1 = i0 + 1
    def i2 = i1 + 1
    def i3 = i2 + 1
    def out0? = {texture-point-right-of-line? self.texture-coords[i0], from, to}
    def out1? = {texture-point-right-of-line? self.texture-coords[i1], from, to}
    def out2? = {texture-point-right-of-line? self.texture-coords[i2], from, to}
    def out3? = {texture-point-right-of-line? self.texture-coords[i3], from, to}
    {if out0? then
        {return {self.clip3 i1, out1?, i2, out2?, i3, out3?, i0, from, to}}
     elseif out1? then
        {return {self.clip3 i2, out2?, i3, out3?, i0, out0?, i1, from, to}}
     elseif out2? then
        {return {self.clip3 i3, out3?, i0, out0?, i1, out1?, i2, from, to}}
     elseif out3? then
        {return {self.clip3 i0, out0?, i1, out1?, i2, out2?, i3, from, to}}
    }
    || If we fall through directly to here, then all four corners of the quad
    || are on the inside of the line and no changes are needed.
    {return i0 + 4}
  }
}

{doc-next
    {purpose
        Reflect a (u, v) texture coordinate about the line {no-break \\u = 0.5}.
    }
    {parameter uv,
        The texture coordinate to be reflected.
    }
    {return-vals
        The texture coordinate that results from the reflection operation.
    }
}
{define-proc package {urefl uv:FloatFraction2d}:FloatFraction2d
    {return
        {FloatFraction2d 1f - uv.u, uv.v}
    }
}

{define-class package PageTurn2DGeometry
  
  field constant page-width:Distance
  field constant page-height:Distance
  field constant top-y:Distance
  field constant left-x:Distance
  
  field alpha:Angle
  field d:double
  
  field texture-coords:{Array-of FloatFraction2d} = {new {Array-of FloatFraction2d}}
  field vertex-list:{Array-of FloatDistance3d} = {new {Array-of FloatDistance3d}}
  
  {constructor {default
                   page-height:Distance = 1m,
                   page-width:Distance = page-height,
                   alpha:Angle = 10deg
               }
    set self.page-height = page-height
    set self.page-width = page-width
    set self.alpha = alpha
    set self.top-y = 0.5 * page-height
    set self.left-x = -0.5 * page-width
  }
  
  {method {get-effective-alpha}:(alpha:Angle, d:double)
    let alpha:Angle = self.alpha
    let d:double = self.d
    {if d > 1.0 then
        def d-extra = d - 1.0
        def new-alpha = alpha - d-extra * 1rad
        set alpha = {max 0.00001deg, new-alpha}
        set d = 1.0
    }
    {return alpha, d}
  }
  
  {method {point-coords i:int, top?:bool}:(uv:FloatFraction2d, xyz:FloatDistance3d)
    def v = {if top? then 0f else 1f}
    {if i < 0 then
        {assert i == -1}
        || Here we should return the coordinates for the right-hand edge
        || of the not yet turned portion of the page.
        def y = {if top? then self.top-y else self.top-y - self.page-height} asa FloatDistance
        {return
            {FloatFraction2d 1f, v},
            {FloatDistance3d (self.left-x + self.page-width) asa FloatDistance, y, 0f(m)}
        }
    }
    
    def (alpha, d) = {self.get-effective-alpha}
    
    || Texture coordinates are (u, v) which fit into a unit square from 0 to 1, with v
    || increasing downward.  But the page may not be square, so for computational purposes
    || we will use "w" as a "texture coordinate" that equals u scaled by the aspect
    || ratio of the page, so w = (page-width / page-height) * u.
    
    {if i > 0 then
        {assert i == 1}
        || This case computes the position of the left-hand edge of the page,
        || which is the first part to turn.
        def (uv-top, xyz-top) = {self.point-coords i - 1, true}
        def (uv-bot, xyz-bot) = {self.point-coords i - 1, false}
        def xyz-vec = xyz-top - xyz-bot
        def plane-vec = {cross-product xyz-vec, {FloatFraction3d 0f, 0f, 1f}}
        def plane-vec-size = {sqrt {dot-product plane-vec, plane-vec}}
        def unit-plane-vec = ((self.page-height / plane-vec-size) asa float) * plane-vec
        def unit-w-vec =
            ({cos alpha} asa float) * unit-plane-vec + ({sin alpha} asa float) * xyz-vec
        def uv-nsteps = {if top? then uv-top else uv-bot}
        def dw = uv-nsteps.u * ((self.page-width / self.page-height) asa float)
        def dxyz = dw * unit-w-vec
        {return
            {FloatFraction2d 0f, v},
            {if top? then xyz-top else xyz-bot} + dxyz
        }
    }
    
    {assert i == 0}
    || Here we return the coordinates of the line where the turning page is folded over.
    def w = (self.page-width / (2.0 * self.page-height)) * d - (1.0 - v) * {tan alpha}
    def y = {if top? then self.top-y else self.top-y - self.page-height} asa FloatDistance
    def xyz = {FloatDistance3d (self.left-x + w * self.page-height) asa FloatDistance, y, 0f(m)}
    def u = (w * self.page-height / self.page-width) asa float
    
    {return
        {FloatFraction2d u, v},
        xyz
    }
  }
  
  {method {line-coords i:int
          }:(uv-top:FloatFraction2d, xyz-top:FloatDistance3d,
             uv-bottom:FloatFraction2d, xyz-bottom:FloatDistance3d
            )
    def (uv-top, xyz-top) = {self.point-coords i, true}
    def (uv-bot, xyz-bot) = {self.point-coords i, false}
    {return uv-top, xyz-top, uv-bot, xyz-bot}
  }
  
  || Auxiliary method for add-quad, below.
  {method private {trim-quad start-index:int, from:FloatFraction2d, to:FloatFraction2d}:void
    let i:int = start-index
    {while i < self.texture-coords.size do
        def qs = {QuadSpec self.texture-coords, self.vertex-list, i}
        set i = {qs.clip-at-texture-line from, to}
    }
  }
  
  {method {add-quad
              uv-top-right:FloatFraction2d, xyz-top-right:FloatDistance3d,
              uv-bot-right:FloatFraction2d, xyz-bot-right:FloatDistance3d,
              uv-top-left:FloatFraction2d, xyz-top-left:FloatDistance3d,
              uv-bot-left:FloatFraction2d, xyz-bot-left:FloatDistance3d
          }:void
    def start-index = self.texture-coords.size
    {self.texture-coords.append uv-top-left}
    {self.texture-coords.append uv-bot-left}
    {self.texture-coords.append uv-bot-right}
    {self.texture-coords.append uv-top-right}
    {self.vertex-list.append xyz-top-left}
    {self.vertex-list.append xyz-bot-left}
    {self.vertex-list.append xyz-bot-right}
    {self.vertex-list.append xyz-top-right}
    {self.trim-quad start-index, {FloatFraction2d 1f, 1f}, {FloatFraction2d 1f, 0f}}
    {self.trim-quad start-index, {FloatFraction2d 1f, 0f}, {FloatFraction2d 0f, 0f}}
    {self.trim-quad start-index, {FloatFraction2d 0f, 0f}, {FloatFraction2d 0f, 1f}}
    {self.trim-quad start-index, {FloatFraction2d 0f, 1f}, {FloatFraction2d 1f, 1f}}
  }
  
  {method {update-out-page-quads}:void
    {self.texture-coords.clear}
    {self.vertex-list.clear}
    def (uv-topm1, xyz-topm1, uv-botm1, xyz-botm1) =
        {self.line-coords -1}
    def (uv-top0, xyz-top0, uv-bot0, xyz-bot0) =
        {self.line-coords 0}
    def (uv-top1, xyz-top1, uv-bot1, xyz-bot1) =
        {self.line-coords 1}
    
    || Add the not yet turned part of the page:
    {self.add-quad uv-topm1, xyz-topm1, uv-botm1, xyz-botm1, uv-top0, xyz-top0, uv-bot0, xyz-bot0}
  }
  
  {method {update-in-page-quads}:void
    {self.texture-coords.clear}
    {self.vertex-list.clear}
    def (uv-topm1, xyz-topm1, uv-botm1, xyz-botm1) =
        {self.line-coords -1}
    def (uv-top0, xyz-top0, uv-bot0, xyz-bot0) =
        {self.line-coords 0}
    def (uv-top1, xyz-top1, uv-bot1, xyz-bot1) =
        {self.line-coords 1}
    
    def dz = {FloatDistance3d 0f(m), 0f(m), 0.5f(mm)}
    
    || Add the "turned" part of the page:
    || The following two calculations avoid creating a "bowtie" shaped
    || quad that crosses itself.
    def uv-top1a =
        {if uv-top0.u >= 0f then
            uv-top1
         else
            uv-top0
        }
    def xyz-top1a =
        {if uv-top0.u >= 0f then
            xyz-top1
         else
            xyz-top0
        }
    {self.add-quad {urefl uv-top0}, xyz-top0 + dz, {urefl uv-bot0}, xyz-bot0 + dz, {urefl uv-top1a}, xyz-top1a + dz, {urefl uv-bot1}, xyz-bot1 + dz}
    
    || Add a page below the page that is turning:
    def pw = {FloatDistance3d self.page-width asa FloatDistance, 0f(m), 0f(m)}
    {self.add-quad
        uv-topm1, xyz-topm1 - dz, uv-botm1, xyz-botm1 - dz,
        {Float2d 0f, 0f}, xyz-topm1 - pw - dz,
        {Float2d 0f, 1f}, xyz-botm1 - pw - dz
    }
  }
}

{doc-next
    {purpose
        A {docref PolygonSet} that can contain translucent material that will
        be alpha-blended with objects that it covers.
    }
}
{define-class public BlendPolygonSet {inherits PolygonSet}
  {constructor public {default ...}
    {with-compiler-directives allow-slow-spliced-arguments? = true do
        {construct-super ...}
    }
  }
  
  {method open public {paint renderer:Renderer3d, viewport-width:Distance, viewport-height:Distance}:void
    || The rendering of the objects in the BlendPolygonSet is done with renderer
    || modes that permit alpha-blending.
    {with
        renderer.blend-enabled? = true,
        renderer.blend-src-function = Blend.src-alpha,
        renderer.blend-dst-function = Blend.one-minus-src-alpha
     do
        {super.paint renderer, viewport-width, viewport-height}
    }
  }
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that implements
        an effect that looks like a stiff page is being turned in a book,
        revealing the new screen as the next double-page spread in the book.
    }
    {notes
        This class is used by {docref PageTurnTransitionEffect}.
    }
}
{define-class public PageTurnPixmap {inherits Pixmap3dTransitionOverlay}
  
  field private in-pixmap:#Pixmap = null
  
  field private out-ptg:PageTurn2DGeometry
  field private in-ptg:PageTurn2DGeometry
  
  field private constant shadow-band-pixmap-aspect-ratio:int = 6
  
  field private shadow-band-pixmap:Pixmap
  field private turn-shadow-texture-coords:{Array-of FloatFraction2d} = {new {Array-of FloatFraction2d}}
  field private turn-shadow-vertex-list:{Array-of FloatDistance3d} = {new {Array-of FloatDistance3d}}
  field private turn-shadow-pset:BlendPolygonSet
  
  field private edge-shadow-pixmap:Pixmap
  field private edge-shadow-texture-coords:{Array-of FloatFraction2d} = {new {Array-of FloatFraction2d}}
  field private edge-shadow-vertex-list:{Array-of FloatDistance3d} = {new {Array-of FloatDistance3d}}
  field private edge-shadow-pset:BlendPolygonSet
  
  {doc-next
    {purpose
        Construct an object of this type.
    }
    {notes
        See {docref Pixmap3dTransitionOverlay.default} for further information.
    }
  }
  {constructor public {default pixmap:Pixmap, alpha:Angle = 10deg}
    {construct-super pixmap}
    def aspect-ratio = pixmap.width / pixmap.height
    def (w3d, h3d, z, fill-pattern) = {self.get-3d-sizes pixmap, 1m}
    
    set self.out-ptg =
        {PageTurn2DGeometry
            page-width = w3d,
            page-height = h3d,
            alpha = alpha
        }
    set self.in-ptg =
        {PageTurn2DGeometry
            page-width = w3d,
            page-height = h3d,
            alpha = alpha
        }
    
    def shadow-band-pixmap-height = 360
    def shadow-band-pixmap-width = shadow-band-pixmap-height div self.shadow-band-pixmap-aspect-ratio
    set self.shadow-band-pixmap = {Pixmap shadow-band-pixmap-width, shadow-band-pixmap-height}
    
    set self.turn-shadow-pset =
        {BlendPolygonSet
            texture-coords = self.turn-shadow-texture-coords,
            vertices = self.turn-shadow-vertex-list,
            primitive-type = "quads"
        }
    {self.set-shadow-pixmap 0.5}
    
    set self.edge-shadow-pixmap = {self.shadow-band-pixmap.clone}
    set self.edge-shadow-pset =
        {BlendPolygonSet
            texture-coords = self.edge-shadow-texture-coords,
            vertices = self.edge-shadow-vertex-list,
            fill-pattern = self.edge-shadow-pixmap,
            primitive-type = "quads"
        }
  }
  
  {method private {set-shadow-pixmap max-alpha:double}:void
    def shadow-band-pixmap = self.shadow-band-pixmap
    def shadow-band-pixmap-width = shadow-band-pixmap.width
    def shadow-band-pixmap-height = shadow-band-pixmap.height
    {for-pixel p:Pixel at x:int, y:int no-read in shadow-band-pixmap do
        def x-side-dist = {min x, shadow-band-pixmap-width - x - 1}
        def y-side-dist = {min y, shadow-band-pixmap-height - y - 1}
        def xnorm = {min 1.0, 2.0 * x-side-dist / shadow-band-pixmap-width}
        def ynorm = {min 1.0, 2.0 * y-side-dist / shadow-band-pixmap-width}
        def dnorm = xnorm * ynorm
        def alpha = max-alpha * dnorm * dnorm * (3 - 2 * dnorm)
        set p = {Pixel.create 0, 0, 0, alpha = alpha}
    }
    set self.turn-shadow-pset.fill-pattern = shadow-band-pixmap
  }
  
  {method public {set-in-pixmap pmap:Pixmap}:void
    set self.in-pixmap = pmap
    {if self.scene-graphic == null then
        || Create the SceneGraphic if necessary.
        set self.completion = 0.0
    }
  }
  
  field private out-pset:PolygonSet = {uninitialized-value-for-type PolygonSet}
  field private in-pset:#PolygonSet = null
  
  {setter public {completion c:double}:void
    {if self.scene-graphic == null then
        def (scene, scene-graphic) = {self.make-scene}
        set self.out-pset =
            {PolygonSet
                vertices = self.out-ptg.vertex-list,
                texture-coords = self.out-ptg.texture-coords,
                fill-pattern = {FillPattern.from-pixmap self.pixmap},
                primitive-type = "quads"
            }
        {scene.add-object self.out-pset}
    }
    
    {if self.in-pset == null and self.in-pixmap != null then
        set self.in-pset =
            {PolygonSet
                vertices = self.in-ptg.vertex-list,
                texture-coords = self.in-ptg.texture-coords,
                fill-pattern = {FillPattern.from-pixmap {non-null self.in-pixmap}},
                primitive-type = "quads"
            }
        {self.scene.add-object {non-null self.in-pset}}
        {self.scene.add-object self.turn-shadow-pset}
        {self.scene.add-object self.edge-shadow-pset}
    }
    
    set self.out-ptg.d = c * (1.0 + self.out-ptg.alpha / 1radian)
    {self.out-ptg.update-out-page-quads}
    set self.in-ptg.d = self.out-ptg.d
    {self.in-ptg.update-in-page-quads}
    
    {self.turn-shadow-texture-coords.clear}
    {self.turn-shadow-vertex-list.clear}
    {self.edge-shadow-texture-coords.clear}
    {self.edge-shadow-vertex-list.clear}
    
    def ealpha = {self.out-ptg.get-effective-alpha}
    {if ealpha < self.out-ptg.alpha then
        def ratio = 1.0 - ealpha / self.out-ptg.alpha
        def new-alpha = 0.5 * (1.0 - ratio * ratio)
        {self.set-shadow-pixmap new-alpha}
    }
    
    || Make the shadow that's on top of the turning page:
    
    def top-shadow-index = self.turn-shadow-texture-coords.size
    {self.turn-shadow-texture-coords.append {FloatFraction2d 0f, 0.2f}}
    {self.turn-shadow-texture-coords.append {FloatFraction2d 0f, 0.8f}}
    {self.turn-shadow-texture-coords.append {FloatFraction2d 1f, 0.8f}}
    {self.turn-shadow-texture-coords.append {FloatFraction2d 1f, 0.2f}}
    
    || Coordinates of the line that marks the fold in the turning page:
    def (uv-top0, xyz-top0, uv-bot0, xyz-bot0) =
        {self.out-ptg.line-coords 0}
    def turn-shadow-width = self.out-ptg.page-width / 10.0
    || dw is a delta that moves to the right by the width of the shadow pattern.
    def dw = {FloatDistance3d turn-shadow-width asa FloatDistance, 0f(m), 0f(m)}
    || dd makes the shadows float just a bit closer to the camera than the page.
    def dd = {FloatDistance3d 0f(m), 0f(m), 1f(mm)}
    {self.turn-shadow-vertex-list.append xyz-top0 + dd}
    {self.turn-shadow-vertex-list.append xyz-bot0 + dd}
    {self.turn-shadow-vertex-list.append xyz-bot0 + dd + dw}
    {self.turn-shadow-vertex-list.append xyz-top0 + dd + dw}
    
    def top-shadow-quad = {QuadSpec self.turn-shadow-texture-coords, self.turn-shadow-vertex-list, top-shadow-index}
    def xyz-pbot0 = xyz-bot0
    || Coordinates of the point that marks the edge of the turning page:
    def (uv-ignoret1, xyz-ptop1, uv-ignoreb1, xyz-pbot1) = {self.out-ptg.line-coords 1}
    def uv-pbot0 = {top-shadow-quad.xyz-to-uv xyz-pbot0}
    def uv-pbot1 = {top-shadow-quad.xyz-to-uv xyz-pbot1}
    def top-shadow-end = {top-shadow-quad.clip-at-texture-line uv-pbot0, uv-pbot1}
    {if top-shadow-end > top-shadow-index then
        {assert top-shadow-end == top-shadow-index + 4}
        def uv-ptop1 = {top-shadow-quad.xyz-to-uv xyz-ptop1}
        def top-shadow-nend = {top-shadow-quad.clip-at-texture-line uv-pbot1, uv-ptop1}
    }
    
    || Make the shadow that's on the page that's being revealed:
    
    {self.turn-shadow-texture-coords.append {FloatFraction2d 0f, 0.2f}}
    {self.turn-shadow-texture-coords.append {FloatFraction2d 0f, 0.8f}}
    {self.turn-shadow-texture-coords.append {FloatFraction2d .5f, 0.8f}}
    {self.turn-shadow-texture-coords.append {FloatFraction2d .5f, 0.2f}}
    def pdw = 0.7f * dw
    {self.turn-shadow-vertex-list.append xyz-top0 + dd - pdw}
    {self.turn-shadow-vertex-list.append xyz-bot0 + dd - pdw}
    {self.turn-shadow-vertex-list.append xyz-bot0 + dd}
    {self.turn-shadow-vertex-list.append xyz-top0 + dd}
    
    || Make the shadow on the page that's being covered up:
    
    def x-pbot1 = xyz-pbot1.x
    def y-pbot1 = xyz-pbot1.y
    def alpha = {self.out-ptg.get-effective-alpha}
    def tan-alpha = {tan alpha}
    def turned-width-fraction = 1 - (1 - tan-alpha * tan-alpha) / 2
    def turned-width-bot1 = (x-pbot1 - self.out-ptg.left-x) * turned-width-fraction
    def alpha2 = 2.0 * alpha
    def dtw-dy = {tan alpha2} * turned-width-fraction
    def full-turn-width = 0.85 * turn-shadow-width
    def y-turned-top = y-pbot1 + (turned-width-bot1 - full-turn-width) / dtw-dy
    def cdw =
        {FloatDistance3d
            (turn-shadow-width * {cos alpha2}) asa FloatDistance,
            (turn-shadow-width * {sin alpha2}) asa FloatDistance,
            0f(m)
        }
    def cdh =
        {FloatDistance3d
            (turn-shadow-width * {sin alpha2}) asa FloatDistance,
            (-turn-shadow-width * {cos alpha2}) asa FloatDistance,
            0f(m)
        }
    def dz = {FloatDistance3d 0f(m), 0f(m), 0.1f(mm)}
    
    || turn-t describes the position along the edge of the turning page
    || of the boundary between the portion of the turning page that is
    || wide enough to cast a full-width shadow on the part of the page
    || that has not yet turned, and the portion of the turning page that
    || should only cast a partial-width shadow.  If turn-t >= 1, then
    || the entire turning page should cast a full-width shadow.  If
    || turn-t <= 0, then none of the turning page should cast a full-width
    || shadow.
    def turn-t = ((y-turned-top - y-pbot1) / (xyz-ptop1.y - y-pbot1)) asa float
    def xyz-turn-top =
        {if turn-t >= 1.0 then
            xyz-ptop1
         else
            xyz-pbot1 + turn-t * (xyz-ptop1 - xyz-pbot1)
        }
    {if turn-t > 0.0 then
        || Add a quad for the full-width portion of the shadow that's cast
        || toward the right of the edge of the turning page.
        {self.edge-shadow-texture-coords.append {FloatFraction2d 0.5f, 0.2f}}
        {self.edge-shadow-texture-coords.append {FloatFraction2d 0.5f, 0.8f}}
        {self.edge-shadow-texture-coords.append {FloatFraction2d 1f, 0.8f}}
        {self.edge-shadow-texture-coords.append {FloatFraction2d 1f, 0.2f}}
        {self.edge-shadow-vertex-list.append xyz-turn-top + dz}
        {self.edge-shadow-vertex-list.append xyz-pbot1 + dz}
        {self.edge-shadow-vertex-list.append xyz-pbot1 + dz + cdw}
        {self.edge-shadow-vertex-list.append xyz-turn-top + dz + cdw}
    }
    
    def y-zero-top = y-turned-top + full-turn-width / dtw-dy
    || zero-t describes the position along the edge of the turning page
    || of the top of the tapered portion of the shadow that is cast on
    || the part of the page not yet turned.  If zero-t <= 0, then no
    || shadow is cast.  If zero-t >= 1, then the top of the tapered
    || portion is above the top of the page.
    def zero-t = ((y-zero-top - y-pbot1) / (xyz-ptop1.y - y-pbot1)) asa float
    let taper-base-index:int = -1
    let taper-edge-index:int = -1
    {if turn-t < 1.0 and zero-t > 0.0 then
        def xyz-trunc-top =
            {if zero-t >= 1.0 then
                xyz-ptop1
             else
                xyz-pbot1 + zero-t * (xyz-ptop1 - xyz-pbot1)
            }
        def turned-width-trunc-top = (xyz-trunc-top.x - self.out-ptg.left-x) * turned-width-fraction
        def turned-width-trunc-ratio = {max 0.3f, (turned-width-trunc-top / full-turn-width) asa float}
        def taper-index = self.edge-shadow-texture-coords.size
        
        || Add a quad for the tapered portion of the shadow that's cast
        || toward the right of the edge of the turning page.
        {self.edge-shadow-texture-coords.append {FloatFraction2d 0.5f * (2f - turned-width-trunc-ratio), 0.2f}}
        {self.edge-shadow-texture-coords.append {FloatFraction2d 0.5f, 0.8f}}
        {self.edge-shadow-texture-coords.append {FloatFraction2d 1f, 0.8f}}
        {self.edge-shadow-texture-coords.append {FloatFraction2d 1f, 0.2f}}
        {self.edge-shadow-vertex-list.append xyz-trunc-top + dz}
        {self.edge-shadow-vertex-list.append xyz-turn-top + dz}
        {self.edge-shadow-vertex-list.append xyz-turn-top + dz + cdw}
        {self.edge-shadow-vertex-list.append xyz-trunc-top + dz + turned-width-trunc-ratio * cdw}
        
        || Now clip the tapered shadow at the bottom, if necessary.
        {if turn-t < 0.0 then
            def taper-quad = {QuadSpec self.edge-shadow-texture-coords, self.edge-shadow-vertex-list, taper-index}
            def bot-uv = {taper-quad.xyz-to-uv xyz-pbot1 + dz}
            def bot-uv-to = bot-uv + {FloatFraction2d 0.5f, 0f}
            def taper-clip-index = {taper-quad.clip-at-texture-line bot-uv, bot-uv-to}
            {assert taper-clip-index == taper-index + 4}
            || NOTE: The following calculations depend on details of the quad-clipping methods in QuadSpec.
            set taper-base-index = taper-index + 3
            set taper-edge-index = taper-index
        }
    }
    
    def taper-start-u =
        {if taper-base-index < 0 then
            0.5f
         else
            self.edge-shadow-texture-coords[taper-base-index].u
        }
    def taper-edge-xyz =
        {if taper-edge-index < 0 then
            xyz-pbot1 + dz + cdw
         else
            self.edge-shadow-vertex-list[taper-edge-index]
        }
    def taper-fraction = (1f - taper-start-u) / 0.5f
    || Add a quad for the corner of the shadow that's below and to the
    || right of the bottom right corner of the turning page.
    def v-corner-top = 1f - 0.5f / self.shadow-band-pixmap-aspect-ratio
    {self.edge-shadow-texture-coords.append {FloatFraction2d taper-start-u, v-corner-top}}
    {self.edge-shadow-texture-coords.append {FloatFraction2d taper-start-u, 1f}}
    {self.edge-shadow-texture-coords.append {FloatFraction2d 1f, 1f}}
    {self.edge-shadow-texture-coords.append {FloatFraction2d 1f, v-corner-top}}
    {self.edge-shadow-vertex-list.append xyz-pbot1 + dz}
    {self.edge-shadow-vertex-list.append xyz-pbot1 + dz + taper-fraction * cdh}
    {self.edge-shadow-vertex-list.append taper-edge-xyz + taper-fraction * cdh}
    {self.edge-shadow-vertex-list.append taper-edge-xyz}
    
    || Add a quad for the portion of the shadow that's below the bottom
    || edge of the turning page.
    {self.edge-shadow-texture-coords.append {FloatFraction2d taper-start-u, 0.2f}}
    {self.edge-shadow-texture-coords.append {FloatFraction2d taper-start-u, 0.8f}}
    {self.edge-shadow-texture-coords.append {FloatFraction2d 1f, 0.8f}}
    {self.edge-shadow-texture-coords.append {FloatFraction2d 1f, 0.2f}}
    {self.edge-shadow-vertex-list.append xyz-pbot1 + dz}
    {self.edge-shadow-vertex-list.append xyz-pbot0 + dz}
    {self.edge-shadow-vertex-list.append xyz-pbot0 + dz + taper-fraction * cdh}
    {self.edge-shadow-vertex-list.append xyz-pbot1 + dz + taper-fraction * cdh}
    
    {self.scene-graphic.update-drawable}
    {self.request-draw}
  }
}

{doc-next
    {purpose
        An effect that looks like a stiff page is being turned in a book,
        revealing the new screen as the next double-page spread in the book.
    }
    {details
        The {quote spine} of the book is a vertical line in the middle
        of the screen.
        The page turn looks like a 180-degree turn of a stiff page anchored
        at that spine.
    }
}
{define-class public PageTurnTransitionEffect {inherits StandardTransitionEffect}
  
  field private angle:Angle
  
  {doc-next
    {purpose
        Construct a new {docref PageTurnTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
  }
  {constructor public {default
                          duration:Time = 0.5s,
                          pacing:#{proc-type {double}:double} = null,
                          angle:Angle = 7degrees
                      }
    set self.angle = angle
    {construct-super duration = duration, pacing = pacing}
  }
  
  {method public {make-out-transition-overlay out-pmap:Pixmap}:TransitionOverlay
    {return {PageTurnPixmap out-pmap, alpha = self.angle}}
  }
}

{doc-next
    {purpose
        Build an array of texture coordinates for a {docref PolygonSet}
        based on the mapping specified by a {docref DisplacementMesh}.
    }
    {parameter mesh,
        The {docref DisplacementMesh} that specifies the mapping to apply.
    }
    {parameter dest,
        An array into which to write the texture coordinates.
        If this parameter is supplied, the array will first be cleared
        and then the new texture coordinates will be written into it.
        Otherwise, a new array will be allocated and filled with
        the texture coordinates.
    }
    {return-vals
        The array that contains the texture coordinates.
    }
}
{define-proc public {make-texture-coords-from-mesh
                        mesh:DisplacementMesh,
                        dest:{Array-of FloatFraction2d} = {new {Array-of FloatFraction2d}}
                    }:{Array-of FloatFraction2d}
    {dest.clear}
    def mh = mesh.height - 1
    def mw = mesh.width - 1
    {for i = 0 below mw do
        def x0 = (i / mw) asa float
        def x1 = ((i + 1) / mw) asa float
        {for j = 0 below mh do
            def y0 = (j / mh) asa float
            def y1 = ((j + 1) / mh) asa float
            {dest.append {FloatFraction2d x0, y0}}
            {dest.append {FloatFraction2d x0, y1}}
            {dest.append {FloatFraction2d x1, y1}}
            {dest.append {FloatFraction2d x1, y0}}
        }
    }
    {return dest}
}

{doc-next
    {purpose
        Build an array of vertex coordinates for a {docref PolygonSet}
        corresponding to a given a {docref DisplacementMesh}.
    }
    {parameter mesh,
        The {docref DisplacementMesh}.
        Only the width and height information from
        {param mesh} are actually used.
    }
    {parameter (x, y, z),
        The coordinates of the lower left corner of the quadrilateral
        that is displayed as the {docref PolygonSet}.
    }
    {parameter width,
        The width of the quadrilateral in the x direction.
    }
    {parameter height,
        The height of the quadrilateral in the y direction.
    }
    {parameter dest,
        An array into which to write the vertex coordinates.
        If this parameter is supplied, the array will first be cleared
        and then the new vertex coordinates will be written into it.
        Otherwise, a new array will be allocated and filled with
        the vertex coordinates.
    }
    {return-vals
        The array that contains the vertex coordinates.
    }
}
{define-proc public {make-vertex-list-from-mesh
                        mesh:DisplacementMesh,
                        x:Distance, y:Distance, z:Distance,
                        width:Distance, height:Distance,
                        dest:{Array-of FloatDistance3d} = {new {Array-of FloatDistance3d}}
                    }:{Array-of FloatDistance3d}
    {dest.clear}
    def mh = mesh.height - 1
    def mw = mesh.width - 1
    def append-vertex =
        {proc {v:Fraction2d}:void
            {dest.append
                {FloatDistance3d
                    (x + v.x * width) asa FloatDistance,
                    (y + (1.0 - v.y) * height) asa FloatDistance,
                    z asa FloatDistance
                }
            }
        }
    {for i = 0 below mw do
        {for j = 0 below mh do
            def v0 = mesh[i, j]
            def v1 = mesh[i, j + 1]
            def v2 = mesh[i + 1, j + 1]
            def v3 = mesh[i + 1, j]
            {append-vertex v0}
            {append-vertex v1}
            {append-vertex v2}
            {append-vertex v3}
        }
    }
    {return dest}
}


{doc-next
    {purpose
        Return a regular {docref DisplacementMesh} of a specified size.
    }
    {parameter (width, height),
        The width and height of the {docref DisplacementMesh} that should
        be returned.
    }
    {return-vals
        A regular {docref DisplacementMesh} having the specified width and height.
        {quote Regular} means that the {docref DisplacementMesh} maps every
        point to itself and does not specify any distortion.
    }
}
{define-proc public {make-regular-displacement-mesh width:int, height:int}:DisplacementMesh
    {return {DisplacementMesh width, height}}
}

{doc-next
    {purpose
        Make a {quote genie going into a bottle} {docref DisplacementMesh},
        similar to the Macintosh window minimization effect.
    }
    {parameter base-mesh,
        A {docref DisplacementMesh} that is cloned to serve as the starting point for
        this operation.
        Usually this would be a regular {docref DisplacementMesh} whose points are
        then warped into the {quote genie going into a bottle} shape.
        However, a different {docref DisplacementMesh} could be supplied,
        and its points will be warped according to the same transformation,
        providing a route to some variants on the basic {quote genie} shape.
    }
    {parameter strength,
        Controls the strength of the {quote pinch} in the middle of the
        {quote genie} shape.
        If {param strength} is 0, then the shape will be a triangle pointing
        downward.
        As {param strength} is increased, the sides of the triangle will
        become more concave, leading to a sharper point at the bottom of the shape.
    }
    {parameter base-x,
        The x position along the bottom of the {docref DisplacementMesh} where
        the bottom point of the genie shape is located.
        This should be a number in the range from 0 to 1.
    }
    {return-vals
        The desired {docref DisplacementMesh}.
    }
}
{define-proc public {make-genie-displacement-mesh
                        base-mesh:DisplacementMesh,
                        strength:Fraction = 0.8,
                        base-x:Fraction = 0.3
                    }:DisplacementMesh
    def genie-mesh = {base-mesh.clone}
    def width = genie-mesh.width
    def height = genie-mesh.height
    {for i = 0 below width do
        {for j = 0 below height do
            def p = base-mesh[i, j]
            def x = p.x
            def y = p.y
            let extension:double = 1.0 - y
            def esq = extension * extension
            set extension = (1.0 - strength) * extension + strength * esq
            set genie-mesh[i, j] =
                {Fraction2d
                    extension * x + (1.0 - extension) * base-x,
                    y
                }
        }
    }
    {return genie-mesh}
}

{doc-next
    {purpose
        Make a {docref DisplacementMesh} that maps all points to a
        single, specified (x, y) position.
    }
    {parameter base-mesh,
        A {docref DisplacementMesh} whose width and height control
        the width and height of the new {docref DisplacementMesh}
        that will be created.
    }
    {parameter (x, y),
        The texture coordinates to which the returned {docref DisplacementMesh}
        should map all points.
        These coordinates are within the unit square that goes from
        0 to 1.
    }
    {return-vals
        A {docref DisplacementMesh} that maps all points to the
        position given by {param x} and {param y}.
    }
}
{define-proc public {make-point-displacement-mesh
                        base-mesh:DisplacementMesh,
                        x:Fraction = 0.3,
                        y:Fraction = 1.0
                    }:DisplacementMesh
    def point-mesh = {base-mesh.clone}
    def width = point-mesh.width
    def height = point-mesh.height
    {for i = 0 below width do
        {for j = 0 below height do
            set point-mesh[i, j] = {Fraction2d x, y}
        }
    }
    {return point-mesh}
}

{doc-next
    {purpose
        Make a pincushion-shaped {docref DisplacementMesh},
        that looks like a rectangle where the middle of each side has been
        pulled in toward the center.
    }
    {parameter base-mesh,
        A {docref DisplacementMesh} that is cloned to serve as the starting point for
        this operation.
        Usually this would be a regular {docref DisplacementMesh} whose points are
        then warped into the pincushion shape.
        However, a different {docref DisplacementMesh} could be supplied,
        and its points will be warped according to the same transformation,
        providing a route to some variants on the basic pincushion shape.
    }
    {parameter strength,
        Controls the strength of the {quote pinch} in the middle of the
        sides of the pincushion shape.
        As {param strength} is increased, the sides of the rectangle
        will be more pulled-in in the center,
        leading to a more exaggerated pincushion shape.
    }
    {return-vals
        The desired {docref DisplacementMesh}.
    }
}
{define-proc public {make-pincushion-displacement-mesh
                        base-mesh:DisplacementMesh,
                        strength:Fraction = 0.65
                    }:DisplacementMesh
    def result-mesh = {base-mesh.clone}
    def width = result-mesh.width
    def height = result-mesh.height
    def center-x = 0.5
    def center-y = 0.5
    def normalizer = 2.0 * {sqrt 2.0}
    {for i = 0 below width do
        {for j = 0 below height do
            def p = base-mesh[i, j]
            def x = p.x
            def y = p.y
            def dx = x - center-x
            def dy = y - center-y
            def dsq = dx * dx + dy * dy
            def d = {sqrt dsq}
            def dnew = dsq * dsq * normalizer
            def scale = dnew / d
            set result-mesh[i, j] =
                {Fraction2d
                    center-x + scale * dx,
                    center-y + scale * dy
                }
        }
    }
    {result-mesh.interpolate-from base-mesh, strength, result-mesh}
    {return result-mesh}
}

{doc-next
    {purpose
        Compute a {docref DisplacementMesh} by Bezier interpolation using
        four specified meshes as the control points.
    }
    {parameter (a, b, c, d),
        The control points for the interpolation.
        Each point in the result mesh will be computed by applying Bezier interpolation
        to the corresponding points in
        {param a}, {param b}, {param c}, and {param d},
        using the interpolation parameter {param t}.
        All four of these meshes must have the same heights and widths.
    }
    {parameter t,
        The interpolation parameter, which should be between 0 and 1, inclusive.
        If {param t} is 0, then the result mesh will equal {param a}.
        If {param t} is 1, then the result mesh will equal {param d}.
    }
    {parameter target-mesh,
        The {docref DisplacementMesh} into which to store the result of
        the interpolation.
        This mesh must have the same height and width as the four control meshes
        {param a} through {param d}.
        If this keyword argument is not supplied, the target mesh
        is created by making a clone of {param a}.
    }
    {return-vals
        The desired {docref DisplacementMesh}.
    }
}
{define-proc public {bezier-interpolate-displacement-mesh
                        a:DisplacementMesh,
                        b:DisplacementMesh,
                        c:DisplacementMesh,
                        d:DisplacementMesh,
                        t:Fraction,
                        target-mesh:DisplacementMesh = {a.clone}
                    }:DisplacementMesh
    def width = a.width
    def height = a.height
    def tbar = 1.0 - t
    || Calculate the Bezier interpolation coefficients:
    def ca = tbar * tbar * tbar
    def cb = 3.0 * tbar * tbar * t
    def cc = 3.0 * tbar * t * t
    def cd = t * t * t
    {for i = 0 below width do
        {for j = 0 below height do
            def pa = a[i, j]
            def pb = b[i, j]
            def pc = c[i, j]
            def pd = d[i, j]
            set target-mesh[i, j] =
                {Fraction2d
                    ca * pa.x + cb * pb.x + cc * pc.x + cd * pd.x,
                    ca * pa.y + cb * pb.y + cc * pc.y + cd * pd.y
                }
        }
    }
    {return target-mesh}
}

{doc-next
    {purpose
        A {docref TransitionOverlay} that morphs the old screen through a series of
        {docref DisplacementMesh}es, revealing the new screen under the
        morphing old screen.
    }
    {notes
        This class is used by {docref BezierDisplacementTransitionEffect}.
    }
}
{define-class public BezierDisplacementPixmap {inherits Pixmap3dTransitionOverlay}
  
  field private start-mesh:DisplacementMesh
  field private t1-mesh:DisplacementMesh
  field private t2-mesh:DisplacementMesh
  field private end-mesh:DisplacementMesh
  field private temp-mesh:DisplacementMesh
  
  {doc-next
    {purpose
        Create a new {docref BezierDisplacementPixmap} object.
    }
    {parameter pixmap,
        A {docref Pixmap} that shows the initial state of the old screen
        in the transition.
    }
    {parameter (start-mesh, t1-mesh, t2-mesh, end-mesh),
        {docref DisplacementMesh}es that control how the old screen warps during
        the transition.
        See {docref BezierDisplacementTransitionEffect.default} for more information.
    }
  }
  {constructor public {default
                          pixmap:Pixmap,
                          start-mesh:DisplacementMesh,
                          t1-mesh:DisplacementMesh,
                          t2-mesh:DisplacementMesh,
                          end-mesh:DisplacementMesh
                      }
    {construct-super pixmap}
    set self.start-mesh = start-mesh
    set self.t1-mesh = t1-mesh
    set self.t2-mesh = t2-mesh
    set self.end-mesh = end-mesh
    set self.temp-mesh = {start-mesh.clone}
  }
  
  {method public {set-in-pixmap pmap:Pixmap}:void
    {if self.scene-graphic == null then
        || Create the SceneGraphic if necessary.
        set self.completion = 0.0
    }
    {self.make-partial-quad pmap, 2m}
  }
  
  {method private {make-polygon-set
                      pmap:Pixmap,
                      quad-scale:Distance
                  }:PolygonSet
    def base-mesh = self.start-mesh
    def (quad-width, quad-height, z, fill-pattern) = {self.get-3d-sizes pmap, quad-scale}
    def pset =
        {PolygonSet
            fill-pattern = {FillPattern.from-pixmap self.pixmap},
            texture-coords = {make-texture-coords-from-mesh base-mesh},
            vertices =
                {make-vertex-list-from-mesh
                    base-mesh,
                    -0.5 * quad-width, -0.5 * quad-height, 0m,
                    quad-width, quad-height
                },
            primitive-type = "quads"
        }
    {return pset}
  }
  
  field private pset:#PolygonSet = null
  
  {setter public {completion c:double}:void
    def quad-scale = 1m
    
    def scene-graphic =
        {if-non-null sc = self.scene-graphic then
            sc
         else
            def (scene, scene-graphic) = {self.make-scene}
            def pset = {self.make-polygon-set self.pixmap, quad-scale}
            set self.pset = pset
            {self.scene.add-object pset}
            scene-graphic
        }
    
    {bezier-interpolate-displacement-mesh
        self.start-mesh,
        self.t1-mesh,
        self.t2-mesh,
        self.end-mesh,
        c,
        target-mesh = self.temp-mesh
    }
    def pmap = self.pixmap
    def (quad-width, quad-height, z, fill-pattern) = {self.get-3d-sizes pmap, quad-scale}
    set self.pset.vertices =
        {make-vertex-list-from-mesh
            self.temp-mesh,
            -0.5 * quad-width, -0.5 * quad-height, 0m,
            quad-width, quad-height
        }
    {scene-graphic.update-drawable}
    {self.request-draw}
  }
}

{doc-next
    {purpose
        A transition effect that morphs the old screen through a series of
        {docref DisplacementMesh}es, revealing the new screen under the
        morphing old screen.
    }
    {usage
        This class can be used for a whole variety of transition effects
        in which the old screen is deformed in different ways but ultimately
        collapses to a point and disappears.
    }
}
{define-class public BezierDisplacementTransitionEffect {inherits StandardTransitionEffect}
  
  field private start-mesh:DisplacementMesh
  field private t1-mesh:DisplacementMesh
  field private t2-mesh:DisplacementMesh
  field private end-mesh:DisplacementMesh
  
  {doc-next
    {purpose
        Create a {docref BezierDisplacementMeshTransitionEffect} object.
    }
    {parameter duration,
        The duration of the transition effect.
        This is the value that will be returned by the {docref-abbr TransitionEffect.duration} getter
        for this object.
    }
    {parameter pacing,
        A procedure that can be used to warp the time scale of a transition.
        See {docref TransitionEffect.pacing} for additional information.
    }
    {parameter mesh-size,
        The width and height of the {docref DisplacementMesh} objects
        that will be used.
        Larger numbers for this parameter lead to smoother warping of the old screen,
        while smaller numbers may increase performance at the expense of a more angular
        look to the warping.
        After a certain mesh size is reached, however, the added improvement from
        further increases in the mesh size is very difficult to notice.
        
        The {param mesh-size} parameter is only used if no value is specified
        for the {param start-mesh} parameter.
        If a {docref DisplacementMesh} is specified for the {param start-mesh} parameter, then the
        height and width of that {docref DisplacementMesh} will govern.
    }
    {parameter start-mesh,
        A {docref DisplacementMesh} describing the initial warping of the old screen
        in the transition.
        Ordinarily the old screen should not be warped at the beginning of the transition,
        so this mesh should usually be a regular {docref DisplacementMesh}
        such as is returned by {docref make-regular-displacement-mesh}.
        If no value is explicitly specified for this argument,
        a regular {docref DisplacementMesh} with height and width equal
        to {param mesh-size} is used.
    }
    {parameter (t1-mesh, t2-mesh),
        These {docref DisplacementMesh}es specify the control points for a
        Bezier cubic curve that smoothly transitions from
        {param start-mesh} to {param end-mesh}.
        If only {param t1-mesh} is specified,
        the same {docref DisplacementMesh} is used for {param t2-mesh}.
        In this case, the shape of the old screen will warp toward{em-dash}but
        not actually reach{em-dash} this shape as it transitions from
        {param start-mesh} to {param end-mesh}.
        If different meshes are specified for {param t1-mesh} and {param t2-mesh},
        a greater degree of control over the trajectory of the animation
        is possible.
    }
    {parameter end-mesh,
        A {docref DisplacementMesh} describing the final warping of the old screen
        in the transition.
        Ordinarily the old screen should disappear at the end of the transition,
        so this mesh should usually be a {docref DisplacementMesh} that maps all
        coordinates to the same point,
        such as is returned by {docref make-point-displacement-mesh}.
        Callers may want to specify this {docref DisplacementMesh} explicitly
        to control the (x, y) coordinates of the final point into which the
        old screen vanishes.
    }
    {notes
        All four {docref DisplacementMesh}es {param start-mesh}, {param t1-mesh},
        {param t2-mesh}, and {param end-mesh}, must have the same width and height.
    }
  }
  {constructor public {default
                          duration:Time = 0.5s,
                          pacing:#{proc-type {double}:double} = null,
                          mesh-size:int = 30,
                          start-mesh:DisplacementMesh =
                              {make-regular-displacement-mesh mesh-size, mesh-size},
                          t1-mesh:DisplacementMesh =
                              {make-genie-displacement-mesh start-mesh},
                          t2-mesh:DisplacementMesh = t1-mesh,
                          end-mesh:DisplacementMesh = {make-point-displacement-mesh start-mesh}
                      }
    {construct-super duration = duration, pacing = pacing}
    set self.start-mesh = start-mesh
    set self.t1-mesh = t1-mesh
    set self.t2-mesh = t2-mesh
    set self.end-mesh = end-mesh
  }
  
  {method public {make-out-transition-overlay out-pmap:Pixmap}:TransitionOverlay
    {return
        {BezierDisplacementPixmap
            out-pmap,
            self.start-mesh,
            self.t1-mesh,
            self.t2-mesh,
            self.end-mesh
        }
    }
  }
}


{doc-next
    {purpose
        The default value of the {docref TransitionFrame.transition-effect} option.
    }
    {details
        The default transition effect for a {docref TransitionFrame},
        if none is explicitly specified,
        is {docref CrossFadeTransitionEffect}.
    }
}
{def public default-transition-effect = {CrossFadeTransitionEffect}}

{doc-next
    {purpose
        Graphical container that provides animated transitions between screens.
    }
    {details
        {ctext TransitionFrame} is a graphical container that can hold multiple child
        objects.
        At any given time, one of those objects is displayed and the others are hidden
        (although all child objects, hidden or not, affect the layout of the
        {ctext TransitionFrame}).
        New child objects can be added using the
        {docref-abbr TransitionFrame.add} method,
        while child objects can be removed using the
        {docref-abbr TransitionFrame.remove-screen} or
        {docref-abbr TransitionFrame.clear} methods.
        The currently visible child object is controlled by calling
        {docref-abbr TransitionFrame.set-active-screen}.
        The transition effect that occurs when the visible child object changes
        is controlled by the {docref-abbr TransitionFrame.transition-effect} option.
    }
}
{define-class public TransitionFrame {inherits BaseFrame, FontGraphicMixin}
  
  || A TransitionFrame object is a BaseFrame that contains an OverlayBox.
  || A pointer to this OverlayBox is stored in self.obox.
  || The OverlayBox, in turn, acts as a graphical ancestor for all of the screens
  || that have been added to the TransitionFrame.  Each screen has an index,
  || and the graphical object for the screen itself is found in self.screens[index].
  || Each screen is contained within a "screen holder" Frame, which is found in
  || self.screen-holders[index].  The screen holders, in turn, are children of
  || the OverlayBox.  The OverlayBox also has two child objects that are on top
  || of all the screens in the OverlayBox's stacking order.  The first of these
  || objects is self.out-effect-screen, and the second, which is at the very top
  || of the stacking order, is self.in-effect-screen.  Each of these is a Frame
  || that can hold a Graphic that draws an animated effect.
  ||
  || out-effect-screen is used to hold an animated effect that displays the
  || "before" screen in an animated transition.  For example, this Frame can
  || hold a version of the "before" screen that is fading out, shrinking in size,
  || or sliding out of view.  in-effect-screen is used to hold an animated effect
  || that displays the "after" screen in an animated transition.  in-effect-screen
  || is not always used.  It is only needed when the "after" screen is sliding in
  || in some way.  It is not needed if the "after" screen is just being revealed
  || in place as a result of the out-effect-screen animation, because the "after"
  || contents are already marked as visible in the OverlayBox while the animation
  || is going on.
  ||
  || When no animation is active, the visible? and enabled? options are set to false
  || on all screens except the one that is currently shown.  When a transition to a
  || new screen begins, the current appearance of the TransitionFrame is captured
  || in a Pixmap that serves as the starting state of the out-effect-screen, and
  || then the currently shown screen is made invisible and the new screen to be shown
  || is made visible.  Because the "before" appearance of the TransitionFrame has
  || already been loaded into the out-effect-screen, however, the user does not notice
  || a change immediately.  As the animation in the out-effect-screen progresses,
  || the new screen will be revealed, and at the end of the animation, the
  || out-effect-screen will be disabled so the TransitionFrame returns to its
  || quiescent state.
  ||
  || If, as discussed above, the arrival of the new screen is not just a matter of
  || being revealed, but requires some animation of the new screen contents as well,
  || then after the visible? and enabled? options are unset on the new screen
  || (allowing it to be displayed), the appearance of the new screen, without the
  || out-effect-screen overlay, will be captured into another Pixmap and an
  || animation based on that Pixmap will be installed in the in-effect-screen.
  || At the end of the transition, the in-effect-screen is disabled and finally
  || the actual new screen contents will show through.
  
  field private constant obox:OverlayBox = {OverlayBox horigin = "left", vorigin = "top"}
  field private constant screens:{Array-of Graphic} = {new {Array-of Graphic}}
  field private constant screen-holders:{Array-of Frame} = {new {Array-of Frame}}
  field private constant out-effect-screen:Frame = {Frame horigin = "left", vorigin = "top", {Fill}}
  field private constant in-effect-screen:Frame = {Frame horigin = "left", vorigin = "top", {Fill}}
  
  || The index of the currently shown screen:
  field private current-active-index:int = -1
  
  {doc-next
    {purpose
        The transition effect that will occur when changing to a new screen.
    }
  }
  {local-option public transition-effect:TransitionEffect = default-transition-effect}
  
  {doc-next
    {purpose
        This option is still experimental.
    }
  }
  {local-option public frame-rate:Frequency = 500fps}
  
  || This field is true while the TransitionFrame is initially being constructed.
  field private constructing?:bool = true
  
  {doc-next
    {purpose
        Create a new {docref TransitionFrame} object with the specified parameters.
    }
    {details
        This method accepts three kinds of arguments:
        {itemize
            {item Keyword arguments that specify options to set on
                the new {docref TransitionFrame}.
            }
            {item Graphical objects that should be added as child objects
                to the new {docref TransitionFrame}.
            }
            {item Dynamic event handler specifications that should be added
                to the new {docref TransitionFrame}.
            }
        }
        The form of these arguments is the same as for other graphical containers
        such as {docref VBox}.
    }
  }
  {constructor public {default ...}
    {self.obox.add self.out-effect-screen}
    {self.obox.add self.in-effect-screen}
    {construct-super.BaseFrame ...}
    {self.add-internal self.obox}
    set self.constructing? = false
  }
  
  {getter public {style-element}:String
    {if self._style-element == "" then
        {return "TransitionFrame"} ||""
     else
        {return self._style-element}
    }
  }
  
  {doc-next
    {purpose
        Return the numerical index that is associated with the specified {docref Graphic}.
    }
    {parameter g,
        The {docref Graphic} whose numerical index is wanted.
    }
    {return-vals
        The numerical index of {param g} in this {docref TransitionFrame}.
        If {param g} has not been added as a screen to this {docref TransitionFrame},
        then {ctext -1} is returned.
    }
  }
  {method public {index-for-screen g:Graphic}:int
    {return {self.screens.find g}}
  }
  
  {doc-next
    {purpose
        The screen that is currently displayed in this {docref TransitionFrame}.
    }
    {details
        If no screen is currently displayed in this {docref TransitionFrame},
        then this getter returns {ctext null}.
    }
    {notes
        If this getter is called during a transition, the value returned
        corresponds to the screen that will be visible at the end of the transition.
        
        Calling this setter will cause the displayed screen to change.
        The setter will throw an error if asked to display an object
        that has not been added as a screen to this {docref TransitionFrame}.
    }
  }
  {getter public {current-screen}:#Graphic
    {if self.current-active-index >= 0 then
        {return self.screens[self.current-active-index]}
    }
    {return null}
  }
  
  {setter public {current-screen g:Graphic}:void
    set self.current-screen-index = {self.index-for-screen g}
  }
  
  {doc-next
    {purpose
        The index of the screen that is currently displayed in this {docref TransitionFrame}.
    }
    {details
        If no screen is currently displayed in this {docref TransitionFrame},
        then this getter returns {ctext -1}.
    }
    {notes
        If this getter is called during a transition, the value returned
        corresponds to the screen that will be visible at the end of the transition.
        
        Calling this setter will cause the displayed screen to change.
        The setter will throw an error if given an index value that is negative
        or larger than the number of screens that have been added to this
        {docref TransitionFrame}.
    }
  }
  {getter public {current-screen-index}:int
    {return self.current-active-index}
  }
  
  {setter public {current-screen-index index:int}:void
    {if not {self.show-screen-at-index index} then
        {error "Invalid screen index"}
    }
  }
  
  {method public {add g:any, ...}:#Visual
    def gg = g asa Graphic
    def f = {Dialog gg, horigin = "left", vorigin = "top"}
    {self.obox.add f, before = self.out-effect-screen}
    {self.screens.append gg}
    {self.screen-holders.append f}
    {self.set-active-screen gg}
    {return gg}
  }
  
  {doc-next
    {purpose
        Remove a screen from this {docref TransitionFrame}.
    }
    {parameter g,
        The screen to remove.
    }
    {return-vals
        True if the removal was successful; otherwise false.
        The only reason for a false return would be if {param g}
        was not currently one of the screens in this {docref TransitionFrame}.
    }
    {notes
        If {param g} is the currently shown screen, the {docref TransitionFrame}
        will switch to displaying another screen as a side effect of removing {param g}.
        If you want to control which screen will be seen after {param g} is removed,
        switch to that screen first and then call the
        {docref-abbr TransitionFrame.remove-screen} method.
        
        If {param g} is the only screen in this {docref TransitionFrame},
        the {docref TransitionFrame} will become blank as a result of calling
        this method.  The transition to the blank state will not be animated.
    }
  }
  {method public {remove-screen g:Graphic}:bool
    {return {self.remove-screen-at-index {self.index-for-screen g}}}
  }
  
  {doc-next
    {purpose
        Remove a screen from this {docref TransitionFrame}.
    }
    {parameter index,
        The index of the screen to remove.
    }
    {return-vals
        True if the removal was successful; otherwise false.
        The only reason for a false return would be if {param index}
        is outside the current range of indices for this {docref TransitionFrame}.
    }
    {notes
        If the screen to be removed is the currently shown screen, the {docref TransitionFrame}
        will switch to displaying another screen as a side effect of the removal operation.
        If you want to control which screen will be seen after the removal,
        switch to that screen first and then call this method.
        
        If the removed screen is the only screen in this {docref TransitionFrame},
        the {docref TransitionFrame} will become blank as a result of calling
        this method.  The transition to the blank state will not be animated.
    }
  }
  {method public {remove-screen-at-index index:int}:bool
    {if index >= 0 and index < self.screens.size then
        {if index == self.current-active-index then
            {if index + 1 < self.screens.size then
                {self.show-screen-at-index index + 1}
             elseif index > 0 then
                {self.show-screen-at-index index - 1}
             else
                {if-non-null cleanup = self.clean-up-transition then
                    {cleanup}
                }
                set self.current-active-index = -1
            }
        }
        def g = self.screens[index]
        def holder = self.screen-holders[index]
        {g.detach}
        {holder.detach}
        {self.screens.remove index}
        {self.screen-holders.remove index}
        {if self.current-active-index >= index then
            {assert self.current-active-index != index}
            {dec self.current-active-index}
        }
        {return true}
     else
        {return false}
    }
  }
  
  {doc-next
    {purpose
        Remove all screens from this {docref TransitionFrame}.
    }
    {notes
        The {docref TransitionFrame} will become blank as a result of calling
        this method.  The transition to the blank state will not be animated.
    }
  }
  {method public {clear}:void
    {if-non-null cleanup = self.clean-up-transition then
        {cleanup}
    }
    set self.current-active-index = -1
    {for g in self.screens do {g.detach}}
    {for h in self.screen-holders do {h.detach}}
    {self.screens.clear}
    {self.screen-holders.clear}
  }
  
  {doc-next
    {purpose
        Render a graphic into an offscreen {docref Drawable} and {docref Pixmap}.
    }
    {parameter g,
        The graphic to render.
        This should either be the {docref TransitionFrame} itself,
        or one of the {docref Frame}s that is in this {docref TransitionFrame}'s
        {docref-abbr TransitionFrame.screen-holders} array.
    }
    {return-vals
        A {docref Pixmap} and a {docref Drawable} that contain the result of
        rendering {param g}.
        The {docref Drawable} is created first, with a size in pixels that
        equals the current size of this {docref TransitionFrame},
        and then the {docref Pixmap} is created from that.
        When these objects are no longer needed,
        the {docref Drawable} should be explicitly destroyed
        by calling {docref Drawable.destroy}.
    }
  }
  {method private {make-pixmap-from g:GetBoundsBox}:(Pixmap, Drawable)
    def self-bounds = {self.get-bounds}
    def dc = {self.get-display-context}
    def (r2d, drawable) =
        {Renderer2d.create-offscreen
            self-bounds.width,
            self-bounds.height,
            resolution = 1.0 / dc.pixel-size
        }
    def bg = {g.background.to-FillPattern}
    {r2d.render-rectangle 0m, 0m, self-bounds.width, self-bounds.height, fill-pattern = bg}
    
    def bounds = {g.get-bounds}
    def (xr, yr) = {g.get-origin-in-root}
    def pixel-size = dc.pixel-size
    def (xp, xo) = {round xr, pixel-size}
    def (yp, yo) = {round yr, pixel-size}
    {with-render-properties
        translation = {Distance2d bounds.lextent + xo, bounds.ascent + yo}
     on r2d do
        {g.draw r2d}
    }
    
    def pmap = {drawable.to-Pixmap}
    || Patch for the bug that the default black color has alpha == 0!! 
    {for-pixel p:Pixel in pmap do
        set p = {Pixel.from-uint8 p.red-as-uint8, p.green-as-uint8, p.blue-as-uint8, alpha = 255}
    }
    {return pmap, drawable}
  }
  
  || If this field is not null, then it holds a procedure that should be
  || called to clean up the state of a transition that is currently in progress,
  || including destroying the Drawables that were created for the transition.
  field private clean-up-transition:#{proc-type {early?:bool = false}:void} = null
  
  {doc-next
    {purpose
        Show a specified screen in this {docref TransitionFrame}.        
    }
    {parameter g,
        The screen to show, specified either as a {docref Graphic}
        or as the screen's numeric index.
    }
    {details
        The operation of this method is like that of
        {docref-abbr TransitionFrame.show-screen} or
        {docref-abbr TransitionFrame.show-screen-at-index},
        depending on whether a {docref Graphic} or a numeric index is specified
        for {param g}.
        If the index is out of bounds or the {docref Graphic} is not one
        of the screens in this {docref TransitionFrame},
        an error will be thrown.
    }
  }
  {method public {set-active-screen g:any}:void
    let index:int
    {type-switch g
     case i:int do
        set index = i
     case gg:Graphic do
        set index = {self.screens.find gg}
     else
        {error "Bad argument to TransitionFrame.set-active-screen"}
    }
    {if not {self.show-screen-at-index index} then
        {error "Bad argument to TransitionFrame.set-active-screen"}
    }
  }
  
  {doc-next
    {purpose
        Show a specified screen in this {docref TransitionFrame}.
    }
    {parameter g,
        The screen to show, which should already have been added to the
        {docref TransitionFrame}.
    }
    {return-vals
        True if {param g} could be shown; otherwise false.
        The only reason for a false return would be if {param g}
        was not currently one of the screens in this {docref TransitionFrame}.
    }
    {notes
        If the specified screen is the screen currently being shown,
        no transition effect will be displayed.
    }
  }
  {method public {show-screen g:Graphic}:bool
    {return {self.show-screen-at-index {self.index-for-screen g}}}
  }
  
  || Temporary tracing tool to investigate timing behavior.
  field public constant time-trace:{Array-of Time} = {new {Array-of Time}}  || *temp* RHH
  field public constant end-time-trace:{Array-of Time} = {new {Array-of Time}}  || *temp* RHH
  field public constant next-time-trace:{Array-of Time} = {new {Array-of Time}}  || *temp* RHH
  
  {doc-next
    {purpose
        Show a screen in this {docref TransitionFrame}, specified using an index.
    }
    {parameter index,
        The index of the screen to show.
    }
    {return-vals
        True if the screen could be shown; otherwise false.
        The only reason for a false return would be if {param index}
        is outside the current range of indices for this {docref TransitionFrame}.
    }
    {notes
        If the specified screen is the screen currently being shown,
        no transition effect will be displayed.
    }
  }
  {method public {show-screen-at-index index:int}:bool
    {if index < 0 or index >= self.screens.size then
        {return false}
    }
    {if index == self.current-active-index then
        {return true}
    }
    def active-index = self.current-active-index
    
    {if self.constructing? or self.display-context == null then
        || If we're still adding screens as part of the initial construction
        || of this object, or the object is not currently attached to a View,
        || skip the animations.
        {self.update-screen-visibility index}
        set self.current-active-index = index
        {return true}
    }
    
    {if-non-null cleanup = self.clean-up-transition then
        {cleanup early? = true}
    }
    
    {self.time-trace.clear}   || *temp* RHH
    {self.end-time-trace.clear}   || *temp* RHH
    {self.next-time-trace.clear}   || *temp* RHH
    def (pmap, drawable) = {self.make-pixmap-from self}
    def effect = self.transition-effect
    {effect.begin-transition}
    def out-fader = {effect.make-out-transition-overlay pmap}
    {self.out-effect-screen.add out-fader, replace? = true}
    set out-fader.completion = 0.0
    {unset self.out-effect-screen.visible?}
    
    {self.update-screen-visibility index}
    
    def new-screen = self.screen-holders[index]
    let new-screen-captured?:bool = false
    let new-screen-pmap:Pixmap = {uninitialized-value-for-type Pixmap}
    let new-screen-drawable:Drawable = {uninitialized-value-for-type Drawable}
    let in-fader:TransitionOverlay = {uninitialized-value-for-type TransitionOverlay}
    def effect-uses-in-overlay? = effect.uses-in-transition-overlay?
    def effect-needs-new-screen? = effect-uses-in-overlay? or out-fader.uses-in-pixmap?
    
    def animation-start-time = {DateTime}
    let last-update-time:Time = -1s
    def refresh-interval = 1s / 59.5
    def duration = effect.duration
    def pacing = effect.pacing
    let animation-timer:#Timer = null
    
    set self.clean-up-transition =
        {proc {early?:bool = false}:void
            set self.clean-up-transition = null
            set animation-timer.enabled? = false
            set self.out-effect-screen.visible? = false
            {if early? then
                {self.out-effect-screen.add {Fill}, replace? = true}
                {drawable.destroy}
             else
                {after 0s do
                    {self.out-effect-screen.add {Fill}, replace? = true}
                    {drawable.destroy}
                }
            }
            {if new-screen-captured? then
                set self.in-effect-screen.visible? = false
                {self.in-effect-screen.add {Fill}, replace? = true}
                {new-screen-drawable.destroy}
            }
            {effect.end-transition}
        }
    
    set animation-timer =
        {Timer
            interval = 1ms,
            {on TimerEvent do
                {if-non-null cleanup = self.clean-up-transition then
                    {if effect-needs-new-screen? and not new-screen-captured? then
                        set (new-screen-pmap, new-screen-drawable) =
                            {self.make-pixmap-from new-screen}
                        set new-screen-captured? = true
                        {if effect-uses-in-overlay? then
                            set in-fader = {effect.make-in-transition-overlay new-screen-pmap}
                            {self.in-effect-screen.add in-fader, replace? = true}
                            set in-fader.completion = 0.0
                            {unset self.in-effect-screen.visible?}
                         else
                            {assert out-fader.uses-in-pixmap?}
                            {out-fader.set-in-pixmap new-screen-pmap}
                        }
                    }
                    def etime = {animation-start-time.elapsed}
                    {if self.next-time-trace.size < self.time-trace.size then {self.next-time-trace.append etime}}  || *temp* RHH
                    {if {floor etime, refresh-interval} > {floor last-update-time, refresh-interval} then
                        set last-update-time = etime
                        {self.time-trace.append etime}  || *temp* RHH
                        {if etime < duration then
                            let completion:double = {min 1.0, etime / duration}
                            {if-non-null pacing then
                                set completion = {pacing completion}
                            }
                            set out-fader.completion = completion
                            {if effect-uses-in-overlay? then
                                set in-fader.completion = completion
                            }
                         else
                            {cleanup}
                        }
                        {self.end-time-trace.append {animation-start-time.elapsed}}  || *temp* RHH
                    }
                }
            }
        }
    
    {out-fader.add-event-handler
        {on DetachEvent do
            {if-non-null cleanup = self.clean-up-transition then
                {cleanup early? = true}
            }
        }
    }
    
    set self.current-active-index = index
    {return true}
  }
  
  || Configures the TransitionFrame so that the screen specified by index
  || is the visible screen.  This method does not touch any of the transition
  || effect screens.
  {method private {update-screen-visibility index:int}:void
    def active-index = self.current-active-index
    def new-screen = self.screen-holders[index]
    {unset new-screen.visible?}
    {unset new-screen.enabled?}
    {if active-index >= 0 then
        set self.screen-holders[active-index].visible? = false
        set self.screen-holders[active-index].enabled? = false
    }
  }
}

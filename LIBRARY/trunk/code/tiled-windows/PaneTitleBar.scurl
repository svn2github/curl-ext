{define-class package PaneTitleBar {inherits BaseFrame, PaneDragger}
  || package constants defining title bar appearance
  || (note: any values using {prefs} must be defined in constructor)
  let package constant color-focused:FillPattern = FillPattern.white
  let package constant background-focused:FillPattern= "#003366"
  let package constant background-unfocused:FillPattern= "#808080"

  field private _title:#String
  field private _visible-text:Dynamic = {Dynamic ""}
  field private _controls:Dynamic = {Dynamic ""}
  field private _min-max-restore-close-buttons:Dynamic = {Dynamic ""}

  {method package {display-focus-lost}:void
    set self.color = {prefs}["ui-background"] asa FillPattern ||""
    set self.background = PaneTitleBar.background-unfocused
  }

  {method package {display-focus-gained}:void
    set self.color = PaneTitleBar.color-focused
    set self.background = PaneTitleBar.background-focused
  }

  {constructor package {default single-pane:SinglePane}
    {construct-super.BaseFrame
        width = {add-stretch},
        margin = 1pixel,
        font-family = {prefs}["caption-font-family"] asa String, ||""
        font-weight = {prefs}["caption-font-weight"] asa FontWeight, ||""
        font-style = {prefs}["caption-font-style"] asa FontStyle, ||""
        font-size = {prefs}["caption-font-size"] ||""
    }
    {construct-super.PaneDragger single-pane}
    set self._min-max-restore-close-buttons.value =
        {self.create-buttons single-pane}
    {self.add-internal
        {HBox
            opaque-to-events? = true,
            {Fill width = 1pixel},
            {image
                source = {pane-container-image-dir.concat "curl.gif"},
                width = 16px,
                height = 16px
            },
            {Fill width = 4pixels},
            {no-break {value self._visible-text}},
            {Fill},
            self._controls,
            self._min-max-restore-close-buttons,
            valign = "center",          ||""
            horigin = "left",           ||""
            vorigin = "top"             ||""
        }
    }
  }

  {getter public open {title}:#String
    {return self._title}
  }

  {setter public open {title val:#String}:void
    {if self._title == val then
        {return}
    }
    set self._title = val
    set self._visible-text.value = self._title
  }

  {setter public open {controls controls:Graphic}:void
    set self._controls.value = controls
  }

  {setter public open {min-max-restore-close-buttons buttons:Graphic}:void
    set self._min-max-restore-close-buttons.value = buttons
  }

  {method protected {create-buttons pane:SinglePane}:Graphic
    {if not pane.show-minimize-button? and
        not pane.show-maximize-restore-button? and
        not pane.show-close-button?
     then
        {return {Fill height = 22px}}
    }
    let min-cb:#CommandButton
    {if pane.show-minimize-button? then
        set min-cb =
            {CommandButton
                takes-focus? = false,
                style = CommandButtonStyle.label-only,
                skin = null,
                focus-skin = null,
                reactive-label =
                    {ReactiveLabel
                        label =
                            {image
                                source =
                                    {pane-container-image-dir.concat
                                        "min-normal.gif" ||""
                                    },
                                blocking? = true
                            },
                        label-pressed =
                            {image
                                source =
                                    {pane-container-image-dir.concat
                                        "min-pressed.gif" ||""
                                    },
                                blocking? = true
                            }
                    },
                {on Action do
                    {popup-message "Minimize"}
                }
            }
    }
    let max-cb:#CommandButton
    {if pane.show-maximize-restore-button? then
        def max-label =
            {ReactiveLabel
                label =
                    {image
                        source =
                            {pane-container-image-dir.concat
                                "max-normal.gif" ||""
                            },
                        blocking? = true
                    },
                label-pressed =
                    {image
                        source =
                            {pane-container-image-dir.concat
                                "max-pressed.gif" ||""
                            },
                        blocking? = true
                    }
            }
        def restore-label =
            {ReactiveLabel
                label =
                    {image
                        source =
                            {pane-container-image-dir.concat
                                "restore-normal.gif" ||""
                            },
                        blocking? = true
                    },
                label-pressed =
                    {image
                        source =
                            {pane-container-image-dir.concat
                                "restore-pressed.gif" ||""
                            },
                        blocking? = true
                    }
            }
        set max-cb =
            {CommandButton
                takes-focus? = false,
                style = CommandButtonStyle.label-only,
                skin = null,
                focus-skin = null,
                reactive-label = max-label,
                {on Action do
                    {if max-cb.reactive-label == max-label then
                        set max-cb.reactive-label = restore-label
                     else
                        set max-cb.reactive-label = max-label
                    }
                    {popup-message "Maximize (TODO: Swap label for Restore)"}
                }
            }
    }
    let close-cb:#CommandButton
    {if pane.show-close-button? then
        set close-cb =
            {CommandButton
                takes-focus? = false,
                style = CommandButtonStyle.label-only,
                skin = null,
                focus-skin = null,
                reactive-label =
                    {ReactiveLabel
                        label =
                            {image
                                source =
                                    {pane-container-image-dir.concat
                                        "close-normal.gif" ||""
                                    },
                                blocking? = true
                            },
                        label-pressed =
                            {image
                                source =
                                    {pane-container-image-dir.concat
                                        "close-pressed.gif" ||""
                                    },
                                blocking? = true
                            }
                    },
                {on Action do
                    {self.single-pane.hide}
                }
            }
    }
|| TODO:
|| - Is there a less brutal way of creating these buttons?
|| - Need images for the other buttons
|| - Need to swap max/restore button label when it's clicked.
    def min-max-hbox = {HBox spacing = 0cm}
    {if-non-null min-cb then
        {min-max-hbox.add min-cb}
    }
    {if-non-null max-cb then
        {min-max-hbox.add max-cb}
    }
    def hbox = {HBox spacing = 2px}
    {if-non-null close-cb then
        {if not min-max-hbox.child-array.empty? then
            {hbox.add min-max-hbox}
            {hbox.add close-cb}
            {return hbox}
         else
            {hbox.add close-cb}
            {return hbox}
        }
     else
        {if not min-max-hbox.child-array.empty? then
            {return min-max-hbox}
         else
            {return {Fill height = 22px}}
        }
    }
  }

  {method protected final {allow-dragging? e:PointerMotion}:bool
    let drag?:bool = false

    {if-non-null layout = self.layout then
        {if {layout.bounds-valid?} then
            let bounds:GRect = {layout.get-bounds}

            set drag? = not {bounds.within? e.x, e.y}
        }
    }

    {return drag?}
  }

  {method public sealed {on-pointer-press e:PointerPress}:void 
    {if e.button == left-button and
        e.click-count == 2 
     then
        {if self.single-pane.state == PaneState.docked then
            {self.single-pane.float true}
         elseif self.single-pane.state == PaneState.dockable then
            {self.single-pane.dock}
        }
        {e.consume}
    }
    
    {super.on-pointer-press e}
  }

  {method public open {on-drag-started e:DragStarted}:void
    {self.handle-drag-started e, self}
    {super.on-drag-started e}
    {self.request-key-focus}
  }

  {method public open {on-pointer-motion e:PointerMotion}:void
    {self.handle-pointer-motion e, self}
    {super.on-pointer-motion e}
  }

  {method public open {on-pointer-release e:PointerRelease}:void
    {self.handle-pointer-release e, self}
    {super.on-pointer-release e}
  }

  {method public open {on-grab-release e:GrabRelease}:void
    {self.handle-grab-release}
    {super.on-grab-release e}
  }

  {method public open {on-key-press e:KeyPress}:void
    {self.handle-key-press e}
    {super.on-key-press e}
  }

  {method package {can-drop-on-self?}:bool
    {return false}
  }

  {method package {float-pane pane:SinglePane, dockable?:bool}:void
    {if-non-null pane.root-container then
        {pane.root-container.float-pane pane, dockable?}
    }
  }

  {method package {dock-pane 
                        pane:SinglePane,
                        state:DockingAction,
                        target-pane:#SinglePane
                    }:void
    {if-non-null pane.root-container then
        {pane.root-container.dock-pane pane, state, target-pane}
    }
  }
}

{define-class package TabDragger {inherits BaseFrame, PaneDragger}
  field private content:PaneContent
  field package tab-pane:TabPane = {uninitialized-value-for-type TabPane}

  {constructor package {default content:PaneContent}
    set self.content = content
    {construct-super.BaseFrame}
    {construct-super.PaneDragger {non-null content.single-pane}}
    {self.add-internal {TextFlowBox content.name-for-tab}}
  }


  {setter public final {title title:String}:void
    {self.add-internal replace? = true, title}
  }

  {method public final {on-context-menu-event e:ContextMenuEvent}:void 
    {self.tab-pane.tab-container.show-pane self.tab-pane}
    {super.on-context-menu-event e}
  }
    
  {method protected final {allow-dragging? e:PointerMotion}:bool
    let drag?:bool = false

    {if-non-null layout = self.layout then
        {if {layout.bounds-valid?} then
            let bounds:GRect = {layout.get-bounds}

            set drag? = not {bounds.within? e.x, e.y}
        }
    }

    {return drag?}
  }

  {method public final {on-pointer-press e:PointerPress}:void 
    {if e.button == left-button then
        || Tab pane won't cause this to happen
        {if e.click-count == 2 and 
            e.button == left-button and
            self.single-pane.state == PaneState.docked 
         then
            {e.consume}
            {self.float-pane {non-null self.content.single-pane}, true}
        }
    }
    {super.on-pointer-press e}
  }

  {method public final {on-drag-started e:DragStarted}:void
    {self.handle-drag-started e, self}
    {super.on-drag-started e}
    {self.request-key-focus}
  }

  {method public final {on-pointer-motion e:PointerMotion}:void
    {self.handle-pointer-motion e, self}
    {super.on-pointer-motion e}
  }

  {method public final {on-pointer-release e:PointerRelease}:void
    {self.handle-pointer-release e, self}
    {super.on-pointer-release e}
  }

  {method public open {on-grab-release e:GrabRelease}:void
    {self.handle-grab-release}
    {super.on-grab-release e}
  }

  {method public open {on-key-press e:KeyPress}:void
    {self.handle-key-press e}
    {super.on-key-press e}
  }

  {method package {can-drop-on-self?}:bool
    {return true}
  }

  {method package {float-pane pane:SinglePane, dockable?:bool}:void
    let pc:PaneContent = self.content
|| TODO: root-container could be null
    {pc.single-pane.root-container.float-pane-from-tab 
        pc, 
        self.tab-pane,
        dockable?
    }
  }

  {method package {dock-pane 
                        pane:SinglePane,
                        state:DockingAction,
                        target-pane:#SinglePane
                    }:void
    let old:SinglePane = {non-null self.content.single-pane}
    let new:SinglePane = {old.clone-with-new-content self.content}
|| TODO: root-container could be null
    {pane.root-container.dock-pane-from-tab
        new,
        old,
        self.tab-pane,
        state,
        target-pane
    }
  }
}

||| Copyright (C) 1998-2009, Sumisho Computer Systems Corp. All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

|| RecordSet as a DataSource

|#
    o Create RecordSetDataSource from a RecordSet (or RecordView)
    o Create RecordDataRef from a string
      o For prototype, {name=value,}*[field-name] or just field-name
      o Result can be scalar, row, or column
        o scalar: id=32[name]
        o row: id=32
        o column: status=Complete[id]
      o For future, probably can use XPath type of expression
        (could even convert to XMLNodes and use XPath!)

    o Notify observers on any change
    o Persist using CSV
#|

|| A DataRef bound to a single Record
|| Note that there is no DataSource for a single record. We have the
|| record here. This kind of ref is only used internally for binding
|| args for a RecordSet formula.
{define-class public open RecordRef {inherits DataRef}

  {doc-next
    {purpose The {docref Record} that this {docref DataRef} refers to.}
  }
  field public-get protected-set record:#Record

  {doc-next
    {purpose One or more names of fields in the current record.}
  }
  field public-get protected-set field-names:StringArray

  {doc-next
    {purpose A getter for the data source as a {docref RecordSetDataSource}.}
  }
  {getter public open {record-source}:RecordSetDataSource
    {return self.source asa RecordSetDataSource}
  }

  {doc-next
    {purpose
        A {docref DataRef} that contains one or more values from a single
        record in a {docref RecordSetDataSource}.
    }
    {parameter source, The container for this data}
    {parameter record, The specific {docref Record} containing the data}
    {parameter field-names, A string with the field name for the data
        value, or several field names separated by commas (such as
        "a,b,c").
    }
  }
  {constructor public {default
                          source:RecordSetDataSource,
                          record:#Record,
                          field-names:String
                      }
    {construct-super source}
    set self.record = record
    set self.field-names =
        {field-names.split split-chars = RecordSetDataSource.field-name-separator}
    {for fn in self.field-names do
        || Throw an error if any field names are unknown
        def f = self.record-source.record-set.fields[fn]
    }
  }

  {method public open {resolve target:DataRef}:DataRef
    {if target.source != self.source then
        {error
            {hlmessage Cannot resolve when target is in a different RecordSet.}
        }
    }
    {type-switch target
     case trsr:RecordSetRef do
        set self.record = trsr.current-record
     case trr:RecordRef do
        set self.record = trr.record
    }
    {return self}
  }

  {doc-next
    {purpose
        Return the value that this reference points to.
    }
    {details
        This type of reference can denote several fields in a single record.
        This method returns only the first value. You can call
        {docref DataRef.composite?} to find out if there are several values,
        and use {ctext self.to-Iterator} to iterate through all of them.
    }
  }
  {getter public open {value}:any
    {if-non-null r = self.record then
        {return r[self.field-names[0]]}
     else
        {return null}
    }
  }

  {setter public open {value val:any}:void
    ||FIXME: notify observers
    {if-non-null r = self.record then
        || Note that a Record will call Domain.convert for this assignment
        set r[self.field-names[0]] = val
    }
  }

  {getter public open {domain}:Domain
    {return {self.get-field 0}.domain}
  }

  {method public open {get-field i:int}:RecordField
    {return self.record-source.record-set.fields[self.field-names[i]]}
  }

  || Get the value that this reference points to as a String
  {getter public open {as-String}:String
    {return {self.domain.format self.value}}
  }

  || Get the value that this reference points to asa double
  {getter public open {as-double}:double
    {return {any-to-double self.value}}
  }

  || Return true if this object references several values
  {getter public open {composite?}:bool
    {return self.field-names.size > 1}
  }

  || If this is a composite reference, return an iterator for all of
  || the values.
  {method public open {to-Iterator}:{Iterator-of DataRef}
    {if self.record == null then
        {return DataSource.empty-iterator}
     elseif self.field-names.size > 1 then
        {return {RecordValueIterator self}}
     else
        {return {SingleIterator self}}
    }
  }
}

{doc-next
    {purpose Iterate through values in a single record.}
}
{define-class public final RecordValueIterator
  {inherits {Iterator-of DataRef}, DataRefIteratorMixin}

  {doc-next
    {purpose The record containing the values to be iterated over.}
  }
  field protected ref:RecordRef

  {doc-next
    {purpose The index of the field to be returned next.}
  }
  field protected fi:int

  {doc-next
    {purpose
        Create a new {docref RecordValueIterator} for values specified
        by {param ref}.
    }
  }
  {constructor public {default
                          ref:RecordRef
                      }
    {construct-super.{Iterator-of DataRef}}
    {construct-super.DataRefIteratorMixin}
    set self.ref = ref
    {self.reset}
  }

  {method public {reset}:void
    set self.fi = 0
  }
  
  {method public {read-one}:(v:DataRef, eof?:bool)

    || At the end?
    {if self.fi >= self.ref.field-names.size then
        {return ({uninitialized-value-for-type DataRef}, true)}
    }

    || current value
    def f = {self.ref.get-field self.fi}
    def v = self.ref.record[f.name]
    {self.set-ref v, f.domain}

    {inc self.fi, 1}
    {return (self.value-ref, false)}
  }
}


|| Reference to one or more columns in one or more records
|| Filter is defined by path of the form "a=1,b=2[d,e,f]"
{define-class public open RecordSetRef {inherits DataRef}

  {doc-next
    {purpose Specifies the records and fields to be covered by this reference.
    }
  }
  field public-get protected-set path:String

  ||FIXME: change field to field-names array
  field public-get protected-set field:String || something like "a" or "a,b,c"

  field public-get protected-set filter:RecordFilter

  || For resolving a RecordRef
  field public-get protected-set current-record-index:int
  field public-get protected-set current-records:#{Array-of Record}

  {getter public open {current-record}:#Record
    {if-non-null recs = self.current-records then
        def cri = self.current-record-index
        {if cri >= 0 and cri < recs.size then
            {return self.current-records[cri]}
        }
    }
    {return null}
  }

  {doc-next
    {purpose A getter for the data source as a {docref RecordSetDataSource}.}
  }
  {getter public open {record-source}:RecordSetDataSource
    {return self.source asa RecordSetDataSource}
  }

  {constructor public {default
                          source:RecordSetDataSource,
                          path:String
                      }
    {construct-super source}
    set self.path = path
    set (self.filter, self.field) = {self.parse-path path}
  }

  {method public open {resolve target:DataRef}:DataRef
    ||FIXME: not sure this is correct if self and target are different RecordSets
    {type-switch target
     case rr:RecordRef do
        {return
            {RecordRef rr.record-source, rr.record, self.field}
        }
     case rsr:RecordSetRef do
        {return
            {RecordRef
                rsr.record-source,
                rsr.current-record,
                self.field
            }
        }
     else
        {return self}
||--        {error {hlmessage The formula target must be a RecordSetRef or RecordRef}}
    }
  }

  ||FIXME: doesn't handle multiple fields "a,b,c"
  {method private {get-field}:RecordField
    {if self.field == "" then
        {error {hlmessage No field was specified in this RecordSetRef}}
     else
        {return self.record-source.record-set.fields[self.field]}
    }
  }

  ||FIXME: Implement a better parser
  {method private {parse-path path:String}:(filter:RecordFilter, field:String)
    let filter:RecordData = {RecordData}
    let field:String = path
    def parts = {path.split split-chars = {CharClass "[]"}}
    {if parts.size == 1 then
        || must be something like "a=3,b=2" or "a"
        {if {self.parse-filter filter, path} then
            set field = ""
        }
     else
        set field = parts[1]
        {self.parse-filter filter, parts[0]}
    }
    {return (filter asa RecordFilter, field)}
  }

  {method private {parse-filter rd:RecordData, filter-str:String}:bool
    {if {filter-str.find '='} > 0 then
        def fparts = {filter-str.split split-chars = {CharClass ", "}}
        {for fpart in fparts do
            def item = {fpart.split split-chars = {CharClass "= "}}
            set rd[item[0]] = item[1]
        }
        {return true}
     else
        {return false}
    }
  }

  || Get the value that this reference points to
  {getter public open {value}:any
    {if-non-null r = 
        {self.record-source.record-set.select-one filter = self.filter}
     then
        {if self.field == "" then
            ||FIXME: Does it make sense to return the Record?
            {return r}
         else
            {return r[self.field]}
        }
    }
    {return 0}
  }

  || Update the value that is the target of this reference
  {setter public open {value val:any}:void
    ||FIXME: notify observers
    def rf = {self.get-field} || Error if no field specified
    {if-non-null
        r = {self.record-source.record-set.select-one filter = self.filter}
     then
        set r[self.field] = 
            {type-switch val
             case s:String do
                {rf.domain.parse s}
             else
                val
            }
    }
  }

  || Get the value that this reference points to as a String
  {getter public open {as-String}:String
    def rf = {self.get-field} || Error if no field specified
    {return {rf.domain.format self.value}}
  }

  || Get the value that this reference points to asa double
  {getter public open {as-double}:double
    {return {any-to-double self.value}}
  }

  || Return true if this object references several values
  {getter public open {composite?}:bool
    {return true}
  }

  || If this is a composite reference, return an iterator for all of
  || the values.
  {method public open {to-Iterator}:{Iterator-of DataRef}
    def rv = {RecordView self.record-source.record-set, filter = self.filter}
    {return {RecordSetValueIterator rv, self.field}}
  }
}


||FIXME: perhaps the field-names should be stored in a central place
|| and passed to the iterator to save computation
{define-class public final RecordSetValueIterator
  {inherits {Iterator-of DataRef}, DataRefIteratorMixin}

  field protected rv:RecordSet
  field protected field-names:StringArray
  field protected ri:int
  field protected fi:int
  field protected records:{Array-of Record} = 
      {uninitialized-value-for-type {Array-of Record}}

  {constructor public {default
                          rv:RecordSet,
                          field-names:String
                      }
    {construct-super.{Iterator-of DataRef}}
    {construct-super.DataRefIteratorMixin}
    set self.rv = rv
    {if field-names == "" then
        set self.field-names = {StringArray}
        {for fn in self.rv.fields do
            {self.field-names.append fn.name}
        }
     else
        set self.field-names =
            {field-names.split
                split-chars = RecordSetDataSource.field-name-separator
            }
    }
    {self.reset}
  }

  {method public {reset}:void
    set self.records = {self.rv.select}
    set self.ri = 0
    set self.fi = 0
  }

  {method public {read-one}:(v:DataRef, eof?:bool)

    || At the end?
    {if self.ri >= self.records.size
        or (self.ri == self.records.size - 1
            and (self.fi >= self.field-names.size)
           )
     then
        {return ({uninitialized-value-for-type DataRef}, true)}
    }

    || current value
    def f = self.rv.fields[self.field-names[self.fi]]
    def v = self.records[self.ri][f.name]
    {self.set-ref v, f.domain}

    || Increment for next time
    {inc self.fi, 1}
    {if self.fi >= self.field-names.size then
        {inc self.ri}
        set self.fi = 0
    }
    {return (self.value-ref, false)}
  }
}

{doc-next
    {purpose
        A class to make a a {docref RecordSet} (or {docref
        RecordView}) available as a {docref DataSource}.
    }
}
{define-class public open RecordSetDataSource {inherits DataSource, CalcMixin}

  def public field-name-separator = ","

  ||FIXME: Better to call it record-source, as on other classes?
  {doc-next
    {purpose
        The {docref RecordSet} that contains the data for this
        {ctext RecordSetDataSource}.
    }
  }
  field public-get protected-set record-set:RecordSet

  {doc-next
    {purpose Create and initialize a new {docref RecordSetDataSource}.}
    {parameter record-set, The data for this data source.}
  }
  {constructor public {default
                          record-set:RecordSet
                      }
    {construct-super.DataSource}
    {construct-super.CalcMixin}
    set self.record-set = record-set
    {self.record-set.add-event-handler
        {on e:RecordsChanged do
            {self.update}
        }
    }
  }

  {method public open {get-ref
                          ...
                      }:DataRef
    let ref:#String = null
    {for (a,k) in ... do
        {if-non-null k then
            {error {hlformat "Unexpected keyword: %s", k}}
         else
            {type-switch a
             case ref-str:String do
                {if ref != null then
                    {error
                        {hlformat
                            "Unexpected extra string argument: '%s'", ref-str
                        }
                    }
                }
                set ref = ref-str
             else
                {error {hlmessage Argument must be a string.}}
            }
        }
    }
    {return {RecordSetRef self, {non-null ref}}}
  }


  {method public open {make-formula
                          target:DataRef,
                          domain:Domain,
                          formula:CalcProc,
                          ...:DataRef
                      }:Formula

    {if not target isa RecordSetRef then
        {error
            {hlmessage Target must be a RecordSetRef}
        }
    }
    || {assert target.field-names.size == 1}
    
    def f = {super.make-formula target, domain, formula, ...}
    {self.update}
    {return f}
  }

  {method protected open {handle-observer-message
                             sender:Observable,
                             message:any
                         }:void
||--    {dump sender, message, self, self._refresh-requested?}
    {self.recalc} || no notification
  }

  {method public open {refresh}:void
    {self.recalc}
    {self.notify-observers}
  }

  {method public open {recalc}:void
    ||FIXME: if args come from other recordsets, how does iteration work?
    ||FIXME: what about nested batch-events?
    {for f:Formula in self.ordered-calcs do
        {type-switch f.target
         case target-rsr:RecordSetRef do
            set target-rsr.record-source.record-set.batch-events? = true
        }
    }
    {for f:Formula in self.ordered-calcs do
        {type-switch f.target
         case target-rsr:RecordSetRef do
            def trs = target-rsr.record-source.record-set
            ||FIXME: need to stop notifications for all target rs until done!
            def records = {trs.select filter = target-rsr.filter}
            set target-rsr.current-records = records
            {for r:Record key ri in records do
                set target-rsr.current-record-index = ri
                def tref =
                    {RecordRef target-rsr.record-source, r, target-rsr.field}
                {self.eval f.formula, tref, {splice f.args}}
            }
         else
            {error "Internal error. Should validate target in make-formula."} ||""
        }
    }
    {for f:Formula in self.ordered-calcs do
        {type-switch f.target
         case target-rsr:RecordSetRef do
            set target-rsr.record-source.record-set.batch-events? = false
        }
    }
  }

}


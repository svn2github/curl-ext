||| Copyright (C) 1998-2009, Sumisho Computer Systems Corp. All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

|| RecordSet as a DataSource

|#
    o Create RecordSetDataSource from a RecordSet (or RecordView)
    o Create RecordDataRef from a string
      o For prototype, {name=value,}*[field-name] or just field-name
      o Result can be scalar, row, or column
        o scalar: id=32[name]
        o row: id=32
        o column: status=Complete[id]
      o For future, probably can use XPath type of expression
        (could even convert to XMLNodes and use XPath!)

    o Notify observers on any change
    o Persist using CSV
#|

|| A DataRef bound to a single Record
|| Note that there is no DataSource for a single record. We have the
|| record here. This kind of ref is only used internally for binding
|| args for a RecordSet formula.
{define-class package RecordRef {inherits DataRef}
  field public-get protected-set record:Record
  field public-get protected-set fields:StringArray


  || Convenience getter
  {getter public open {record-source}:RecordSetDataSource
    {return self.source asa RecordSetDataSource}
  }

  {constructor package {default
                           source:RecordSetDataSource, record:Record, field:String
                       }
    {construct-super source}
    set self.record = record
    set self.fields = {field.split split-chars = {CharClass "/"}}
  }

  {method public open {resolve target:DataRef}:DataRef
    {type-switch target
     case trsr:RecordSetRef do
        set self.record = trsr.current-records[trsr.current-record-index]
     case trr:RecordRef do
        set self.record = trr.record
    }
    {return self}
  }

  {method public open {get-value}:any
    {return self.record[self.fields[0]]}
  }

  {method public open {set-value val:any}:void
    ||FIXME: notify observers
    set self.record[self.fields[0]] = val
  }

  {method private {get-rf i:int}:RecordField
    {return self.record-source.record-set.fields[self.fields[i]]}
  }

  || Get the value that this reference points to as a String
  {method public open {get-String}:String
    def rf = {self.get-rf 0}
    {return {rf.domain.format {self.get-value}}}
  }

  || Get the value that this reference points to asa double
  {method public open {get-double}:double
    {return {any-to-double {self.get-value}}}
  }

  || Return true if this object references several values
  {getter public open {composite?}:bool
    {return self.fields.size > 1}
  }

  || If this is a composite reference, return an iterator for all of
  || the values.
  {method public open {to-Iterator}:{Iterator-of any}
    {if self.fields.size > 1 then
        {return {RecordValueIterator self}}
     else
        {return {SingleIterator self}}
    }
  }

}

|| Iterate through values in a single record
{define-class public final RecordValueIterator {inherits {Iterator-of any}}

  field protected ref:RecordRef
  field protected fi:int
  field protected fields:RecordFields

  {constructor public {default
                          ref:RecordRef
                      }
    set self.ref = ref
    set self.fields = ref.record-source.record-set.fields
    {self.reset}
  }

  {method public {reset}:void
    set self.fi = 0
  }
  
  {method public {read-one}:(v:any, eof?:bool)

    || At the end?
    {if self.fi >= self.ref.fields.size then
        {return (null, true)}
    }

    || current value
    def f = self.fields[self.ref.fields[self.fi]]
    def v = self.ref.record[f.name]

    {inc self.fi, 1}
    {return (v, false)}
  }
}


|| Reference to one or more columns in one or more records
|| Filter is defined by path of the form "a=1,b=2[d/e/f]"
{define-class public open RecordSetRef {inherits DataRef}

  field public-get protected-set path:String
  ||FIXME: change field to field-names array
  field public-get protected-set field:String || something like "a" or "a/b/c"
  field public-get protected-set filter:RecordFilter

  || For resolving a RecordRef
  field public-get protected-set current-record-index:int
  field public-get protected-set current-records:#{Array-of Record}

  || Convenience getter
  {getter public open {record-source}:RecordSetDataSource
    {return self.source asa RecordSetDataSource}
  }

  {constructor public {default
                          source:RecordSetDataSource,
                          path:String
                      }
    {construct-super source}
    set self.path = path
    set (self.filter, self.field) = {self.parse-path path}
  }

  {method public open {resolve target:DataRef}:DataRef
    ||FIXME: not sure this is correct if self and target are different RecordSets
    {type-switch target
     case rr:RecordRef do
        {return
            {RecordRef rr.record-source, rr.record, self.field}
        }
     case rsr:RecordSetRef do
        {return
            {RecordRef
                rsr.record-source, rsr.current-records[rsr.current-record-index], self.field
            }
        }
     else
        {return self}
||--        {error {hlmessage The formula target must be a RecordSetRef or RecordRef}}
    }
  }

  {method private {get-rf}:RecordField
    {if self.field == "" then
        {error {hlmessage No field was specified in this RecordSetRef}}
     else
        {return self.record-source.record-set.fields[self.field]}
    }
  }

  ||FIXME: Implement a better parser
  {method private {parse-path path:String}:(filter:RecordFilter, field:String)
    let filter:RecordData = {RecordData}
    let field:String = path
    def parts = {path.split split-chars = {CharClass "[]"}}
    {if parts.size == 1 then
        || must be something like "a=3,b=2" or "a"
        {if {self.parse-filter filter, path} then
            set field = ""
        }
     else
        set field = parts[1]
        {self.parse-filter filter, parts[0]}
    }
    {return (filter asa RecordFilter, field)}
  }

  {method private {parse-filter rd:RecordData, filter-str:String}:bool
    {if {filter-str.find '='} > 0 then
        def fparts = {filter-str.split split-chars = {CharClass ", "}}
        {for fpart in fparts do
            def item = {fpart.split split-chars = {CharClass "= "}}
            set rd[item[0]] = item[1]
        }
        {return true}
     else
        {return false}
    }
  }

  || Get the value that this reference points to
  {method public open {get-value}:any
    {if-non-null r = 
        {self.record-source.record-set.select-one filter = self.filter}
     then
        {if self.field == "" then
            ||FIXME: Does it make sense to return the Record?
            {return r}
         else
            {return r[self.field]}
        }
    }
    {return 0}
  }

  || Update the value that is the target of this reference
  {method public open {set-value val:any}:void
    ||FIXME: notify observers
    def rf = {self.get-rf} || Error if no field specified
    {if-non-null
        r = {self.record-source.record-set.select-one filter = self.filter}
     then
        set r[self.field] = 
            {type-switch val
             case s:String do
                {rf.domain.parse s}
             else
                val
            }
    }
  }

  || Get the value that this reference points to as a String
  {method public open {get-String}:String
    def rf = {self.get-rf} || Error if no field specified
    {return {rf.domain.format {self.get-value}}}
  }

  || Get the value that this reference points to asa double
  {method public open {get-double}:double
    {return {any-to-double {self.get-value}}}
  }

  || Return true if this object references several values
  {getter public open {composite?}:bool
    {return true}
  }

  || If this is a composite reference, return an iterator for all of
  || the values.
  {method public open {to-Iterator}:{Iterator-of any}
    def rv = {RecordView self.record-source.record-set, filter = self.filter}
    {return {RecordSetValueIterator rv, self.field}}
  }
}


||FIXME: perhaps the field-names should be stored in a central place
|| and passed to the iterator to save computation
{define-class public final RecordSetValueIterator {inherits {Iterator-of any}}

  field protected rv:RecordView
  field protected field-names:StringArray
  field protected ri:int
  field protected fi:int
  field protected records:{Array-of Record} = 
      {uninitialized-value-for-type {Array-of Record}}

  {constructor public {default
                          rv:RecordView,
                          field:String
                      }
    set self.rv = rv
    {if field == "" then
        set self.field-names = {StringArray}
        {for fn in self.rv.fields do
            {self.field-names.append fn.name}
        }
     else
        set self.field-names = {field.split split-chars = {CharClass "/"}}
    }
    {self.reset}
  }

  {method public {reset}:void
    set self.records = {self.rv.select}
    set self.ri = 0
    set self.fi = 0
  }

  {method public {read-one}:(v:any, eof?:bool)

    || At the end?
    {if self.ri >= self.records.size
        or (self.ri == self.records.size - 1
            and (self.fi >= self.field-names.size)
           )
     then
        {return (null, true)}
    }

    || current value
    def v = self.records[self.ri][self.field-names[self.fi]]

    || Increment for next time
    {inc self.fi, 1}
    {if self.fi >= self.field-names.size then
        {inc self.ri}
        set self.fi = 0
     else
        {inc self.ri}
    }
    {return (v, false)}
  }
}


|| DataSource bound to a RecordSet (or RecordView)
{define-class public open RecordSetDataSource {inherits DataSource, CalcMixin}

  ||FIXME: Better to call it record-source, as on other classes?
  field public-get protected-set record-set:RecordSet

  {constructor public {default
                          record-set:RecordSet
                      }
    {construct-super.DataSource}
    {construct-super.CalcMixin}
    set self.record-set = record-set
    {self.record-set.add-event-handler
        {on e:RecordsChanged do
            {self.update}
        }
    }
  }

  {method public open {get-ref
                          ...
                      }:DataRef
    let ref:#String = null
    {for (a,k) in ... do
        {if-non-null k then
            {error {hlformat "Unexpected keyword: %s", k}}
         else
            {type-switch a
             case ref-str:String do
                {if ref != null then
                    {error
                        {hlformat
                            "Unexpected extra string argument: '%s'", ref-str
                        }
                    }
                }
                set ref = ref-str
             else
                {error {hlmessage Argument must be a string.}}
            }
        }
    }
    {return {RecordSetRef self, {non-null ref}}}
  }

  {method public open {request-notification
                          ref:DataRef, obs:Observer
                      }:void
    ||FIXME: NYI request-notification
  }

  || Stop notifications for ref. If ref is null, stop all notifications to obs
  {method public open {suspend-notification
                          ref:#DataRef, obs:Observer
                      }:void
    ||FIXME: NYI
  }

  ||FIXME: (design issue) WorksheetModel has this method too, and other
  || DataSources do not. Where does it belong? The good news is that a
  || formula works no matter where you put it, so maybe this is good enough.
  || Or maybe all formulas really should be added to the WorksheetModel
  || and it would delegate to some other method here (based on the target?)
  {method public open {make-formula
                          target:DataRef,
                          domain:Domain,
                          formula:CalcProc,
                          ...:DataRef
                      }:Formula

    {if not target isa RecordSetRef then
        {error
            {hlmessage Target must be a RecordSetRef}
        }
    }
    || {assert target.field-names.size == 1}
    
    def f = {super.make-formula target, domain, formula, ...}
    {return f}
  }

  {method protected open {handle-observer-message
                             sender:Observable,
                             message:any
                         }:void
||--    {dump sender, message, self, self._refresh-requested?}
    {self.recalc} || no notification
  }

  {method public open {refresh}:void
    {self.recalc}
    {self.notify-observers}
    {if not self._refresh-requested? then
    }
  }

  ||FIXME: foreign formulas to work, need some kind of method to resolve
  || a target so that the recalc methods can all be moved to CalcMixin
  {method protected open {recalc}:void
    ||FIXME: if args come from other recordsets, how does iteration work?
    ||FIXME: what about nested batch-events?
    {for f:Formula in self.ordered-calcs do
        {type-switch f.target
         case target-rsr:RecordSetRef do
            set target-rsr.record-source.record-set.batch-events? = true
        }
    }
    {for f:Formula in self.ordered-calcs do
        {type-switch f.target
         case target-rsr:RecordSetRef do
            def trs = target-rsr.record-source.record-set
            ||FIXME: need to stop notifications for all target rs until done!
            def records = {trs.select filter = target-rsr.filter}
            set target-rsr.current-records = records
            {for r:Record key ri in records do
                set target-rsr.current-record-index = ri
                def tref =
                    {RecordRef target-rsr.record-source, r, target-rsr.field}
                {self.eval f.formula, tref, {splice f.args}}
            }
         else
            {error "Internal error. Should validate target in make-formula."} ||""
        }
    }
    {for f:Formula in self.ordered-calcs do
        {type-switch f.target
         case target-rsr:RecordSetRef do
            set target-rsr.record-source.record-set.batch-events? = false
        }
    }
  }

}


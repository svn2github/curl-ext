||| Copyright 1998-2010, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.
|||
||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.
||| ----------------------------------------------------------------------------

|| Move to CURL.EXT
{doc-next
    {purpose
        Create a JSON representation of the records in {param rs}.
    }
    {details
        ||FIXME: currently returning a JsonObject with records:<array>
        The result is a {docref JsonArray} with one {docref JsonObject}
        for each record. The {ctext JsonObject} has entries field:value
        for each field in the {ctext RecordSet}. You can use {docref
        RecordSet-from-Json} to restore the records.

        The field values are converted to strings using the {docref
        Domain.format} method.
    }
}
{define-proc public {RecordSet-to-Json rs:RecordSet}:JsonObject
    def data = {JsonObject}
    def records = {JsonArray}
    ||FIXME: get rid of surrounding object, or also store col widths...
    set data["records"] = records
    {for r in rs do
        def rdata = {JsonObject}
        {for f in rs.fields do
            set rdata[f.name] = {f.domain.format r[f.name]}
        }
        {records.append rdata}
    }
    {return data}
}

{doc-next
    {purpose Replace all of the records in {param rs} with data from
        {param records}.
    }
    {details
        Each element in the {param records} array is expected to be
        a {docref JsonObject} containing strings named by the field
        names in {param rs}. Each string value is parsed using the
        field domain.

        All records in {param rs} are deleted (and committed).
        For each record in {param records}, a new record is created
        in {param rs} with fields initialized from the next {docref
        JsonObject} in {param records}. The result is then committed to
        {param rs}.
    }
}
{define-proc public {RecordSet-from-Json rs:RecordSet, records:JsonArray}:void
    {with rs.batch-events? = true do
        {rs.delete-all}
        {rs.commit}
        {for rd in records do
            def rdo = rd asa JsonObject
            def r = {rs.new-record}
            {for f in rs.fields do
                set r[f.name] = {f.domain.parse rdo[f.name] asa String}
            }
            {rs.append r}
        }
        {rs.commit}
    }
}

|| -------------------------------------------------------------------------
|#

What's in the Model?
  o 2-D array of cell values and attributes
  o List of formulas
  o List of CellRefs
  o List of RangeRefs

What's in the UI?
  o Grid that holds four WorksheetGrids, one for each independently
    scrollable region (some are empty if there are no frozen rows/cols)
  o Row selectors and resizers at the left
  o Column selectors and resizers at the top
  o 2-D array of GridCells, which contain UI or displayed value

Worksheet Life Cycle
  - Create a model big enough to hold everything you need
  - Instantiate the data sources
  - Instantiate datarefs as needed
  - Construct the Worksheet
    - Text and visuals as needed
    - Editable cells
    - EmbeddedRecordGrid
    - EmbeddedRecordForm

How does the edit/update cycle work?
  o Steady state: all calcs have run and UI shows current values
  o User edits a cell, commits
  o Recalc everything
  o notify observers, including the UI
  o Look at every cell. If (formatted) value is different than it was,
    rebuild the cell. Same for attributes.

#|

|| --------------------------
|| Cell and Range References
|| --------------------------

||FIXME: Not yet used
{define-class package final CellRefInfo
  field public constant rc-ref?:bool
  field public constant row:int
  field public constant col:int
  field public constant abs-row?:bool
  field public constant abs-col?:bool
  field public constant rel-row?:bool
  field public constant rel-col?:bool

  {constructor package {default
                          rc-ref?:bool,
                          row:int,
                          col:int,
                          abs-row?:bool,
                          abs-col?:bool,
                          rel-row?:bool,
                          rel-col?:bool
                      }
    set self.rc-ref? = rc-ref?
    set self.row = row
    set self.col = col
    set self.abs-row? = abs-row?
    set self.abs-col? = abs-col?
    set self.rel-row? = rel-row?
    set self.rel-col? = rel-col?
  }
}

||FIXME: Not yet used
|| Parse Excel style r4c2 or r[0]c[-1]
{define-proc package {parse-rc-ref s:String}:#CellRefInfo
    let rc-ref?:bool
    let row:int
    let col:int
    let abs-row?:bool
    let abs-col?:bool
    let rel-row?:bool
    let rel-col?:bool
    let state:int = 0
    ||States: 0:start 1:[ 2:row 3:] 4:c 5:[ 6:row 7:]
    {for c:char in s do
        def uc = {char-upcase c}
        {if uc == 'R' then
            {if state == 0 then
                set state = 1
             else
                {bad-ref s}
            }
         elseif uc == '[' then

         elseif uc == ']' then

         elseif {digit? c, 10} then
            {if state == 2 or state == 3 or state == 4 then
                set state = 4
                set row = row * 10 + c - '0'
             else
            }
        }
    }
    {return null}
}

|| Helper proc to parse A1, $B$3, etc.
{define-proc package {parse-cellref s:String}:(r:int, c:int, ra?:bool, ca?:bool)
    ||FIXME: also parse a sheet ref
    ||FIXME: what about named ranges, and named sheets?
    let state:int = 0 || start => 0 $ => 1 letter => 2 $ => 3 digit => 4
    let abs-c?:bool = false
    let abs-r?:bool = false
    let col:int = 0
    let row:int = 0
    {for c:char in s do
        {if c == '$' then
            {if state == 0 then
                set abs-c? = true
                set state = 1
             elseif state == 2 then
                set abs-r? = true
                set state = 3
             else
                {bad-ref s}
            }
         elseif {digit? c, 10} then
            {if state == 2 or state == 3 or state == 4 then
                set state = 4
                set row = row * 10 + c - '0'
             else
                {bad-ref s}
            }
         elseif {CharClass.letter-chars.member? c} then
            {if state == 0 or state == 1 or state == 2 then
                set state = 2
                set col = col * 26 + {char-upcase c} - 'A'
             elseif state == 3 then
                {bad-ref s}
||--             elseif state == 4 then
||--                || Saw letter, digit. Letter again might mean r1c1 notation
||--                {return {parse-rc-ref s}}
            }
         else
            {bad-ref s}
        }
    }
    {return (row - 1, col, abs-r?, abs-c?)}
}


{doc-next
    {purpose
        Base class for cell reference or range reference in a {docref
        Worksheet}.
    }
}
{define-class abstract public open SheetRef {inherits DataRef}

  {doc-next
    {purpose The data source for this reference.}
  }
  {getter public open {worksheet}:WorksheetModel
    {return self.source asa WorksheetModel}
  }

  {doc-next
    {purpose Initialize a new {docref SheetRef}.}
    {parameter worksheet, The data source for this reference.}
  }
  {constructor public {default
                          worksheet:WorksheetModel
                      }
    {construct-super worksheet}
  }

  {doc-next
    {purpose Return true if the reference is absolute.}
  }
  {getter abstract public open {absolute?}:bool
  }

  {doc-next
    {purpose
        Adjust for {param row-count} rows added (negative means
        deleted) at {param row} and {param col-count} added/deleted
        at {param col}.
    }
  }
  {method abstract public open {adjust
                                   row:int, row-count:int,
                                   col:int, col-count:int
                               }:void
  }

  {doc-next
    {purpose
        Return true if this object references several values.
    }
  }
  {getter abstract public open {composite?}:bool
  }
}

|# About CellRefs

  - Both absolute and relative cellrefs are adjusted when rows or
    columns are inserted or deleted.a
  - The difference between "absolute" and "relative" is what
    happens when the reference is resolved to a "target" in
    CalcMixin.eval. Absolute refs are not changed. Relative
    refs are adjusted to the target.

#|


{doc-next
    {purpose A reference to a cell defined by its position relative
        to the target cell of a formula.
    }
}
{define-class public open RelativeCellRef {inherits ValueRef}
  field public-get protected-set row-offset:int
  field public-get protected-set col-offset:int
  
  {doc-next
    {purpose Initialize a new {docref RelativeCellRef}.}
    {parameter row-offset, This offset is added to the row number
        of the target cell of a formula.
    }
    {parameter col-offset, This offset is added to the column number
        of the target cell of a formula.
    }
  }
  {constructor public {default row-offset:int, col-offset:int}
    {construct-super 0}
    set self.row-offset = row-offset
    set self.col-offset = col-offset
  }

  {method public open {resolve target:DataRef}:DataRef
    {return {target.source.get-ref target, self.row-offset, self.col-offset}}
  }

}


{doc-next
    {purpose Reference to a single cell in a {docref Worksheet}.}
}
{define-class public open CellRef {inherits SheetRef}

  ||FIXME: do this in RangeRef, not CellRef
  let public constant all:int = -1

  field public-get protected-set row:int
  field public-get protected-set row-abs?:bool
  field public-get protected-set col:int
  field public-get protected-set col-abs?:bool
  field public-get protected-set all-cols?:bool = false || covers entire row
  field public-get protected-set all-rows?:bool = false || covers entire column

  || Actually, this is an easy way to construct relative refs
  || def cell-above = {CellRef -1, 0}
  || def cell-right = {CellRef 0, 1}
  {doc-next
    {purpose Initialize a {docref CellRef}.}
    {notes
        Normally a {docref CellRef} is created by calling {docref
        WorksheetModel.get-ref}, which will register the reference and
        update it if rows or columns are added or removed.
    }
    {parameter worksheet, the {docref DataSource} for this reference.}
    {parameter row, the row index, with 0 meaning the first row.}
    {parameter col, the column index, with 0 meaning the leftmost column.}
    {parameter row-abs?, if true, the row index will never be adjusted.}
    {parameter col-abs?, if true, the column index will never be adjusted.}
  }
  {constructor public {default
                          worksheet:WorksheetModel,
                          row:int, col:int,
                          row-abs?:bool = false,
                          col-abs?:bool = false,
                          all-rows?:bool = false,
                          all-cols?:bool = false
                      }
    {construct-super worksheet}
    set self.row = row
    set self.row-abs? = row-abs?
    set self.col = col
    set self.col-abs? = col-abs?
    {if all-rows? then
        ||FIXME: Better to use RangeRefs for this?
        set self.all-rows? = true
        set self.row-abs? = true || No resolution needed
    }
    {if all-cols? then
        set self.all-cols? = true
        set self.col-abs? = true || No resolution needed
    }
    {self.check-invariants}
  }

  {method private {check-invariants}:void
    ||FIXME: do we allow both all-rows? and all-cols?
    {if (self.row-abs? and self.row < 0) or (self.col-abs? and self.col < 0)
     then
        {error {hlmessage Absolute row or column value must be 0 or higher.}}
    }
  }

  {method public open {resolve target:DataRef}:DataRef
    {return self}
  }

  ||FIXME: you need to pass a row/col even if you want all-rows/cols
  || maybe better to use all keyword args? Or maybe no big deal
  {doc-next
    {purpose Initialize a {docref CellRef}.}
    {notes
        Normally a {docref CellRef} is created by calling {docref
        WorksheetModel.get-ref}, which will register the reference and
        update it if rows or columns are added or removed.
    }
    ||FIXME: more params and details
  }
  {constructor public {absolute
                          worksheet:WorksheetModel,
                          row:int,
                          col:int,
                          all-rows?:bool = false,
                          all-cols?:bool = false
                      }
    {construct-super worksheet}
    set self.row = row
    set self.row-abs? = true
    set self.col = col
    set self.col-abs? = true
    {if all-rows? then
        ||FIXME: Better to use RangeRefs for this?
        set self.all-rows? = true
    }
    {if all-cols? then
        set self.all-cols? = true
    }
    {self.check-invariants}
  }

  || This constructor is primarily for use by a GUI formula builder, which
  || will know what cell to user for reference (for relative references).
  {doc-next
    {purpose Initialize a {docref CellRef}.}
    {notes
        Normally a {docref CellRef} is created by calling {docref
        WorksheetModel.get-ref}, which will register the reference and
        update it if rows or columns are added or removed.
    }
    ||FIXME: more params and details
  }
  {constructor public {from-String
                          worksheet:WorksheetModel, s:String, ref:#CellRef
                      }
    {construct-super worksheet}
    set (self.row, self.col, self.row-abs?, self.col-abs?) = {parse-cellref s}
    {self.adjust-to-ref ref}
  }

  {method private {adjust-to-ref ref:#CellRef}:void
    {if-non-null ref then
        {assert self.worksheet == ref.worksheet}
        {if not self.row-abs? then
            set self.row = self.row - ref.row
        }
        {if not self.col-abs? then
            set self.col = self.col - ref.col
        }
    }
  }
    
  {doc-next
    {purpose Initialize a {docref CellRef}.}
    {notes
        Normally a {docref CellRef} is created by calling {docref
        WorksheetModel.get-ref}, which will register the reference and
        update it if rows or columns are added or removed.
    }
    ||FIXME: more params and details
  }
  {constructor public {relative-to
                          ref:CellRef,
                          row-offset:int, col-offset:int
                      }
    {construct-super ref.worksheet}
    set self.row = ref.row + row-offset
    set self.row-abs? = ref.row-abs?
    set self.col = ref.col + col-offset
    set self.col-abs? = ref.col-abs?
    set self.all-rows? = ref.all-rows?
    set self.row-abs? = ref.row-abs?
    set self.all-cols? = ref.all-cols?
    set self.col-abs? = ref.col-abs?
    {self.check-invariants}
  }

  || Override
  {getter public open {absolute?}:bool
    {return (self.row-abs? and self.col-abs?)
            or (self.all-cols? and self.row-abs?)
            or (self.all-rows? and self.col-abs?)
    }
  }

  || Override
  {method public open {adjust
                          row:int, row-count:int,
                          col:int, col-count:int
                      }:void
    {if row-count == 0 and col-count == 0 then
        {return}
    }
    {if not self.all-rows? then
        {if row-count < 0 then
            {if self.row >= row - row-count then
                {inc self.row, row-count}
            }
         else
            {if self.row >= row then
                {inc self.row, row-count}
            }
        }
    }
    {if not self.all-cols? then
        {if col-count < 0 then
            {if self.col >= col - col-count then
                {inc self.col, col-count}
            }
         else
            {if self.col >= col then
                {inc self.col, col-count}
            }
        }
    }
  }

  {method private {check-reference}:void
    ||FIXME: what should this do?
  }

  ||FIXME: why isn't this abstract on the base class?
  {doc-next
    {purpose
        Get the value that this reference points to.
    }
  }
  {method public open {get-value}:any
    {self.check-reference}
    {return {self.worksheet.get-value self.row, self.col}}
  }

  {doc-next
    {purpose
        Update the value that is the target of this reference.
    }
  }
  {method public open {set-value val:any}:void
    ||FIXME: notify observers
    {self.check-reference}
    {self.worksheet.set-value self.row, self.col, val}
  }

  {doc-next
    {purpose
        Get the value that this reference points to as a String.
    }
  }
  {method public open {get-String}:String
    {self.check-reference}
    def cv = self.worksheet.vals[self.row, self.col]
    {return
        {if-non-null v = {self.worksheet.get-value self.row, self.col} then
            {cv.domain.format v}
         else
            ""
        }
    }
  }

  {doc-next
    {purpose
        Get the value that this reference points to asa double.
    }
  }
  {method public open {get-double}:double
    {self.check-reference}
    {return {any-to-double {self.get-value}}}
  }

  || Override
  {getter public open {composite?}:bool
    {return false}
  }
}


{doc-next
    {purpose
        Reference to a rectangular range of cells in a {docref Worksheet}.
    }
}
{define-class public open RangeRef {inherits SheetRef}

  field public-get protected-set cell1:CellRef
  field public-get protected-set cell2:CellRef

  {doc-next
    {purpose Initialize a {docref RangeRef}.}
    {notes
        Normally a {docref CellRef} is created by calling {docref
        WorksheetModel.get-ref}, which will register the reference and
        update it if rows or columns are added or removed.
    }
    {parameter worksheet, The worksheet data that this object refers to.}
    {parameter row, The upper row of the range.}
    {parameter col, The left column of the range.}
    {parameter row2, The lower row of the range.}
    {parameter col2, The right column of the range.}
  }
  {constructor public {default
                          worksheet:WorksheetModel,
                          row:int,
                          col:int,
                          row2:int,
                          col2:int
                      }
    {construct-super worksheet}
    ||FIXME: canonicalize
    set self.cell1 = {CellRef.absolute worksheet, row, col}
    set self.cell2 = {CellRef.absolute worksheet, row2, col2}
  }

  {method public open {resolve target:DataRef}:DataRef
    {return self}
  }

  {doc-next
    {purpose Initialize a {docref RangeRef}.}
    {notes
        Normally a {docref CellRef} is created by calling {docref
        WorksheetModel.get-ref}, which will register the reference and
        update it if rows or columns are added or removed.
    }
    ||FIXME: more params and details
  }
  {constructor public {from-String
                          worksheet:WorksheetModel,
                          s:String,
                          ref:#CellRef
                      }
   
    {construct-super worksheet}
    def cells = {s.split split-chars = {CharClass ".:"}}
    {if cells.size == 3 then
        def sheet = cells[0]
        {cells.remove 0}
        ||FIXME: deal with sheet prefix
    }
    set self.cell1 = {CellRef.from-String worksheet, cells[0], ref}
    set self.cell2 = {CellRef.from-String worksheet, cells[1], ref}
  }


  || Override
  {getter public open {absolute?}:bool
    {return self.cell1.absolute? and self.cell2.absolute?}
  }

  || Override
  {method public open {adjust
                          row:int, row-count:int,
                          col:int, col-count:int
                      }:void
    ||FIXME: NYI RangeRef.adjust
  }

  {method public open {get-value}:any
    ||FIXME: Is this OK? should be error?
    {return {self.cell1.get-value}}
  }

  || Update the value that is the target of this reference
  {method public open {set-value val:any}:void
    ||FIXME: notify observers
    ||FIXME: Is this OK? should be error?
    {self.cell1.set-value val}
  }

  || Get the value that this reference points to as a String
  {method public open {get-String}:String
    ||FIXME: Is this OK? should be error?
    {return {self.cell1.get-String}}
  }

  || Get the value that this reference points to asa double
  {method public open {get-double}:double
    ||FIXME: Is this OK? should be error?
    {return {self.cell1.get-double}}
  }

  || Override
  {getter public open {composite?}:bool
    {return true}
  }

  {doc-next
    {purpose
        Return an iterator over all of the objects within the range
        specified by this reference.
    }
  }
  {method public open {to-Iterator}:{Iterator-of any}
    {return {RangeIterator self}}
  }
}


{doc-next
    {purpose
        Iterator for the cells covered by a {docref  RangeRef}.
    }
}
{define-class public final RangeIterator {inherits {Iterator-of any}}

  field private ref:RangeRef
  field private done?:bool
  field private ri:int
  field private ci:int

  {doc-next
    {purpose Initialize an iterator for the values covered by {param ref}.
    }
  }
  {constructor public {default ref:RangeRef}
    set self.ref = ref
    {self.reset}
    {assert ref.cell1.row <= ref.cell2.row and ref.cell1.col <= ref.cell2.col}
  }

  || Override
  {method public open {reset}:void
    set self.done? = false
    set self.ri = self.ref.cell1.row
    set self.ci = self.ref.cell1.col
  }

  || Override
  {method public open {read-one}:(v:any, eof?:bool)
    {if self.done? then
        {return (null, true)}
    }

    || Get the current value to return
    def nv = {self.ref.cell1.worksheet.get-value self.ri, self.ci}

    || Increment for next call
    {inc self.ci}
    {if self.ci > self.ref.cell2.col then
        set self.ci = self.ref.cell1.col
        {inc self.ri}
    }
    {if self.ri > self.ref.cell2.row then
        set self.done? = true
    }
    {return (nv, false)}
  }
}

|| ---------------------------------------------------------------------------

||FIXME: make this a public class constant?
{def package max-cols = 10000}

{define-proc package {cellref-hash-proc ref:CellRef}:int
    {assert ref.absolute?} || Can't hash relative refs
    {return {value-hash ref.row * max-cols + ref.col}}
}
{define-proc package {cellref-equal-proc a:CellRef, b:CellRef}:bool
    {return a.row == b.row and a.col == b.col}
}

||--{define-class public open WorksheetRefTable
||--
||--  field protected row-hash:{HashTable-of int, CellRef} =
||--      {new {HashTable-of int, CellRef}}
||--
||--  field protected col-hash:{HashTable-of int, CellRef} =
||--      {new {HashTable-of int, CellRef}}
||--
||--  field protected cell-hash:{HashTable-of int, CellRef} =
||--      {new {HashTable-of int, CellRef}
||--        key-hash-proc = cellref-hash-proc,
||--        key-equality-proc = cellref-equal-proc
||--      }
||--
||--  || FIXME: Doing a linear search for ranges. Need something better eventaully.
||--  field protected ranges:{Array-of RangeRef} = {new {Array-of RangeRef}}
||--
||--  {constructor public {default}
||--  }
||--
||--  || Return an interned CellRef for the cell at row,col
||--  {method public open {get-cell-ref row:int, col:int}:CellRef
||--    def (ref, found?) = {self.cell-hash.get-if-exists row * max-cols + col}
||--    {if found? then
||--        {return ref}
||--     else
||--        def ref = {CellRef.absolute row, col}
||--        set self.cell-hash[row * max-cols + col] = ref
||--        {return ref}
||--    }
||--  }
||--
||--  || Return all interned RangeRefs that overlap row,col
||--  {method public open {get-range-refs row:int, col:int}:{Array-of RangeRef}
||--  }
||--
||--  || Remove all refs
||--  {method public open {clear}:
||--  }
||--
||--  || Adjust any refs that overlap count rows at row.
||--  {method public open {adjust-rows row:int count:int}:void
||--  }
||--
||--  || Adjust any refs that overlap count columns at col.
||--  {method public open {adjust-cols col:int count:int}:void
||--  }
||--
||--  || Get ref
||--  {method public open {get-}:
||--  }
||--
||--  || 
||--  {method public open {}:
||--  }
||--
||--
||--}

|| ---------------------------------------------------------------------------

{doc-next
    {purpose When inserted in a particular cell, it specifies that
        adjacent rows or columns should be grouped together in a
        {docref GroupTree}.
    }
}
{define-value-class public final GroupProto

  {doc-next
    {purpose 
        If true, it specifies a group of rows. Otherwise, a group
        of columns.
    }
  }
  field public constant row?:bool

  {doc-next
    {purpose The number of rows or columns that are in the group.}
  }
  field public constant span:int

  {doc-next
    {purpose If true, the group is expanded and all group members
        will be visible.
    }
  }
  field public constant expanded?:bool

  {doc-next
    {purpose Create an object to specify a group of rows or columns.}
  }
  {constructor public {default
                          row?:bool,
                          span:int,
                          expanded?:bool = true
                      }
    set self.row? = row?
    set self.span = span
    set self.expanded? = expanded?
  }
}


||FIXME: GroupSpec could contain links to parent if that helps performance
{doc-next
    {purpose
        Specifies parameters for a group of rows or columns in a
        {docref GroupTree}.
    }
}
{define-class public open GroupSpec
  field public row?:bool
  field public level:int
  field public first:int
  field public last:int
  field public group-tree:#GroupTree

  field protected _expanded?:bool = true
  {doc-next
    {purpose Returns true if the group is in the expanded state.}
  }
  {getter public open {expanded?}:bool
    {return self._expanded?}
  }
  {setter public open {expanded? v:bool}:void
    set self._expanded? = v
    {if-non-null gt = self.group-tree then
        {inc gt.edit-count}
    }
  }

  {doc-next
    {purpose Initialize a {docref GroupSpec} to specify one node
        in the row or column group tree.
    }
    {details Usually row and column groups are created by calling
        {docref row-group} and {docref col-group}.
    }
    {parameter row?, If true it means that this represents a group of rows.}
    {parameter level, The depth of the group, where 0 is the root level.}
    {parameter first, The first row or column in the group.}
    {parameter last, The last row or column in the grup.}
    {parameter expanded?, If true, it means the group is in the expanded state.}
  }
  {constructor public {default
                          row?:bool, level:int, first:int, last:int,
                          expanded?:bool = true
                      }
    {if level < 0 then
        {IllegalArgumentException
            {hlmessage level must be 0 or greater.}
        }
    }
    {if first > last then
        {IllegalArgumentException
            {hlmessage The argument first must be less than or equal to last.}
        }
    }
    set self.row? = row?
    set self.level = level
    set self.first = first
    set self.last = last
    set self.expanded? = expanded?
  }

  {doc-next
    {purpose Return true if the group contains index {param n}.}
  }
  {method public open {contains? n:int}:bool
    {return (self.expanded? and n >= self.first and n <= self.last)
        or n == self.first
    }
  }

  ||FIXME: handle deletes that remove entire groups
  {method protected open {adjust
                             pos:int, count:int
                         }:void
    {if count == 0 then
        {return}
    }
    {if pos <= self.first then
        || Inserting before this group
        {inc self.first, count}
        {inc self.last, count}
     elseif pos <= self.last then
        || Inserting within this group
        {inc self.last, count}
        {assert self.last >= self.first} || Can't delete beyond end of group
        || NOTE: must remove the group first
    }
  }

  {method public open {object-describe
                          out:TextOutputStream,
                          locale:Locale
                      }:void
    {format out = out, locale = locale,
        "[GroupSpec level=%s first=%s last=%s]",
        self.level, self.first, self.last
    }
  }

}

{doc-next
    {purpose
        An array of {docref GroupSpec}
    }
}
{def GroupSpecArray = {Array-of GroupSpec}}


{doc-next
    {purpose
        Represents a hierarchy of groups of rows or columns in a
        {docref Worksheet}.
    }
}
{define-class public open GroupTree {inherits RefreshMixin}
  field protected edit-count:int = 0

  field protected levels:{Array-of GroupSpecArray} =
      {new {Array-of GroupSpecArray}}

  {doc-next
    {purpose Return the number of levels in the group tree.}
  }
  {getter public open {depth}:int
    {return self.levels.size}
  }

  {doc-next
    {purpose Create an empty {docref GroupTree}.}
  }
  {constructor public {default}
  }

||--  {method public open {validate group:GroupSpec}:bool
||--    {return true}||FIXME: NYI
||--  }

  {doc-next
    {purpose
        Return group at {param level} that includes {param i} if any,
        or null otherwise.
    }
  }
  {method public open {get-group
                          level:int, i:int, j:int
                      }:#GroupSpec
    ||FIXME: Could sort and use a binary search if performance is a problem
    {if level < self.depth then
        {for group in self.levels[level] do
            {if i >= group.first and i <= group.last then
                {if j > group.last then
                    {throw
                        {IllegalArgumentException
                            {hlmessage 
                                Upper bound not included in group that
                                contains lower bound.
                            }
                        }
                    }
                }
                {return group}
            }
        }
    }
    {return null}
  }

  {doc-next
    {purpose Insert {param group} into this group tree.}
  }
  {method public open {insert-group group:GroupSpec}:GroupSpec
    {self.update}
    set group.group-tree = self
    def missing-parent =
        {hlmessage
            There is no parent group to contain the new group.
        }
    def group-interferes =
        {hlmessage Group interferes with existing group.}

    {if group.level > self.depth then
        {error missing-parent}
     elseif self.depth == 0 then
        || The very first group
        {self.levels.append {GroupSpecArray group}}
     else
        {if group.level == self.depth then
            {self.levels.append {GroupSpecArray}}
        }
        {if group.level > 0 then
            {if {self.get-group
                    group.level - 1, group.first, group.last
                } != null
             then
                || There is a parent. Does this overlap anything at same level?
                {try
                    {if-non-null {self.get-group
                                     group.level, group.first, group.last
                                 }
                     then
                        {error group-interferes}
                    }
                 catch e:Exception do
                    {error group-interferes}
                }
             else
                {error missing-parent}
            }
        }
        def groups = self.levels[group.level]
        {for g key gi in groups do
            {if group.first <= g.first then
                {groups.insert group, gi}
                {return group}
            }
        }
        {groups.append group}
    }
    {return group}
  }

  ||FIXME: should be to-Iterator?
  {method public open {get-Iterator level:int}:{Iterator-of GroupSpec}
    {return {self.levels[level].to-Iterator}}
  }

  {doc-next
    {purpose Modify the tree to account for inserting (or deleting, if
        {param count} is negative) items.
    }
  }
  {method public open {adjust pos:int, count:int}:void
    {if count == 0 then
        {return}
    }
    {self.update}
    {for gsa in self.levels do
        {for gs in gsa do
            {if pos < gs.first then
                {inc gs.first, count}
                {inc gs.last, count}
             elseif pos > gs.last + 1 then
                || do nothing
             else
                {inc gs.last, count}
            }
        }
    }
  }


  field private last-edit-count:int
  field private index-size:int||FIXME: sync this with the model size
  field private position-map:#{Array-of int}
  field private index-map:#{Array-of int}

  {doc-next
    {purpose
        Rebuild the maps from position to index and back.
    }
  }
  {method public open {refresh}:void
    {if self.position-map == null or
        self.last-edit-count != self.edit-count
     then
        {self.make-position-map}
        {self.make-index-map}
        set self.last-edit-count = self.edit-count
    }
  }

  || Override
  {method public open {update}:void
    {super.update}
    {inc self.edit-count}
  }

  {doc-next
    {purpose Return an iterator over the visible indexes in the group tree.}
  }
  {method public open {to-Iterator}:{Iterator-of int}
    {return {GroupTreeIterator self}}
  }

  || Array such that a[index-in-model] = position-in-grid
  {method private {make-position-map}:void
    def last = self.index-size
    def map = {new {Array-of int}, efficient-size = last}
    def gti = {GroupTreeIterator self}
    let last-i:int = 0
    {for i in gti do
        {for i = last-i + 1 below i do
            {map.append -1}
            {if map.size >= last then
                {break}
            }
        }
        {if map.size < last then
            {map.append gti.count - 1}
        }
        {if map.size >= last then
            {break}
        }
        set last-i = i
    }
    set self.position-map = map
  }

  {method private {make-index-map}:void
    def last = self.index-size
    def map = {new {Array-of int}, efficient-size = last}
    def gti = {GroupTreeIterator self}
    || Map with iterator results - just the visible numbers
    {for i in gti do
        {if map.size > last then
            {break}
        }
        {map.append i}
    }
    set self.index-map = map
  }

  {doc-next
    {purpose An array that maps a position to an index.}
  }
  {method public open {get-position-map last:int}:{Array-of int}
    {if self.index-size < last then
        set self.index-size = last
        {self.update}
    }
    {self.refresh}
    {return {non-null self.position-map}}
  }

  {doc-next
    {purpose
        Return an array that maps a position to the corresponding index.
    }
    {details
        If no groups are collapsed, the mapping is the identity
        (position and index are the same). If there is one group of
        three starting at 0 ({ctext {GroupSpec 0,3}}) and collapsed,
        then the resulting array is (0, 3, 4). This means that
        position 0 corresponds to index 0, position 1 to index 3
        (because two items are hidden), and position 2 corresponds to
        index 4.
    }
  }
  {method public open {get-index-map last:int}:{Array-of int}
    {if self.index-size < last then
        set self.index-size = last
        {self.update}
    }
    {self.refresh}
    {return {non-null self.index-map}}
  }

  {method public open {map-position-to-index pos:int}:int
    {if self.index-size <= pos then
        set self.index-size = pos + 1
        {self.update}
    }
    {self.refresh}
    {return self.index-map[pos]}
  }

  {method public open {map-index-to-position i:int}:int
    {if self.index-size <= i then
        set self.index-size = i + 1
        {self.update}
    }
    {self.refresh}
    {return self.position-map[i]}
  }

  {method public open {visible? index:int}:bool
    {return {self.map-index-to-position index} >= 0}
  }

  {method public open {visible-position i:int, below?:bool = false}:int
    {while not {self.visible? i} do
        {if below? then
            {dec i}
         else
            {inc i}
        }
        {if i < 0 or i >= self.index-size then
            {return -1}
        }
    }
    {return {self.map-index-to-position i}}
  }

}


{doc-next
    {purpose
        Iterator for visible index values in a {docref GroupTree}.
    }
}
{define-class public open GroupTreeIterator {inherits {Iterator-of int}}
  field protected tree:GroupTree
  field protected done?:bool
  field protected next:int
  field protected level:int
  field protected group:#GroupSpec
  field public-get protected-set last:int

  field public-get protected-set count:int

  field public-get protected-set skipped:int
  field public-get protected-set current:int

  {doc-next
    {purpose Initialize an iterator over the visible indices of
        {param tree}.
    }
  }
  {constructor public {default
                          tree:GroupTree,
                          last:int = -1
                      }
    set self.tree = tree
    set self.last = last
    {self.reset}
  }

  {method public open {reset}:void
    set self.done? = false
    set self.next = 0
    set self.group = null
    set self.level = 0
    set self.count = 0
    set self.current = 0
  }
  
  || Find the innermost group containing self.next
  {method private {find-current-group}:#GroupSpec
    let group:#GroupSpec = null
    {for level = 0 below self.tree.depth do
        {if-non-null g =
            {self.tree.get-group level, self.next, self.next}
         then
            set group = g
            {if not g.expanded? then
                {break}
            }
         else
            {break}
        }
    }
    {return group}
  }

  {getter {current-pos}:int
    {return self.count - 1}
  }

  {method public open {read-one}:(v:int, eof?:bool)
    ||FIXME: no upper bound, so done? is never true
    {if self.done? then
        {return (-1, true)}
    }

    def ngroup = {self.find-current-group}
    {if ngroup != self.group then
        set self.group = ngroup
    }

    set self.current = self.next
    {if self.last >= 0 and self.next >= self.last then
        set self.done? = true
    }

    || Find the next visible item
    {inc self.next}
    let ng:#GroupSpec = self.group
    {while ng != null do
        {if {ng.contains? self.next} then
            {break}
         else
            set self.next = ng.last + 1
            {inc self.skipped, ng.last - ng.first}
            set ng = {self.find-current-group}
        }
    }
||--
||--        {if ng != self.group then
||--            set self.next = ng.first
||--            set self.group = ng
||--         elseif not ng.expanded? then
||--            set self.next = ng.last + 1
||--            set ng = {self.find-current-group}
||--            set self.group = ng
||--         else
||--            {break}
||--        }
||--    }
    {inc self.count}
    {return (self.current, false)}
  }
}


{doc-next
    {purpose An array of {docref CellValue}s.}
}
{def public ValueArray = {ResizableArray-of CellValue}}

{define-class public sealed EmbeddedFormInfo
  field public erf:EmbeddedRecordForm
  field public row:int
  field public col:int
  {constructor public {default
                          erf:EmbeddedRecordForm,
                          row:int,
                          col:int
                      }
    set self.erf = erf
    set self.row = row
    set self.col = col
  }
  ||FIXME: need to adjust row/col if rows inserted/deleted
}


{doc-next
    {purpose
        Represents one cell value in a {docref WorksheetModel}.
    }
}
{define-class public sealed CellValue

  field public-get protected-set _value:any = null   || Current cell value
  field public ui-spec:any = null
  field public args:Arguments
  field protected _domain:#Domain
  field public editable?:bool
  field public locked?:bool       || Always edit, or never
  field protected _formula:#Formula  || Formula, if any
  field protected _dataref:#DataRef  || For refs to other sources
  field protected _rowspan:int
  field protected _colspan:int

  || Computed values manipulated at run-time
  field public error?:bool        || Error setting or editing value
  field public-get protected-set covered?:bool      || due to row/colspan
  field public editing?:bool      || editing cell?

  || For embedded form fields (could be in a subclass)
  field public-get protected-set field-spec:#WksCellSpec
  field public-get protected-set embedded-form:#EmbeddedRecordForm
  field public-get protected-set init-proc:#{proc-type {r:#Record}:any}

  {doc-next
    {purpose Create a new {docref CellValue}.}
  }
  {constructor public {default
                          value:any = null,
                          ui-spec:any = null,
                          args:Arguments = {Arguments},
                          domain:#Domain = null,
                          editable?:bool = false,
                          editing?:bool = false,
                          rowspan:int = 1,
                          colspan:int = 1,
                          locked?:bool = true,
                          formula:#Formula = null,
                          dataref:#DataRef = null
                      }
    set self.value = value
    set self.ui-spec = ui-spec
    set self.args = args
    set self._domain = domain
    set self.editable? = editable?
    set self.rowspan = rowspan
    set self.colspan = colspan
    set self.locked? = locked?
    set self.editing? = editing?
    set self.formula = formula
    set self.dataref = dataref
  }

  {getter public open {formatted-value}:String
    {return {self.domain.format self._value}}
  }

  {getter public open {value}:any
    {return self._value}
  }

  {setter public open {value v:any}:void
    let err:#Exception = null
    let dv:any = null
    {try
        set dv = {self.domain.convert v}
     catch e:Exception do
        set err = e
    }
    {if err == null then
        set err = {self.domain.validate dv}
    }
    {if err == null then
        set self._value = dv
        set self.error? = false
     else
        set self._value = self.domain.default-value
        set self.error? = true
    }
  }

  {method public open {domain-value v:any}:any
    let err:#Exception = null
    let dv:any = null
    {try
        set dv = {self.domain.convert v}
     catch e:Exception do
        set err = e
    }
    {if err == null then
        set err = {self.domain.validate dv}
    }
    {if err != null then
        set dv = self.domain.default-value
    }
    {return dv}
  }

  {method public open {apply-options v:Visual}:void
    {for (a,k) in self.args do
        {if-non-null k then
            {v.set-option-by-name k, a}
||FIXME: should we prevent setting width/height?
||--            {if k == "width" then
||--             elseif k == "height" then
||--             else
||--                {v.set-option-by-name k, a}
||--            }
         else
            {error "Internal error"} || Should have been caught earlier
        }
    }
  }

  {method public open {unset-options v:Visual}:void
    {for (a,k) in self.args do
        {if-non-null k then
            {if k == "width" then
             elseif k == "height" then
             else
                {v.unset-option-by-name k}
            }
         else
            {error "Internal error"} || Should have been caught earlier
        }
    }
  }

  {doc-next
    {purpose Clear the information that comes from the {docref-abbr
        CellValue.field-spec}.
    }
    {details
        When records are deleted, this method is used to reset the cell
        values.
    }
  }
  {method public open {clear-form-cell}:void
    set self.value = null
    set self.ui-spec = null
    set self._domain = null
    set self.editable? = false
    set self.locked? = true
    set self._formula = null
    set self._dataref = null
    set self._rowspan = 1
    set self._colspan = 1

    set self.covered? = false
    set self.editing? = false

    set self.field-spec = null
    ||FIXME: You can't clear this or adding a record to an embedded
    || form won't work. Should there be another method? Same for ui-spec
||--    set self.embedded-form = null
    set self.init-proc = null
  }

  {setter public open {formula fval:#Formula}:void
    set self._formula = fval
  }

  {getter public open {formula}:#Formula
    {return self._formula}
  }

        
  {setter public open {dataref ref:#DataRef}:void
    set self._dataref = ref
  }

  {getter public open {dataref}:#DataRef
    {return self._dataref}
  }

  {setter public open {domain val:#Domain}:void
    set self._domain = val
  }

  {getter public open {domain}:Domain
    {if-non-null d = self._domain then
        {return d}
    }
    ||FIXME: implement a type->Domain map
    ||FIXME: implement a range->Domain map
    {return {WorksheetModel.get-default-domain self.value}}
  }

  {setter public open {rowspan val:int}:void
    ||FIXME: update the self.covered? flags for adjacent cells (on WorksheetModel)
    set self._rowspan = val
  }

  {getter public open {rowspan}:int
    {return self._rowspan}
  }

  {setter public open {colspan val:int}:void
    ||FIXME: update the self.covered? flags for adjacent cells (on WorksheetModel)
    set self._colspan = val
  }

  {getter public open {colspan}:int
    {return self._colspan}
  }


}


{define-enum WorksheetOpcode
    none,
    insert-rows,    || a is first, b is count
    insert-cols,    || a is first, b is count
    toggle-group,   || a is row, b is col
    recalc          || a, b ignored. sender.row/col-min/max describes changes
}

{define-class public open WorksheetOperation
  field public operation:WorksheetOpcode
  field a:int
  field b:int
  field c:any

  {constructor public {default
                          operation:WorksheetOpcode,
                          a:int,
                          b:int,
                          c:any = null
                      }
    set self.operation = operation
    set self.a = a
    set self.b = b
    set self.c = c
  }

  {method public open {reset}:void
    set self.operation = WorksheetOpcode.none
    set self.a = -1
    set self.b = -1
    set self.c = null
  }

  {method public open {clone}:WorksheetOperation
    {return {WorksheetOperation self.operation, self.a, self.b, c = self.c}}
  }

  {method public open {to-String}:String
    {return {format "Operation:%s a:%s b:%s c:%s", ||""
                self.operation.name, self.a, self.b, self.c
            }
    }
  }
}

|| Note: models are easy to test. Put as much logic as possible in the model.

{doc-next
    {purpose The data model for a {docref Worksheet}.}
}
{define-class public open WorksheetModel {inherits DataSource, CalcMixin}

  def public any-domain:Domain = {StandardAnyDomain}
  def public int-domain:Domain = {StandardIntDomain}
  def public double-domain:Domain = d3-domain
  def public currency-domain:Domain = {CurrencyDomain}
  def public date-domain:Domain =
      {LocaleDateDomain default-value = {DateTime.date}}
  def public string-domain:Domain = {StandardStringDomain}

  field protected _data-version:String = ""
  field protected _model-name:String = ""

  field public-get protected-set last-operation:WorksheetOperation

  field public-get protected-set change-count:int

  field public-get protected-set vals:ValueArray

  field public-get protected-set row-tree:GroupTree

  field public-get protected-set col-tree:GroupTree

  field public-get protected-set embedded-forms:{Array-of EmbeddedFormInfo} =
      {new {Array-of EmbeddedFormInfo}}

  {getter public open {rows}:int
    {return self.vals.rows}
  }

  {getter public open {cols}:int
    {return self.vals.cols}
  }

  field protected cellrefs:{OrderedSet-of CellRef}
||--  field protected rangerefs:{Array-of RangeRef}
||--
||--  field protected sources:{HashTable-of String, DataSource}

||--  {method protected open {init-cell row:int, col:int}:CellValue
||--    {if self.vals[row, col] == null then
||--        set self.vals[row, col] = {CellValue}
||--    }
||--    {return {unchecked-non-null self.vals[row, col]}}
||--  }

  {getter public open {row-map}:{Array-of int}
    {return {self.row-tree.get-position-map self.rows}}
  }

  {getter public open {col-map}:{Array-of int}
    {return {self.col-tree.get-position-map self.cols}}
  }

  {doc-next
    {purpose Create an {docref WorksheetModel} with an initial size
        of {param rows} by {param cols}.
    }
  }
  {constructor public {default
                          rows:int,
                          cols:int
                      }
    {construct-super.DataSource}
    {construct-super.CalcMixin}
    set self.vals = {ValueArray rows, cols}
    set self.row-tree = {GroupTree}
    {self.row-tree.get-position-map rows}
    set self.col-tree = {GroupTree}
    {self.col-tree.get-position-map cols}
    set self.cellrefs = {new {OrderedSet-of CellRef}}
    {for ri = 0 below rows do
        {for ci = 0 below cols do
            set self.vals[ri, ci] = {CellValue}
        }
    }
    set self.last-operation = {WorksheetOperation "none", -1, -1}

||--    set self.rangerefs = {new {Array-of RangeRef}}

||--    || To support refs to "foreign" DataSources FIXME: NYI
||--    set self.sources = {new {HashTable-of String, DataSource}}

||--    set self.calcs = {new {HashTable-of CellRef, Formula}}
||--    set self.ordered-calcs = {new {Array-of Formula}}
  }

  let private constant np:NumberParser =
      {NumberParser
        allow-grouping? = true,
        allow-exponent? = false,
        whitespace-char-class = {CharClass " $,\t"}
      }


  {define-proc public {get-default-domain v:any}:Domain
    let domain:Domain = WorksheetModel.string-domain
    {if {number? v} then
        set domain = WorksheetModel.double-domain
     elseif v == "" then
        || No change
     else
        {type-switch v
         case nt:Null do
            set domain = WorksheetModel.any-domain
||--         case i:int do
||--            set domain = WorksheetModel.int-domain
         case dt:DateTime do
            set domain = WorksheetModel.date-domain
         case s:StringInterface do
            let num?:bool = false
            {try
                def s = v asa String
                def (ret, end, underflow?, overflow?) =
                    {WorksheetModel.np.parse-double s}
                {if end == s.size then
                    set domain = WorksheetModel.double-domain
                    set num? = true
                }
             catch e:Exception do
                || Ignored - no change to domain
            }
            {if not num? then
                {try
                    def dt = {DateTime v}
                    {if dt.info.hour == 0
                        and dt.info.minute == 0
                        and dt.info.second == 0
                     then
                        set domain = WorksheetModel.date-domain
                     else
                        set domain = DateTime asa Domain
                    }
                 catch e:Exception do
                    || Ignored - no change to domain
                }
            }
         case v:Visual do
            set domain = WorksheetModel.any-domain
         case b:bool do
            set domain = bool asa Domain
         case t:Time do
            set domain = Time asa Domain
        }
    }
    {return domain}
  }

  {method protected open {note-operation
                             operation:WorksheetOpcode,
                             a:int,
                             b:int,
                             c:any = null
                         }:void
||--    {dump self.last-operation.operation, operation}
    {inc self.change-count}
    set self.last-operation.operation = operation
    set self.last-operation.a = a
    set self.last-operation.b = b
    set self.last-operation.c = c
    set self.changed-row-min = self.rows
    set self.changed-row-max = 0
    set self.changed-col-min = self.cols
    set self.changed-col-max = 0
    {self.update}
  }

  {method public open {insert-rows first:int, count:int}:void
    {self.row-tree.adjust first, count}
    {self.vals.insert-rows first, count,
        init-proc = {proc {r:int, c:int}:CellValue
                        {return {CellValue}}
                    }
    }
    {for cr in self.cellrefs do
        {cr.adjust first, count, 0, 0}
    }
    {self.note-operation WorksheetOpcode.insert-rows, first, count}
  }

  {method public open {insert-cols first:int, count:int}:void
    {self.col-tree.adjust first, count}
    {self.vals.insert-cols first, count,
        init-proc = {proc {r:int, c:int}:CellValue
                        {return {CellValue}}
                    }
    }
    {for cr in self.cellrefs do
        {cr.adjust 0, 0, first, count}
    }
    {self.note-operation WorksheetOpcode.insert-cols, first, count}
  }

  ||FIXME: make sure the relative and absolute semantics are well specified!
  {doc-next
    {purpose Create a reference to a cell or range of cells in
        the cell array.
    }
    {details
        There are several ways to specify a cell or range of
        cells.

        The simplest way to specify the cell is to use the
        row and column keyword arguments

        {ctext def ref = {wks.get-ref row = 1, column = 4}}

        Rows and columns are numbered from 0, so this will create an
        absolute reference to the cell on the second row, fifth
        column.

        A cell may be also be specified as a string, using the same
        notation as Excel.  The following call is another way to
        specify the same reference:

        {ctext def ref = {wks.get-ref "E2"}}

        You can also specify a reference as relative to some other
        reference. For example, this is a reference to the cell
        above {param ref}.

        {ctext def above-ref = {wks.get-ref ref, row = -1}}

    }
  }
  {method public open {get-ref
                          ...
                      }:SheetRef
    let ref-str:String = ""
    let row:int = CellRef.all
    let col:int = CellRef.all
    let ref:#CellRef = null
    let absolute?:bool = true
    let argn:int
    {for (a,k) in ... do
        {if-non-null k then
            {if k == "row" then
                set row = a asa int
             elseif k == "column" or k == "col" then
                set col = a asa int
             elseif k == "absolute?" then
                set absolute? = a asa bool
            }
         else
            {type-switch a
             case n:int do
                {if argn == 0 or (ref != null and argn == 1) then
                    set row = n
                 elseif argn == 1 or (ref != null and argn == 2) then
                    set col = n
                 else
                    {error
                        {hlmessage
                            Unexpected int parameter
                        }
                    }
                }
             case s:String do
                set ref-str = s
             case cr:CellRef do
                {if argn != 0 then
                    {error
                        {hlmessage
                            For a relative reference, the CellRef must
                            be the first argument.
                        }
                    }
                }
                set row = 0
                set col = 0
                set ref = cr
            }
        }
        {inc argn}
    }
    def cell-ref =
        {if ref-str != "" then
            {if {ref-str.find ':'} >= 0 then
                {RangeRef.from-String self, ref-str, ref}
             else
                {CellRef.from-String self, ref-str, ref}
            }
         elseif ref != null then
            {CellRef.relative-to {non-null ref}, row, col}
         elseif absolute? then
            {CellRef
                self,
                row, row-abs? = absolute?,
                col, col-abs? = absolute?
            }
         elseif row != CellRef.all or col != CellRef.all then
            {error
                {hlmessage
                    Specify a cell using a string, or keywords row and
                    column, and a reference cell if specifying a
                    relative reference.
                }
            }
         else
            {error {hlmessage Invalid CellRef}}
        }
    {type-switch cell-ref
     case cr:CellRef do
        {if cr.row >= self.rows or cr.col >= self.cols then
            {error
                {hlformat
                    "Reference out of bounds: row=%1!s! col=%2!s!",
                    cr.row, cr.col
                }
            }
        }
        {self.cellrefs.insert cr}
     case rr:RangeRef do
        ||FIXME
    }
    {return cell-ref}
  }

  || Call this if some attribute of a cell changes. If the cell value changes,
  || call self.refresh.
  field public changed-row-min:int
  field public changed-row-max:int
  field public changed-col-min:int
  field public changed-col-max:int


  {method public open {note-cell-changed row:int, col:int}:void
    {if row > self.changed-row-max then
        set self.changed-row-max = row
    }
    {if row < self.changed-row-min then
        set self.changed-row-min = row
    }
    {if col > self.changed-col-max then
        set self.changed-col-max = col
    }
    {if col < self.changed-col-min then
        set self.changed-col-min = col
    }
    ||FIXME: this happens too often, and can cause a stack overflow
||--    {self.note-operation WorksheetOpcode.recalc, row, col}
  }

  {method public open {request-notification
                          ref:DataRef, obs:Observer
                      }:void
    ||FIXME: NYI (or drop this?)
  }

  || Stop notifications for ref. If ref is null, stop all notifications to obs
  {method public open {suspend-notification
                          ref:#DataRef, obs:Observer
                      }:void
    ||FIXME: NYI (or drop this?)
  }


  || ---------------------
  || Cell get/set methods
  || ---------------------

  {method public open {get-value row:int, col:int}:any
    {return self.vals[row, col].value}
  }

  {method public open {set-value row:int, col:int, val:any}:void
    {if self.vals[row, col].value != val then
        set self.vals[row, col].value = val
        {inc self.change-count}
||--        {dump "wks.set-value", row, col, val}
        {self.update}
    }
  }

||--  {method public open {get-locked? row:int, col:int}:bool
||--    {return self.vals[row, col].locked?}
||--  }
||--
||--  {method public open {set-locked? row:int, col:int, val:bool}:void
||--    set self.vals[row, col].locked? = val
||--    {self.note-cell-changed}
||--  }
||--
||--  {method public open {get-editing? row:int, col:int}:bool
||--    {return self.vals[row, col].editing?}
||--  }
||--
||--  {method public open {set-editing? row:int, col:int, val:bool}:void
||--    set self.vals[row, col].editing? = val
||--  }
||--
||--  {method public open {get-domain row:int, col:int}:Domain
||--    {return self.vals[row,col].domain}
||--  }
||--
||--  {method public open {set-domain row:int, col:int, val:#Domain}:void
||--    set self.vals[row, col].domain = val
||--    {self.note-cell-changed}
||--  }
||--
||--  {method public open {get-rowspan row:int, col:int}:int
||--    {return self.vals[row, col].rowspan}
||--  }
||--
||--  {method public open {set-rowspan row:int, col:int, val:int}:void
||--    set self.vals[row, col].rowspan = val
||--    {self.note-cell-changed}
||--  }
||--
||--  {method public open {get-colspan row:int, col:int}:int
||--    {return self.vals[row, col].colspan}
||--  }
||--
||--  {method public open {set-colspan row:int, col:int, val:int}:void
||--    set self.vals[row, col].colspan = val
||--    {self.note-cell-changed}
||--  }
||--

||--  {method public open {set-style row:int, col:int, key:String, val:any}:void
||--    def d = self.vals[row, col].styles
||--    def (old, found?) = {d.get-if-exists key}
||--    {if found? then
||--        {if old == val then
||--            || No real change
||--            {return}
||--        }
||--    }
||--    def styles = self.vals[row, col].settable-styles
||--    set styles[key] = val
||--    {self.note-cell-changed row, col}
||--  }

  {method public open {make-formula-at
                          row:int, col:int, 
                          formula:CalcProc,
                          domain:Domain,
                          ...:DataRef
                      }:void
    {self.make-formula
        {CellRef.absolute self, row, col}, domain, formula, ...}
  }

  {method public open {make-formula
                          target:DataRef,
                          domain:Domain,
                          formula:CalcProc,
                          ...:DataRef
                      }:Formula
    {type-switch target
     case cell-target:CellRef do
        ||FIXME: better error checking/message for target?
        {assert cell-target.absolute?}
        {self.cellrefs.insert cell-target}
        def row = cell-target.row
        def col = cell-target.col
        def cv = self.vals[row, col]
        set cv.domain = domain
        def f = {super.make-formula target, domain, formula, ...}
        set cv.formula = f
        {self.note-cell-changed row, col}
        {return f}
     case r:RangeRef do
        {error {hlmessage The target of a formula must be a CellRef0.}}
     else
        ||FIXME: what about other cases? Is it an error?
        {error {hlmessage The target of a formula must be a CellRef0.}}
||--        def f = {super.make-formula target, formula, ...}
||--        {return f}
    }
  }

  || Called because some other DataSource that we are observing changed
  {method protected open {handle-observer-message
                             sender:Observable,
                             message:any
                         }:void
||--    {dump sender, message, self, self._refresh-requested?}
    ||FIXME: This doesn't notify observers directly, but are they notified
    || in any case (because values are set)? Not sure we need both refresh
    || and recalc methods.
    {self.recalc} || no notification
||--    {self.refresh}
  }

  {doc-next
    {purpose
        Bring the model up to date by evaluating all formulas in
        order, then calling {docref Observable.notify-observers}.
    }
    {details
        This method is called when no event is being handled
        if an update was requested (see {docref RefreshMixin}).
    }
  }
  {method public open {refresh}:void
    {self.recalc}
    {self.notify-observers message = self.last-operation}
    {self.last-operation.reset}
||--    {dump {self.last-operation.to-String}} ||DEBUG
  }

  {doc-next
    {purpose
        Update a cell value. If the new value is different, update
        the change count and bounds of the updated cells.
    }
  }
  {method public open {update-cell-value r:int, c:int, v:any}:void
    def cv = self.vals[r, c]
    {if cv.value != v then
        set cv.value = v
        {self.note-cell-changed r, c}
    }
  }

  {method private {update-covered-cells ri:int, ci:int}:void
    def cv = self.vals[ri, ci]
    {for r = 0 below cv.rowspan do
        {for c = 0 below cv.colspan do
            {if r > 0 or c > 0 then
                set self.vals[ri + r, ci + c].covered? = true
            }
        }
    }
  }

  {method protected open {update-covered}:void
    def rows = self.rows
    def cols = self.cols
    {for ri = 0 below rows do
        {for ci = 0 below cols do
            set self.vals[ri, ci].covered? = false
        }
    }
    {for ri = 0 below rows do
        {for ci = 0 below cols do
            def cv = self.vals[ri, ci]
            {if cv.rowspan > 1 or cv.colspan > 1 then
                {self.update-covered-cells ri, ci}
            }
        }
    }
  }


  {doc-next
    {purpose Bring all values in the cell array up to date.}
    {details
        First go through the cell array in row-major order. If any
        cell is a data reference, update the cell value. Next, evaluate
        all formulas in order. Finally, update cell vaues that are
        data references once more.
    }
  }        
  {method public open {recalc}:void
    {for ri = 0 below self.rows do
        {for ci = 0 below self.cols do
            def cv = self.vals[ri, ci]
            {if-non-null ref = cv.dataref then
                {self.update-cell-value ri, ci, {ref.get-value}}
            }
        }
    }
    {for f in self.ordered-calcs do
        def target = f.target asa CellRef
        {assert target.absolute?}
        def cv = self.vals[target.row, target.col]
        def old-val = cv.value
        {self.eval f.formula, target, {splice f.args}}
        {if old-val != cv.value then
            {self.note-cell-changed target.row, target.col}
        }
    }
    {for ri = 0 below self.rows do
        {for ci = 0 below self.cols do
            def cv = self.vals[ri, ci]
            {if-non-null ref = cv.dataref then
                {self.update-cell-value ri, ci, {ref.get-value}}
            }
        }
    }
    {self.note-operation "recalc", 0, 0}
  }

  {method public open {get-group row:int, col:int, node?:bool = true}:#GroupSpec
    let gs:#GroupSpec = null
    let is-node?:bool = false
    {if-non-null rgs = {self.row-tree.get-group col, row, row} then
        set gs = rgs
        set is-node? = col == gs.level and gs.first == row
    }
    {if gs == null then
        {if-non-null cgs = {self.col-tree.get-group row, col, col} then
            set gs = cgs
            set is-node? = row == gs.level and gs.first == col
        }
    }
    {if node? and not is-node? then
        {return null}
    }
    {return gs}
  }


  {doc-next
    {purpose The version string to be saved with the data.}
  }
  {setter public open {data-version v:String}:void
    set self._data-version = v
  }
  {doc-next
    {purpose Return a version string to be saved with the data.}
  }
  {getter public open {data-version}:String
    {return self._data-version}
  }

  ||FIXME: Do we really need this? (if so, add to the spec)
  {doc-next
    {purpose A name that identifies the model.}
  }
  {getter public open {model-name}:String
    {return self._model-name}
  }
  {setter public open {model-name v:String}:void
    set self._model-name = v
  }

  {doc-next
    {purpose
        If necessary, upgrade data to the format required by the
        current version of the worksheet. If impossible, return null.
    }
    {details
        If {param data} has an entry "data-version" and it is the same
        as {ctext self.data-version}, or if there is no entry for
        "data-version", then simply return {param data}.  Otherwise
        return {ctext {migration data}}.

        In each new release of an application based on a
        {docref WorksheetModel}, you can maintain a migration proc
        to upgrade from older versions (or downgrade from newer
        versions).
    }
  }   
  {method public open {migrate
                          data:JsonObject,
                          migration:{proc-type {data:JsonObject}:#JsonObject}
                      }:#JsonObject
    {return {migration data}}
  }

  {doc-next
    {purpose Return a JSON representation of the data model.}
  }
  {method public open {get-data all?:bool = false}:JsonObject
    def data = {JsonObject
                   "data-version", self.data-version,
                   "model-name", self.model-name
               }
    def forms = {JsonObject}
    set data["forms"] = forms
    {for ri = 0 below self.rows do
        {for ci = 0 below self.cols do
            def ref = {format "$%c$%s", 'A' + ci, ri}
            def cv = self.vals[ri, ci]
            {if-non-null fs = cv.field-spec then
                {if-non-null erf = cv.embedded-form then
                    set forms[ref] =
                        {RecordSet-to-Json erf.record-source}
                }
             else
                {if cv.value != null and cv.init-proc == null
                    and (all? or cv.editable?)
                 then
                    set data[ref] = {cv.domain.format cv.value}
                }
            }
        }
    }
    {return data}
  }

  {doc-next
    {purpose Clear all data from the data model (usually so it can
        be reloaded from saved data).
    }
  }
  {method public open {clear-data}:void
    {for ri = 0 below self.rows do
        {for ci = 0 below self.cols do
            def cv = self.vals[ri, ci]
            {if-non-null fs = cv.field-spec then
                {if-non-null erf = cv.embedded-form then
                    {erf.record-source.delete-all}
                }
             else
                {if cv.editable? or cv.init-proc != null then
                    set cv.value = null
                }
            }
        }
    }
  }

  {doc-next
    {purpose Repopulate the data model from {param data}.}
    {details
        First call {ctext {self.migrate data}} in case
        the {docref-abbr WorksheetModel.data-version} of the data
        differs from the current version. Then call {docref-abbr
        WorksheetModel.clear-data} to clear out the model. Next,
        iterate recursively through {param data} and update the data
        model. Finally, notify observers that there has been an update.
    }
    {return-vals
        Returns true if the update is successful. A result of false
        means that the data could not be migrated to the current
        version.  An error may be thrown if there is an error of
        some kind detected when the model is being repopulated.
    }
  }
  {method public open {put-data data:JsonObject}:bool
    {if-non-null data = {self.migrate data, WorksheetModel.default-migration}
     then
        {self.clear-data}
        let forms:JsonObject = data["forms"] asa JsonObject
        {for ri = 0 below self.rows do
            {for ci = 0 below self.cols do
                def cv = self.vals[ri, ci]
                def ref = {format "$%c$%s", 'A' + ci, ri}
                let (v:any, exists?:bool) = {data.get-if-exists ref}
                {if exists? then
                    set cv.value = {cv.domain.parse v asa String}
                }
                set (v, exists?) = {forms.get-if-exists ref}
                {if exists? then
                    def records = (v asa JsonObject)["records"] asa JsonArray
                    {if-non-null erf = cv.embedded-form then
                        {RecordSet-from-Json erf.record-source, records}
                     else
                        {error "Internal error"} ||RecordSet data but no form
                    }
                    {if-non-null fs = cv.field-spec then
                     else
                        set cv.value = {cv.domain.parse v asa String}
                    }
                }
            }
        }
        {self.update}
        {return true}
    }
    {return false}
  }

  def public default-migration =
      {proc {data:JsonObject}:#JsonObject
        {return data}
      }
}

|| -------------------------------------------------------------------------

|| -------------
|| Worksheet UI
|| -------------

|#
  Important data structures to be maintained
  o WorksheetModel
    o GroupTrees
    o ValueCells
    o CellRefs and RangeRefs
  o Worksheet
    o h-ruler-spec, v-ruler-spec
    o WorksheetGrids
      - rows/cols/cells (handled by RowColGrid)
      o h-ruler, v-ruler (if adjustable in that dimension)
      o spacers (handled by the Rulers)
      o RulerResizers (currently Worksheet.refresh-x calls refresh-resizers)
      o resizer spacers (handled by the RulerResizer)

  Changes that have to be tracked
  o insert/delete row/column (command on a Worksheet)
    o Command calls Worksheet.insert-rows/cols
    o Worksheet modifies the model
    o Model notifies observers using a WorksheetOperation
    o Worksheet observes and notifies WorksheetGrids
    o each WorksheetGrid uses a WorksheetView and adjusts itself
      o insert/delete rows/cols
      o insert/delete in h-ruler or v-ruler
  o insert/delete rows due to embedded form
  o insert due to extra data in input

  o expand/contract row/column group
  o change cell value
  o change rowspan/colspan
  o change font size
  o change column width/row height

#|

|| Proc to handle certain events on any GridCell
{define-proc package {handle-grid-cell-event
                         gc:GridCell, e:GuiEvent, t:ActiveTraversor
                     }:void
    {type-switch e
||--     case foe:FocusOut do
||--        {dump foe, g, gc.row, gc.col, gc.refreshing?}
||--        {if not gc.refreshing? then
||--            {gc.activate-cell false}
||--        }
||--     case fie:FocusIn do
||--        {dump fie, g, gc.row, gc.col, gc.refreshing?}
||--        {if not gc.refreshing? then
||--            {gc.activate-cell true}
||--        }
     case vfe:ValueFinished do
||--        {dump "ValueFinished, commit", t, t.valid?}
        {if t.valid? then
            {gc.commit}
        }
    }
}



{doc-next
    {purpose The {docref Graphic} that displays one cell in a {docref
        Worksheet}.
    }
}
{define-class public open GridCell {inherits Frame}

  {getter public open {style-element}:String
    {if self._style-element == "" then
        {return "GridCell"} ||""
     else
        {return self._style-element}
    }
  }

  {getter package {event-hook}:EventHandler
    {return
        {on e:GuiEvent at t:ActiveTraversor do
            {handle-grid-cell-event self, e, t}
        }
    }
  }

  {nonlocal-option public alternate-row-background:Background
    {self.refresh-background}
  }


  ||FIXME: Is there  a way to make the ui available to a formula?
  ||maybe some syntax to get to it, such as A1`ui

  field public-get private-set ui:#Visual || use insert-ui to set
  field public-get protected-set worksheet:Worksheet
  field public-get protected-set row:int
  field public-get protected-set col:int
  field public-get protected-set refreshing?:bool = false
  field public-get protected-set discloser?:bool = false
  field protected discloser-frame:#Frame
  field public stale?:bool = false

  || Store last value displayed so that changes can be recognized
  field public-get protected-set value:any

  {getter public open {cell-value}:CellValue
    {return self.worksheet.model.vals[self.row, self.col]}
  }

  || Store last row/colspan seen so self can notice changes and react
  field protected last-rowspan:int
  field protected last-colspan:int

  {getter public open {active?}:bool
    {return
        self.worksheet.active-col == self.col and
        self.worksheet.active-row == self.row
    }
  }

  {getter public open {editable?}:bool
    {return self.worksheet.model.vals[self.row, self.col].editable?}
  }

  {doc-next
    {purpose If {ctext self.ui} is a {docref ValueControl} then return it.
        Otherwise, return null.
    }
  }
  {getter public open {editor}:#ValueControl
    {type-switch self.ui
     case ctl:ValueControl do
        {return ctl}
    }
    {return null}
  }

  {doc-next
    {purpose Initialize a {docref GridCell} for the value at {param row}
        and {param col} of {param worksheet}.
    }
  }
  {constructor public {default
                          worksheet:Worksheet,
                          row:int,
                          col:int,
                          ...
                      }
    set self.worksheet = worksheet
    set self.row = row
    set self.col = col
    set self.last-rowspan = 1
    set self.last-colspan = 1
    {construct-super
        discrete-select-in-range? = true,
        {splice ...},
        opaque-to-events? = true,
        {click-recognizer consume? = false},
        {on e:PointerPress at gc:GridCell do
||--            {dump e, e.consumed?}
            {self.activate-cell true}
            {e.consume}
        }
||--        ,
||--        {on e:Click at gc:GridCell do
||--            {dump e, e.consumed?}
||--            {self.activate-cell true}
||--        }
    }
  }

  {method public open {add-content v:any}:void
    {if self.discloser? then
        {self.discloser-frame.add replace? = true, v}
     else
        {self.add replace? = true, v}
    }
  }

  {method public open {clear}:void
    {unset self.data-binding-context}
    set self.ui = null
    set self.value = null
    {super.clear}
  }


  {doc-next
    {purpose Remove the editor and replace it with the formatted value.}
  }
  {method protected open {show-cell-value commit?:bool = true}:void
    def cv = self.cell-value
    {if commit? then
||--        {dump "show-cell-value, commit"}
        {self.commit}
    }

    || If there is an editor, and it isn't locked, remove it.
    {if-non-null editor = self.editor then
        {if not cv.locked? then
            set self.value = null  || Force refresh from cell value
            {(editor asa Graphic).detach}
            set self.ui = null
        }
     else
        {type-switch cv.value
         case erg:EmbeddedRecordGrid do
            set erg.grid-line-color = self.grid-line-color
            {if erg.grid-cell == null then
                set erg.grid-cell = self
             else
                {assert erg.grid-cell == self}
            }
        }
    }

    {if self.editor == null then
        {if cv.value != self.value or self.stale? then
            ||FIXME: reset the margin because sometimes cells don't display
            set self.margin = 0pt
            def margin =
                {if self.editor != null then
                    0m
                 elseif cv.ui-spec isa EmbeddedRecordGrid then
                    0m
                 elseif self.ui isa Graphic then
                    0m
                 elseif cv.ui-spec isa Graphic then
                    0m
                 else
                    self.cell-margin
                }
            set self.margin = margin
            {cv.apply-options self}
            {type-switch cv.value
             case n:Null do
                {self.clear}
             case v:Visual do
                {self.add-content v}
             else
                {self.add-content cv.formatted-value}
            }
            set self.value = cv.value
        }
    }
  }

  || Create the editor for a GridCell that is about to become active
  || (called from gc.refresh when there is no editor but there should be)
  {method protected open {get-editor cv:CellValue}:#ValueControl
    {assert self.ui == null}  || should not be any Graphic in the cell yet
    {assert cv.editable?}     || Must be editable to ask for editor
    {assert not cv.covered?}  || Should not ask for editor if covered

    || If there is a suitable ui-spec, use it to create the editor
    let editor:#ValueControl =
        {type-switch cv.ui-spec
         case nt:Null do
            null
         case p:{proc-type {gc:GridCell}:ValueControl} do
            {p self}
         case p:{proc-type {}:ValueControl} do
            {p}
         case t:ClassType do
            {if-non-null maker = {t.get-instance-maker "default"} then ||""
                {maker.new} asa ValueControl
             else
                {error {hlformat "No default constructor for %1!s!", t}}
            }
         case vc:ValueControl do
            vc
         case v:Visual do
            || Any other type of visual will get inserted as a ui
            {return null}
         else
            null
        }

    let vc:ValueControl =
        {if-non-null editor then
            editor
         else
            {switch cv.domain.type
             case DateTime do
                {DateField}
||--                def df = {DateField}
||--                set df.value-as-any = cv.value
||--                df
             else
                {TextField
                    {validate-with {WorksheetDomainValidator cv.domain}}
                }
||--                {TextField value = {domain.format cv.value}}
            }
        }

||--    set vc.control-appearance-changeable? = true
    set vc.color = vc.look-and-feel.color
    def gctl = vc asa Graphic
    set gctl.width = {add-stretch}
    def ctl-height = {self.worksheet.v-ruler-spec.get-spec-size
                         self.row, self.worksheet.default-row-height
                     }
    set gctl.height = ctl-height
    {cv.apply-options vc}
    {return vc}
  }


  {doc-next
    {purpose Display an object that is not a control.}
  }
  {method public open {insert-ui ui:Visual}:void
    set self.margin = 0pt
    set self.ui = ui
    {self.add-content self.ui}
  }

  {method protected open {insert-editor ctl:ValueControl}:void
    def cv = self.cell-value
||--    {dump "insert-editor", ctl, ctl.value-as-any, cv.value}
    {self.insert-ui ctl}
    {self.refresh-editor}
    {ctl.add-event-handler self.event-hook}
  }

  {method private {refresh-discloser}:void
    let gs:#GroupSpec = null
    let discloser?:bool = false
    {if-non-null
        rgs = {self.worksheet.model.row-tree.get-group
                  self.col, self.row, self.row
              }
     then
        set gs = rgs
        set discloser? = self.col == gs.level and gs.first == self.row
    }
    {if not discloser? then
        def group-tree = self.worksheet.model.col-tree
        {if-non-null cgs = {group-tree.get-group self.row, self.col, self.col}
         then
            set gs = cgs
            set discloser? = self.row == gs.level and gs.first == self.col
        }
    }

    || If a Discloser is needed in this cell, create it now
    {if discloser? and not self.discloser? then
        set self.discloser? = true
        def dgs = {non-null gs}
        def discloser =
            {DefaultDiscloser
                margin = 2pt,
                animation-rate = 0Hz,
                orientation =
                    {if dgs.row? then "vertical" else "horizontal"},
                state = {if dgs.expanded? then
                            DisclosureState.expanded
                         else
                            DisclosureState.collapsed
                        },
                {on e:Adjustment at t:Discloser do
                    {if t.state != DisclosureState.changing then
                        {if t.state == DisclosureState.expanded then
                            set dgs.expanded? = true
                            {self.note-discloser-changing dgs, true}
                         else
                            {self.note-discloser-changing dgs, false}
                            set dgs.expanded? = false
                        }
                        {self.worksheet.update}
||--                        {self.worksheet.rebuild-cell-grid}
                    }
                }
            }
        ||FIXME: This won't work if discloser cell is editable
        set self.discloser? = true
        set self.discloser-frame = {Frame}
        {if-non-null child = self.child then
            {self.discloser-frame.add child.graphic}
        }
        set self.margin = 0pt
        {self.add replace? = true,
            {HBox 
                discloser,
                {Fill width = self.cell-margin}, self.discloser-frame
            }
        }
     elseif not discloser? and self.discloser? then
||--        {dump "?? Removed discloser from this cell:", self.row, self.col}
        {self.clear}
        set self.discloser-frame = null
        set self.value = null
    }
  }

  {doc-next
    {purpose
        Called when the user toggles a discloser.
    }
  }
  {method protected open {note-discloser-changing
                             gs:GroupSpec,
                             expanded?:bool
                         }:void
    {if gs.row? and self.row != gs.first or
        not gs.row? and self.col != gs.first
     then
        {return}
    }
    def cv = self.cell-value
    {if expanded? then
        {if gs.row? then
            set cv.rowspan = gs.last - gs.first + 1
         else
            set cv.colspan = gs.last - gs.first + 1
        }
     else
        {if gs.row? then
            set cv.rowspan = 1
         else
            set cv.colspan = 1
        }
    }
    {self.worksheet.model.note-cell-changed self.row, self.col}
    {self.worksheet.note-group-changing gs, expanded?}
  }

  {method public open {refresh-editor}:void
    {if-non-null editor = self.editor then
        def cv = self.cell-value
||--        {dump "refresh-editor", editor, self.row, self.col, cv.value}
        {if cv.field-spec != null then
            def form = {non-null self.data-binding-context} asa RecordForm
            {form.refresh editor}
         else
            || If a recalc changed the cell value, update the editor
            let ev:any = editor.value-as-any
            {if not ev isa editor.value-type then
                set ev = {cv.domain-value ev}
            }
||--            {dump ev, cv.value, editor.value-type}
            {if ev != cv.value then
                {if cv.value isa editor.value-type then
                    set editor.value-as-any = cv.value
                 elseif String == editor.value-type then
                    set self.editor.value-as-any = cv.formatted-value
                 else
                    set cv.error? = true
                }
            }
        }
        set self.value = cv.value
        {if self.active? then
            {type-switch self.ui
             case lb:ListBox do
                ||FIXME: ListBox throws ArrayBoundsException if called directly
                {after 0s do
                    || Delay until this event handled (problem with ListBox)
                    {lb.become-active-from-traversal}
                }
             case t:ActiveTraversor do
                {t.become-active-from-traversal}
            }
        }
    }
  }

  {method public open {commit}:void
    {if-non-null editor = self.editor then
||--        {dump "commit", self.row, self.col, editor.value-as-any}
        {self.worksheet.set-value self.row, self.col, editor.value-as-any}
    }
  }

  {method protected open {refresh-background}:void
    {if (self.worksheet.selection-context-active? and
         {self.worksheet.selection.contains-cell? self.row, self.col}
        )
        and not (self.active? and self.cell-value.editable?)
     then
        set self.background = self.selected-background
        set self.color = self.selected-color
     else
        {unset self.color}
        {if self.cell-value.editable? then
            set self.background = Worksheet.editable-bg
         else
            {if self.row mod 2 == 1 then
                set self.background = self.alternate-row-background
             else
                {unset self.background}
            }
        }
    }
  }

  {method protected open {refresh}:void

    def cv = self.cell-value

    || Adjust to change in rowspan or colspan
    {if cv.rowspan != self.last-rowspan or cv.colspan != self.last-colspan
||--        or cv.rowspan > 1 or cv.colspan > 1
        or self.visual-parent == null
        or self.stale?
     then
        {self.worksheet.attach-cell self}
        set self.last-rowspan = cv.rowspan
        set self.last-colspan = cv.colspan
    }

    ||FIXME:: this lockout is probably not needed.
    {assert not self.refreshing?}
    set self.refreshing? = true
    def ar = self.worksheet.active-row
    def ac = self.worksheet.active-col
    def active? = self.row == ar and self.col == ac
    {if active? then
||--        {dump active?, self.row, self.col}
    }

|| DEBUG
||--    {if self.row == 15 and self.col == 2 then
||--        {dump self.value, cv.value}
||--    }

    {self.refresh-discloser}
    {self.refresh-background}

    {if cv.editable? and (active? or cv.editing? or cv.locked?) then
        || Model says this cell should be editing, so create a control, etc.
||--        {dump "refresh, editing?=true", self.row, self.col, self.editor}
        {if true or
            (self.active? and cv.editable?) or (cv.editable? and cv.locked?) then
            {if self.editor != null then
                || There is an editor already, just refresh it
                {self.refresh-editor}
             elseif self.ui != null then
                || This is a Visual or Graphic that isn't a ValueControl
                || nothing to do - self.ui was inserted when first seen
||--                {assert cv.locked?}
                set cv.locked? = true
             elseif cv.field-spec != null then
                {if-non-null erf = cv.field-spec.embedded-form then
                    {if-non-null vc = {erf.get-field-editor cv, self} then
                        {self.insert-ui vc}
                        {self.refresh-editor}
||--                        {self.insert-editor vc}
                    }
                 else
                    {error {hlmessage Internal error: missing embedded-form}}
                }
             else
                || not editing yet... Create and add the editor
                {self.worksheet.select-nothing}
                {if-non-null editor = {self.get-editor cv} then
                    {self.insert-editor editor}
                 else
                    {self.insert-ui cv.ui-spec}
                }
            }
        }
     else
        || Should not be editing
||DEBUG
||--        {if ar == self.row and ac == self.col then
||--            {dump "show-cell-value for current cell", self.row, self.col}
||--        }
        {self.show-cell-value}
    }
    set self.visible? = not cv.covered?
    set self.refreshing? = false
    set self.stale? = false
  }

  {method public open {activate-cell
                          active?:bool
                      }:void
    def ar = self.worksheet.active-row
    def ac = self.worksheet.active-col
    def cv = self.cell-value
||--    {dump "activate-cell", self.row, self.col, ar, ac, cv.editing?, active?}

    {if active? then
        {if self.row != ar or self.col != ac then
            || De-activate prior cell
            {{self.worksheet.get-grid-cell ar, ac}.activate-cell false}
         else
            ||FIXME: make this an error or assert
            || This can happen with the window regains focus after losing it
||--            {dump "?? activate-cell called to activate current cell!"}
        }
    }

    {if not active? then
        {if not (self.row == ar and self.col == ac) then
            {return}
        }
        {if cv.editing? then
            {if not cv.locked? then
                set cv.editing? = false
            }
        }
        {self.worksheet.update}
        {return}
    }

    || Now activate self
    {self.worksheet.set-active self.row, self.col}
    {if cv.editable? then
        set cv.editing? = true
    }
    {self.worksheet.update}
  }

  {method public open {get-range-as-selected-text
                          into:StringBuf,
                          start-bound:#GuiMark=null,
                          end-bound:#GuiMark=null
                      }:void
    {type-switch self.ui
     case vc:ValueControl do
        {type-switch  vc.form-value
         case str:String do
            {into.concat str}
         case a:StringArray do
            {for s key si in a do
                {if si > 0 then
                    {into.append ' '}
                }
                {into.concat s}
            }
         else
            || null means nothing. But some controls seem to be
            || buggy. For example DateField doesn't return any text.
            || Use the formatted value.
            def cv = self.cell-value
            {if-non-null cv.value then
                {into.concat cv.formatted-value}
            }
        }
     else
        {super.get-range-as-selected-text into, start-bound = start-bound,
            end-bound = end-bound
        }
    }
  }

} ||GridCell

|# 
  How resizing works
  - There is a RulerResizer for every Grid that tracks a given ruler
    - The resizer points to the ruler and a grid that is tracking that ruler
    - The RulerResizer adds a Fill at the right (or bottom) edge of every
      column (or row) in the Grid that it knows about.
    - Each fill has a cursor that shows you can drag to resize
    - Each fill has event handlers to track a press/move/release sequence
    - Mouse handler calls {self.ruler.note-resize self} after setting a
      state field to indicate what the mouse event was
    - ruler.note-resize notifies observers, the WorksheetGrids
    - The PointerRelease handler also updates the ruler size (doing this
      in the Grid that is observing caused problems because there are
      multiple grids observing and sometimes the resize would be done more
      than once)
  - WorksheetGrid does the following
    - Mouse press: show a line that will track the mouse
    - Mouse move: move the line to follow the mouse pointer
    - Mouse release: remove the tracking line, set column width
  - WorksheetRuler.set-column width
    - Update the width spec for the column that was resized
    - Call ruler.refresh
      - Make sure the correct number of spacers are in place
      - Adjust the size of the spacers to match the specified size
    - When ruler.set-size is called, it means the layout is done, so it
      calls ruler.note-resize with null resizer, which notifies observers
    - When WorksheetGrid handles the message, it sets each h-spacer
      width to match the width of the corresponding segment of the ruler

#|

{define-class public open Spacer {inherits Fill}
  {getter public open {style-element}:String
    {if self._style-element == "" then
        {return "Spacer"} ||""
     else
        {return self._style-element}
    }
  }

  {constructor public {default ...}
||--    {construct-super opaque-to-events? = true, {splice ...}}
    {construct-super ...}
  }
}

{define-class public open Resizer {inherits Fill}

  {getter public open {style-element}:String
    {if self._style-element == "" then
        {return "Resizer"} ||""
     else
        {return self._style-element}
    }
  }

  {constructor public {default ...}
    {construct-super ...}
  }
}

{doc-next
    {purpose
        Add a UI to a {docref WorksheetGrid} for resizing rows or
        columns.
    }
    {details
        This object maintains a collection of "resizers". These are
        simply {docref Fill}s attached to the tops of the columns or
        the left of the rows in the {docref WorksheetGrid}. The
        resizers will track mouse events and update the ruler if the
        user changes the size of a row or column. The grid must call
        {docref RulerResizer.refresh} if rows or columns are added
        or removed.
    }
}
{define-class public open RulerResizer

  {doc-next
    {purpose The {docref BaseRuler} to be tracked and adjusted.}
  }
  field public-get protected-set ruler:BaseRuler

  {doc-next
    {purpose the {docref WorksheetGrid} that is to track the ruler.}
  }
  field public-get protected-set grid:WorksheetGrid

  || Fills inserted above the grid lines to support manual resizing
  || There is a Fill for each column in the grid
  field public-get protected-set resizers:{Array-of Fill}

  ||FIXME
  {doc-next
    {purpose
        The orientation of the ruler. If horizontal, it controls the
        column widhts. If vertical, the row heights.
    }
  }
  {getter public open {horizontal?}:bool
    {return self.ruler.orientation == Orientation.horizontal}
  }

  {doc-next
    {purpose
        If true it means that the user is resizing a row or column by
        dragging the mouse pointer.
    }
  }
  field protected dragging?:bool = false

  {doc-next
    {purpose Single event handler shared by all resizers.}
  }
  field protected _handler:EventHandler

  field public-get protected-set ruler-x:Distance
  field public-get protected-set ruler-y:Distance
  field public-get protected-set x0:Distance
  field public-get protected-set y0:Distance
  field public-get protected-set new-x:Distance
  field public-get protected-set new-y:Distance

  || This is a column number in the ruler. When other grids are notified,
  || they can translate to their own column numbers.
  field public-get protected-set resizer-pos:int
  field public-get protected-set state:String

  field protected last-count:int = -1

  {constructor public {default
                          ruler:BaseRuler,
                          grid:WorksheetGrid
                      }
    set self.state = ""
    set self.ruler = ruler
    set self.grid = grid
    set self.resizers = {new {Array-of Fill}}
    set self._handler =
        {on ge:GuiEvent at g:Graphic do
            {type-switch ge
             case e:PointerPress do
                {for s key si in self.resizers do
                    {if s == g then
                        set self.state = "press" ||""
                        set self.dragging? = true
                        set self.resizer-pos = si
                        {e.continue-implicit-pointer-grab g}
                        set (self.x0, self.y0) =
                            {transform-coordinates e.x, e.y, g, self.ruler}
                        set self.new-x = 0m
                        set self.new-y = 0m
||--                        {dump "press", si, self.x0, self.y0, self.grid.name}
                        {self.ruler.note-resize self}
                        {e.consume}
                        {break}
                    }
                }
             case e:PointerMotion do
                {if self.dragging? then
                    set self.state = "move" ||""
                    def (x, y) =
                        {transform-coordinates e.x, e.y, g, self.ruler}
                    set self.new-x = x - self.x0
                    set self.new-y = y - self.y0
                    {self.ruler.note-resize self}
                    {e.consume}
||--                    {dump "motion", self.new-x/1pt, self.new-y/1pt}
                }
             case e:PointerRelease do
                {if self.dragging? then
                    set self.state = "release" ||""
||--                    {dump "release", self.new-x/1pt, self.new-y/1pt}
                    let selection:#WorksheetSelection =
                        self.ruler.worksheet.selection
                    def ruler-index = {self.ruler.get-index self.resizer-pos}
                    {if self.horizontal? then
                        def old-width =
                            {self.ruler.get-spacer-size self.resizer-pos}
                        def new-width =
                            {max
                                1mm,
                                self.new-x + old-width - self.ruler.line-width
                            }
                        {if-non-null s = selection then
                            {if selection.all-rows?
                                and ruler-index >= s.begin-column
                                and ruler-index <= s.end-column
                             then
                                {for ci = s.begin-column to s.end-column do
                                    {if {self.ruler.includes? ci} then
                                        {self.ruler.spec.set-spec-size ci, new-width}
                                    }
                                }
                             else
                                set selection = null
                            }
                        }
                        {if selection == null then
                            {self.ruler.spec.set-spec-size ruler-index, new-width}
                        }
                        {self.ruler.note-resize self}
                     else
                        def old-height =
                            {self.ruler.get-spacer-size self.resizer-pos}
                        def new-height =
                            {max
                                1mm,
                                self.new-y + old-height - self.ruler.line-width
                            }
                        {if-non-null s = selection then
                            {if selection.all-cols?
                                and ruler-index >= s.begin-row
                                and ruler-index <= s.end-row
                             then
                                {for ri = s.begin-row to s.end-row do
                                    {if {self.ruler.includes? ri} then
                                        {self.ruler.spec.set-spec-size ri, new-height}
                                    }
                                }
                             else
                                set selection = null
                            }
                        }
                        {if selection == null then
                            {self.ruler.spec.set-spec-size ruler-index, new-height}
                        }
                        {self.ruler.note-resize self}
                    }
                    set self.dragging? = false
                    {e.consume}
                }
            }
        }
  }

  || Override
  {method public open {clear}:void
    {for f in self.resizers do
        {f.remove-event-handler self.handler}
        {f.detach}
    }
    {self.resizers.clear}
  }

  {method public open {refresh}:void
    def count =
        {if self.horizontal? then self.grid.cols else self.grid.rows}
    {if count != self.last-count then
||--        {dump "RulerResizer.refresh", self.grid.name, self.last-count, count}
        || Rebuild all of the resizers
        {self.clear}
        set self.last-count = count
        {for i = 0 below count do
            def resizer = {self.make-resizer}
            {self.resizers.append resizer}
            {self.grid.add-resizer self.horizontal?, i, resizer}
        }
    }
  }

  {method public open {make-resizer}:Fill
    def r =
        {Resizer
            opaque-to-events? = true,
            self.handler
        }
    {if self.horizontal? then
||--        set r.height = self.ruler.worksheet.column-selector-height
        set r.style-class = "horizontal" ||""
     else
||--        set r.width = self.ruler.worksheet.row-selector-width
        set r.style-class = "vertical" ||""
    }
    {return r}
  }

  {getter {handler}:EventHandler
    {return self._handler}
  }

} ||RulerResizer



{doc-next
    {purpose
        When set-size is called, notify observers of the new bounds.
    }
}
{define-class public open SizeNotifier {inherits Observable, Frame}

  field public-get protected-set row?:bool
  field public-get protected-set prev-width:Distance = 0m

  {getter public open {style-element}:String
    {if self._style-element == "" then
        {return "SizeNotifier"} ||""
     else
        {return self._style-element}
    }
  }

  {getter public open {cell-width}:Distance
    {return (self.layout asa BasicLayout).cell-bounds.width}
  }

  {getter public open {cell-height}:Distance
    {return (self.layout asa BasicLayout).cell-bounds.height}
  }

  {constructor public {default
                          row?:bool,
                          ...
                      }
    {construct-super.Observable}
    {construct-super.Frame
        opaque-to-events? = true,
        {splice ...}
    }
    set self.row? = row?
    set self.style-class =
        {if row? then "vertical" else "horizontal"} ||""
  }

  {method public open {set-size lc:LayoutContext, bounds:GRect}:void
    {super.set-size lc, bounds}
    def w = bounds.width
    {self.notify-observers}
    {if w != self.prev-width then
        {self.notify-observers}
        set self.prev-width = w
    }
  }

}


{doc-next
    {purpose
        Specifies the widths or heights of the columns or rows in a 
        {docref Worksheet}.
    }
    {details
        This object contains one size specification for each row or
        column in a {docref Worksheet}. The size is used for the cell
        size and does not include the grid line width.

        The number of specs must match the number the number of rows
        (for a vertical ruler) or columns (for a horizontal ruler) in
        the model. There will be one {docref RulerSpec} for the rows
        and another for the columns.

        This class does not do any notifications itself.
        Notifications are done by the objects that modify this object.
    }
}
{define-class public open RulerSpec

  {doc-next
    {purpose The sizes specified for each segment of the ruler.}
  }
  field public-get protected-set specs:Array

  {doc-next
    {purpose The {docref Orientation} of the ruler (vertical or horizontal).}
  }
  field protected _orientation:Orientation

  {doc-next
    {purpose
        Splits the ruler into two parts. The sizes up to and including the
        split index correspond to the frozen rows or columns.
    }
  }
  field protected _split-count:int

  {doc-next
    {purpose The {docref Orientation} of the ruler (vertical or horizontal).}
  }
  {getter public open {orientation}:Orientation
    {return self._orientation}
  }

  {doc-next
    {purpose
        Splits the ruler into two parts. The sizes up to and including the
        split index correspond to the frozen rows or columns.
    }
  }
  {getter public open {split-count}:int
    {return self._split-count}
  }
  {setter public open {split-count i:int}:void
    set self._split-count = i
  }

  {doc-next
    {purpose Initialize a new {docref RulerSpec}.}
    {parameter orientation,
        Provides the initial value for {docref RulerSpec.orientation}.
    }
    {parameter split-count,
        Provides the initial value for {docref RulerSpec.split-count}.
    }
    {parameter ...,
        Initial values for the sizes of each segment of the ruler.
        Each value must be a number (interpreted as a number of
        points), a {docref Distance}, or a {docref PixelDistance}.
    }
  }
  {constructor public {default
                          orientation:Orientation,
                          split-count:int,
                          ...
                      }
    set self._orientation = orientation
    set self._split-count = split-count
    set self.specs = {Array {splice ...}}
    {for a key ai in self.specs do
        {self.get-spec-size ai, 0m}
    }
  }

  {doc-next
    {purpose
        Return the specified size of a row (height) or column (width),
        given a row or column number in the model.
    }
  }
  {method public open {get-spec-size i:int, default-size:any}:any
    let spec:any =
        {if i < self.specs.size then
            self.specs[i]
         else
            default-size
        }
    let size:any =
        {if {number? spec} then
            spec asa double * 1pt
         else
            {type-switch spec
             case pd:PixelDistance do
                pd
             case d:Distance do
                d
             else
                {error
                    {hlformat
                        "Size %1!s! must be a Distance or PixelDistance: '%2!s!'",
                        i, spec
                    }
                }
            }
        }

    def n = self.specs.size
    {if i >= n then
        {self.insert n, i - n + 1, size}
    }
    {return size}
  }

  {doc-next
    {purpose
        Change the specified size of a row (height) or column (width),
        given a row or column number in the model and a new size.
    }
    {parameter i, The index of the value to be changed. This is a row
        or column number in the model (0-origin).
    }
    {parameter size, The new size. It must be a number (interpreted as
        a number of points), a {docref Distance}, or a {docref
        PixelDistance}.
    }
  }
  {method public open {set-spec-size i:int, size:any}:any
    {if i >= self.specs.size then
        {return {self.get-spec-size i, size}}
    }
    set self.specs[i] = size
    || Call get-spec-size to check for validity
    {return {self.get-spec-size i, 0m}}
  }

  {doc-next
    {purpose Insert or delete size specifications at the position
        indicated by {param first}. If count is negative, size specs
        are removed.
    }
  }
  {method public open {insert
                          first:int,
                          count:int,
                          size:any
                      }:void
    || Make sure specs exist up to first
    {if first >= self.specs.size then
        def n = first - self.specs.size
        {inc count, n}
        {dec first, n}
    }
    {if count < 0 then
        {self.specs.remove first, length = -count}
     elseif count > 0 then
        {for i = 0 below count do
            def ri = first + i
            {self.specs.insert size, ri}
        }
    }
  }
}


|| FIXME: probably shouldn't change attributes here... this should
|| simply notice changes and broadcast them to the UI
{doc-next
    {purpose
        An object that maintains row heights or column widths in a
        {docref WorksheetGrid}.
    }
    {details
        This object mediates between the model and the UI. If you
        change an attribute of the ruler, it notifies observers (which
        are UI objects) so that they will update themselves to match
        the new state.

        A given {docref WorksheetGrid} may cover only some of the
        cells in the model. For example, it may be displaying only the
        frozen rows, and some of the columns may be invisible because
        they contain groups that eare collapsed. The ruler
        (represented by this object) can map in index in the model to
        a visible row or column position in a {ctext WorksheetGrid}
        or vice versa.
    }
}
{define-class abstract public open BaseRuler {inherits Visual, Observable}

  field public-get protected-set worksheet:Worksheet

  {getter public open {default-size}:Distance
    {return
        {if self.orientation == Orientation.vertical then
            {self.any-to-Distance self.worksheet.default-row-height}
         else
            {self.any-to-Distance self.worksheet.default-column-width}
        }
    }
  }

  || 0 is frozen 1 is normal, more later?
  field public-get protected-set region:int

  {getter public open {group-tree}:GroupTree
    {return
        {if self.orientation == Orientation.vertical then
            self.worksheet.model.row-tree
         else
            self.worksheet.model.col-tree
        }
    }
  }

  field protected _offset:int
  field protected _prev-offset:int = 0

  {getter public open {offset}:int
    def offset = {if self.region == 0 then
                     0
                  else
                     self.spec.split-count
                 }
    {if offset != self._offset then
        set self._prev-offset = self._offset
    }
    set self._offset = offset
    {return self._offset}
  }

  field protected _prev-count:int = 0

  {getter public open {last-index}:int
    {return
        {if self.region == 0 then
            self.spec.split-count - 1
         else
            {if self.orientation == Orientation.vertical then
                self.worksheet.model.rows - 1
             else
                self.worksheet.model.cols - 1
            }
        }
    }
  }

  {doc-next
    {purpose Return the number of visible segments in the ruler.}
  }
  {getter public open {visible-count}:int
    def index = self.last-index
    {return
        {if index >= 0 then
            {self.get-position index} + 1
         else
            0
        }
    }
  }

  {getter public open {line-width}:Distance
    {return
        {if self.orientation == Orientation.horizontal then
            {self.any-to-Distance self.vertical-grid-line-width}
         else
            {self.any-to-Distance self.horizontal-grid-line-width}
        }
    }
  }

  field protected spec:RulerSpec

  ||FIXME: remove this?
  field protected message:any || Message for notify-observers call

  || Objects to fill up the ruler
  field protected segments:{Array-of SizeNotifier}

  {getter public open {orientation}:Orientation
    {return self.spec.orientation}
  }

  {constructor public {default
                          worksheet:Worksheet,
                          spec:RulerSpec,
                          region:int,
                          ...
                      }
    set self.worksheet = worksheet
    set self.region = region
    {construct-super.Observable}
    {construct-super.Visual ...}
    set self.segments = {new {Array-of SizeNotifier}}
    set self.spec = spec
    {self.refresh}
  }

  {doc-next
    {purpose
        Return true if the ruler covers the specified row or column
        in the model.
    }
  }
  {method public open {includes? i:int}:bool
    {return i >= self.offset and i <= self.last-index}
  }

  || Return the first and last position for first and count in the model
  {method public open {clip first:int, count:int}:(first:int, last:int)
    def delete? = count < 0
    def n = {if delete? then -count else count}
    let last:int = first + n - 1
    def last-visible = self.offset + self.visible-count - 1
    {if first > last-visible or last < self.offset then
        {return (-1, -1)}
    }
    {if not {self.includes? first} then
        set first = self.offset
    }
    {if not {self.includes? last} then
        set last = last-visible
    }
    def p0 = {self.get-position first}
    def p1 = {self.get-position last}
||--    {dump "clip", first, last, self.offset, p0, p1} ||DEBUG
    {return (p0, p1)}
  }

  {method public open {get-index pos:int}:int
    {return {self.group-tree.map-position-to-index pos} + self.offset}
  }

  {method public open {get-position i:int}:int
    def pos = {self.group-tree.map-index-to-position i}
    {return
        {if pos >= 0 then
            {self.group-tree.map-index-to-position i} - self.offset
         else
            -1
        }
    }
  }

  {method public open {get-total-size pos:int}:Distance
    def i = {self.get-index pos}
||--    {assert {self.includes? i}}
    def size = {self.spec.get-spec-size i, self.default-size}
    {return {self.any-to-Distance size} + self.line-width}
  }

||--  {method public open {set-spec-size pos:int, size:any}:void
||--    def i = {self.get-index pos}
||--    {assert {self.includes? i}}
||--    {self.spec.set-spec-size i, size}
||--    {self.refresh}
||--  }

  {method protected open {init-segment pos:int}:void
    let sn:SizeNotifier = self.segments[pos]
    let size:Distance = {self.get-total-size pos}
||--    set sn.background = "yellow" ||DEBUG
    {if self.orientation == Orientation.vertical then
        set sn.width = self.worksheet.row-selector-width
        set sn.height = size
     else
        set sn.width = size
        set sn.height = self.worksheet.column-selector-height
    }
  }

  {method abstract protected open {insert-segment i:int}:void
  }

  || Called by refresh to add/remove segments - adjust width/height later
  {method protected open {insert-segments first:int, count:int, size:any}:void
    {if count < 0 then
        {for i = 0 below -count do
            def ri = first + i
            {self.segments[ri].detach}
        }
        {self.segments.remove first, length = -count}
     elseif count > 0 then
        {for i = 0 below count do
            def ri = first + i
            def spacer = {SizeNotifier self.orientation == Orientation.vertical}
            {self.segments.insert spacer, ri}
            {self.insert-segment ri}
        }
    }
  }

  || Called when user adjusts size
  {method public open {note-resize resizer:#RulerResizer}:void
    {self.refresh}
    {self.notify-observers message = resizer}
    ||FIXME: probably don't need self.message field any more
||--    set self.message = resizer
||--    def m = self.message
||--    {after 0s do
||--        {self.notify-observers message = m}
||--    }
    set self.message = null
  }

  || Make sure there are the correct number of segments and that the
  || sizes are correct.
  {method public open {refresh}:void
    {assert self._prev-count == self.segments.size}
    def old-count = self.segments.size
    def count = self.visible-count
    {self.insert-segments
        {min self.visible-count, old-count}, count - old-count, self.default-size
    }
    {for s key si in self.segments do
        {self.init-segment si}
    }
    {assert self.segments.size == count}
    set self._prev-count = self.visible-count
    set self._prev-offset = self.offset
  }

||FIXME: not used
||--  {method public open {get-notifier pos:int}:SizeNotifier
||--    {return self.segments[pos]}
||--  }

||--  {method public open {set-spec i:int, spec:any}:void
||--    def size = {self.any-to-Distance spec}/1pt
||--    {dump "set-spec", i, size}
||--
||--    || Insert default specs if needed. If there are more columns than specs,
||--    || get-spec-size just returns the default and the spec is created only
||--    || if it gets changed to a new value
||--    {for si = self.spec.specs.size - 1 below i do
||--        {self.insert-segments si + 1, 1}
||--    }
||--    set self.specs[i] = spec
||--    def sn = self.segments[i]
||--    {if self.orientation == Orientation.vertical then
||--        set sn.height = {self.get-spec-size i}
||--     else
||--        set sn.width = {self.get-spec-size i}
||--    }
||--  }

  {method public open {get-spacer-size pos:int}:Distance
    {if pos < self.segments.size then
        {if-non-null layout = self.segments[pos].layout then
            def sw =
                {if self.orientation == Orientation.vertical then
                    (layout asa BasicLayout).cell-bounds.height
                 else
                    (layout asa BasicLayout).cell-bounds.width
                }
            {if sw != 0m then
||--                {dump "get-spacer-size", self.orientation, sw/1pt}
                {return sw}
            }
        }
    }
    {return {self.any-to-Distance {self.get-total-size pos}}}
  }

  {method public open {get-notifier i:int}:#SizeNotifier
    {if {self.includes? i} then
        def pos = {self.group-tree.map-index-to-position i} - self.offset
        {if pos >= 0 and pos < self.segments.size then
            {return self.segments[pos]}
        }
    }
    {return null}
  }

  {doc-next
    {purpose
        Given (x,y) coordinates relative to the ruler, return the
        corresponding index (a row or column in the model).
    }
    {details
        A return value of -1 means the point was in a row or column
        header (for a {docref VerticalRuler} or {docref HorizontalRuler}
        respectively).
    }
  }
  {method public open {index-for-point x:Distance, y:Distance}:int
    def sn =
        {(self asa Graphic).find-graphic-at x, y,
            {proc {g:Graphic}:bool
||--                {dump self, g, g.style-class}
                {return g isa SizeNotifier}
            }
        }
    {if-non-null sn then
        {for segment key si in self.segments do
            {if segment == sn then
                {return {self.get-index si}}
            }
        }
    }
    {return -1}
  }


}

{doc-next
    {purpose
        An object used in a {docref Worksheet} to determine the widths
        of the columns.
    }
    {details
        This type of object is used by a {docref Worksheet} to
        maintain column widths or row heights. The ruler is a graphic
        that is stretched all the way across the worksheet (vertically
        or horizontally). When a layout cycle has been completed, it
        notifies the {ctext Worksheet}, which is an {docref
        Observer}. The {ctext Worksheet} will then query the ruler for
        the size of each row or column. In addition, the Worksheet
        will notify the ruler when rows or columns are inserted or
        deleted.
    }
}
{define-class public open HorizontalRuler {inherits HBox, BaseRuler}

  {constructor public {default
                          worksheet:Worksheet,
                          region:int,
                          ...
                      }
    def spec = worksheet.h-ruler-spec
    {construct-super.HBox _style-element = "HorizontalRuler", {splice ...}}
||--    set self.background = "yellow" ||DEBUG
    {construct-super.BaseRuler worksheet, spec, region}
  }

  {method protected open {insert-segment i:int}:void
||--    {self.add-at-index self.segments[i], i}
    {self.add self.segments[i]}
  }

  || Override
  {method public open {clear}:void
    {self.segments.clear}
    {self.spec.specs.clear}
    {super.clear}
  }


  || Override
  {method public open {set-size lc:LayoutContext, bounds:GRect}:void
    {super.set-size lc, bounds}
    {self.note-resize null}
  }

}

{doc-next
    {purpose
        An object used in a {docref Worksheet} to determine the heights
        of the rows.
    }
    {details
        This type of object is used by a {docref Worksheet} to
        maintain row heights.

        The ruler is attached from the top to the bottom of
        the {docref Worksheet}.  When a layout cycle has been
        completed, the ruler notifies the {docref RulerResizer}s that
        are observing it.  (There is one for each {docref
        WorksheetGrid} that is used internally to implement the
        worksheet display.)

        In addition, the Worksheet will notify the ruler when rows or
        columns are inserted or deleted.
    }
}
{define-class public open VerticalRuler {inherits VBox, BaseRuler}

  {constructor public {default
                          worksheet:Worksheet,
                          region:int,
                          ...
                      }
    def spec = worksheet.v-ruler-spec
    {construct-super.VBox _style-element = "VerticalRuler", {splice ...}}
||--    set self.background = "orange" ||DEBUG
    {construct-super.BaseRuler worksheet, spec, region}
  }

  {method protected open {insert-segment i:int}:void
||--    {self.add-at-index self.segments[i], i}
    {self.add self.segments[i]}
  }

  || Override
  {method public open {clear}:void
    {self.segments.clear}
    {self.spec.specs.clear}
    {super.VBox.clear}
  }


  || Override
  {method public open {set-size lc:LayoutContext, bounds:GRect}:void
    {super.set-size lc, bounds}
    {self.note-resize null}
  }

}

|| -------------------------------------------------------------------------

{doc-next
    {purpose
        A subclass of {docref RowColGrid} that allows row heights 
        and column widths to be adjusted with the mouse.
    }
}
{define-class public open WorksheetGrid {inherits RowColGrid, Observer}

  field public-get protected-set worksheet:Worksheet

||FIXME: optional-resizers (autosize difficult with 4 grids)
||--  {local-option public resizable-rows?:bool = false
||--    {self.refresh-resizers}
||--  }
||--
||--  {local-option public resizable-cols?:bool = false
||--    {self.refresh-resizers}
||--  }

  field protected top-left:Fill

  {doc-next
    {purpose
        The ruler that controls column widths. Two or more grids can share
        the same ruler.
    }
  }
  field protected _h-ruler:#HorizontalRuler
  field protected h-ruler-shim:Fill

  {getter public open {h-ruler}:#HorizontalRuler
    {return self._h-ruler}
  }

  {setter {h-ruler ruler:#HorizontalRuler}:void
    {if-non-null old-ruler = self._h-ruler then
        {self.stop-observing old-ruler}
        {old-ruler.detach}
    }

    {if-non-null ruler then
        {self.observe ruler}
        set self._h-ruler = ruler
        {self.clear-h-spacers}

        {if self.h-resize? then
            {self.h-ruler-shim.detach}
            set self.top-left.height = self.worksheet.column-selector-height
            {if self.h-resizer == null then
                || This instance will have resizers on the columns
                set self.h-resizer = {RulerResizer {non-null self.h-ruler}, self}
             else
                || No change needed
                {return}
            }
            {self.add ruler,
                top = {self.top}, bottom = self.h-ruler-fiducial,
                left = self.left-edge, right = self.right-edge
            }
         else
            || Need to anchor self.top-edge to the top of the grid
            {unset self.top-left.height}
            {self.add self.h-ruler-shim,
                top = {self.top}, bottom = self.top-edge,
                left = {self.left}, right = self.left-edge
            }
            {if self.h-resizer == null then
                || No change needed
                {return}
             else
                {self.h-ruler.detach}
                set self.h-ruler = null
                {self.h-resizer.clear} || Probably not strictly necessary
                set self.h-resizer = null
            }
        }
    }
  }

  field public h-resizer:#RulerResizer

  field public-get protected-set h-ruler-fiducial:GridFiducial

  field protected _h-resize?:bool

  {getter public open {h-resize?}:bool
    {return self._h-resize?}
  }

  {setter private {h-resize? resize?:bool}:void
    set self._h-resize? = resize?
  }

  || Graphical elements to provide feedback as a resizer is dragged
  field protected h-resize-spacer:Fill
  field protected h-resize-rule:Fill
  field protected h-resize-fiducial:GridFiducial

  || Fills inserted into the grid to maintain column spacing
  field protected h-spacers:{Array-of Fill}
  
  || Fiducial for the bottom of the h-spacers
||--  field protected h-fiducial:GridFiducial

  || Vertical ruler support

  field protected _v-ruler:#VerticalRuler
  field protected v-ruler-shim:Fill

  {doc-next
    {purpose
        The ruler that controls column widths. Two or more grids can share
        the same ruler.
    }
  }
  {getter {v-ruler}:#VerticalRuler
    {return self._v-ruler}
  }

  {setter {v-ruler ruler:#VerticalRuler}:void
    {if-non-null old-ruler = self._v-ruler then
        {self.stop-observing old-ruler}
        {old-ruler.detach}
    }

    {if-non-null ruler then
        {self.observe ruler}
        set self._v-ruler = ruler
        {self.clear-v-spacers}

        {if self.v-resize? then
            {self.v-ruler-shim.detach}
            set self.top-left.width = self.worksheet.row-selector-width
            {if self.v-resizer == null then
                || This instance will have resizers on the rows
                set self.v-resizer = {RulerResizer {non-null self.v-ruler}, self}
             else
                || No change needed
                {return}
            }
            {self.add ruler,
                top = self.top-edge, bottom = self.bottom-edge,
                left = {self.left}, right = self.v-ruler-fiducial
||--                left = {self.left}, right = {self.right}
            }
         else
            {unset self.top-left.width}
            || Need to anchor self.left-edge to the left of the grid
            {self.add self.v-ruler-shim,
                top = {self.top}, bottom = self.top-edge,
                left = {self.left}, right = self.left-edge
            }
            {if self.v-resizer == null then
                || No change needed
                {return}
             else
                {self.v-ruler.detach}
                set self.v-ruler = null
                {self.v-resizer.clear} || Probably not strictly necessary
                set self.v-resizer = null
            }
        }
    }
  }

  field public v-resizer:#RulerResizer

  field public-get protected-set v-ruler-fiducial:GridFiducial

  field protected _v-resize?:bool

  {getter public open {v-resize?}:bool
    {return self._v-resize?}
  }

  {setter private {v-resize? resize?:bool}:void
    set self._v-resize? = resize?
  }

  || Graphical elements to provide feedback as a resizer is dragged
  field protected v-resize-spacer:Fill
  field protected v-resize-rule:Fill
  field protected v-resize-fiducial:GridFiducial

  || Fills inserted into the grid to maintain column spacing
  field protected v-spacers:{Array-of Fill}
  
  || Fiducial for the bottom of the v-spacers
||--  field protected v-fiducial:GridFiducial


  {constructor public {default
                          worksheet:Worksheet,
                          rows:int,
                          cols:int,
                          h-ruler:HorizontalRuler,
                          v-ruler:VerticalRuler,
                          h-resize?:bool = true,
                          v-resize?:bool = true,
                          ...
                      }
    set self.worksheet = worksheet
    {construct-super.Observer}
    {construct-super.RowColGrid
        rows, cols,
        vorigin = "top", horigin = "left",
        {splice ...}
    }

    set self.top-left =
        {Fill style-class = "top-left", opaque-to-events? = true}

    set self.h-spacers = {new {Array-of Fill}, efficient-size = cols}
||--    set self.h-ruler-fiducial =
||--        {self.make-fiducial orientation = Orientation.horizontal}
    set self.h-ruler-fiducial = self.top-edge
||--    set self.h-fiducial =
||--        {self.make-fiducial orientation = Orientation.horizontal}
    set self.h-ruler-shim =
        {Fill width = 0mm, height = 0mm, name = "h-ruler-shim"}

    set self.v-spacers = {new {Array-of Fill}, efficient-size = rows}
||--    set self.v-ruler-fiducial =
||--        {self.make-fiducial orientation = Orientation.vertical}
    set self.v-ruler-fiducial = self.left-edge
||--    set self.v-fiducial =
||--        {self.make-fiducial orientation = Orientation.vertical}
    set self.v-ruler-shim =
        {Fill width = 0mm, height = 0mm, name = "v-ruler-shim"}

    set self.h-resize? = h-resize?
    set self.v-resize? = v-resize?

    set self.h-ruler = h-ruler
    set self.v-ruler = v-ruler

    || The following elements are used to draw a line in this grid that
    || tracks the resizer in the header as it is dragged with the mouse
    set self.h-resize-fiducial =
        {self.make-fiducial orientation = Orientation.vertical}
    set self.h-resize-rule =
        {Fill _style-element = "WorksheetGrid/h-resize-rule"}
    set self.h-resize-spacer =
        {Fill _style-element = "WorksheetGrid/h-resize-spacer"}

    set self.v-resize-fiducial =
        {self.make-fiducial orientation = Orientation.horizontal}
    set self.v-resize-rule =
        {Fill _style-element = "WorksheetGrid/v-resize-rule"}
    set self.v-resize-spacer =
        {Fill _style-element = "WorksheetGrid/v-resize-spacer"}

    {self.add self.top-left,
        top = {self.top}, bottom = self.top-edge,
        left = {self.left}, right = self.left-edge
    }
||--    {self.refresh}
  }

||FIXME: optional-resizers (autosize difficult with 4 grids)
||--  {method public open {refresh-resizers}:void
||--    {if self.resizable-rows? and self.v-resizer == null then
||--        {dump "FIXME: resizable-rows?"}
||--     else
||--    }
||--    {if self.resizable-cols? and self.h-resizer == null then
||--        {dump "FIXME: resizable-cols?"}
||--     else
||--    }
||--  }

  {method public open {cell-at-point x:Distance, y:Distance}:#GridCell
    def g =
        {self.find-graphic-at x, y,
            {proc {g:Graphic}:bool
                {return g isa GridCell}
            }
        }
    {if-non-null g then
        {type-switch g
         case gc:GridCell do
            {return gc}
        }
    }
    {return null}
  }

  || Create a new GridCell and store it in self.cells
  {method protected open {make-cell row:int, col:int}:GridCell
    def gc = {GridCell self.worksheet, row, col}
    def cv = self.worksheet.model.vals[row, col]
    {type-switch cv.value
     case erg:EmbeddedRecordGrid do
        set erg.grid-cell = gc
        set erg.grid-cell.vstretch? = true
        set erg.grid-cell.hstretch? = true
        set erg.grid-cell.valign = "top"
        set cv.ui-spec = erg
        {gc.insert-ui erg}
    }
    {return gc}
  }

  {method protected open {make-cells}:void
    {for ri = 0 below self.worksheet.model.rows do
        {for ci = 0 below self.worksheet.model.cols do
            def cpos = {self.h-ruler.get-position ci}
            def rpos = {self.v-ruler.get-position ri}
            {if cpos >= 0 and rpos >= 0 then
                set self.cells[rpos, cpos] = {self.make-cell ri, ci}
            }
        }
    }
  }

  ||FIXME: is this really needed?
  {method public open {note-insert-rows first:int, count:int}:void
    {self.insert-rows first, count}
  }

  {method public open {note-insert-cols first:int, count:int}:void
    {self.insert-cols first, count}
  }

  {method public open {refresh}:void
    || Things that might change
    || - rows or cols => handled by insert-rows/cols
    || - One of the rulers => update the corresponding RulerResizera
    || - h-offset or v-offset => adjust row heights or column widths
    || - h-resize? or v-resize? => add or remove a resizer (done in setter)

    {if-non-null h-resizer = self.h-resizer then
        set h-resizer.ruler = {non-null self.h-ruler || In case ruler was changed
                              }}
    {self.refresh-h-spacers}

    {if-non-null v-resizer = self.v-resizer then
        set v-resizer.ruler = {non-null self.v-ruler} || In case ruler was changed
    }
    {self.refresh-v-spacers}

    {for rpos = 0 below self.rows do
        {for cpos = 0 below self.cols do
            def ri = {self.v-ruler.get-index rpos}
            def ci = {self.h-ruler.get-index cpos}
            {type-switch self.cells[rpos, cpos]
             case gc:GridCell do
                {gc.refresh} ||qfix
             case n:Null do
                def gc = {self.make-cell ri, ci}
||--                {dump "new cell:", ri, ci, rpos, cpos, {gc.get-text}}
                {gc.refresh} ||qfix
            }
        }
    }
  }

  {method public open {get-column-width pos:int}:Distance
    {return
        {self.h-ruler.get-spacer-size pos}
    }
  }

  {method public open {get-row-height pos:int}:Distance
    {return
        {self.v-ruler.get-spacer-size pos}
    }
  }

  || Rebuild the spacers
  {method protected open {clear-h-spacers}:void
    {for spacer in self.h-spacers do
        {spacer.detach}
    }
    {self.h-spacers.clear}
  }

  ||FIXME: separate from cells
  {method public open {add-resizer
                          horizontal?:bool, i:int, resizer:Graphic
                      }:void
    {if horizontal? then
        def fi = {min self.col-edges.size - 1, i * 2 + 3}
        def right = self.col-edges[fi]
        {self.add
            resizer,
            top = {self.top}, bottom = {self.bottom},
            right = right
        }
     else
        def fi = {min self.row-edges.size - 1, i * 2 + 3}
        def bottom = self.row-edges[fi]
        {self.add
            resizer,
            left = {self.left}, right = {self.right},
            bottom = bottom
        }
    }
  }

  {method protected open {refresh-h-spacers}:void
    {if self.h-spacers.size != self.cols then
||--        {dump "refresh-h-spacers (from scratch)", self.name}
        {self.clear-h-spacers}
        {for i = 0 below self.cols do
            def spacer =
                {Spacer
                    width = {self.h-ruler.get-total-size i},
                    height = 0mm,
                    style-class = "horizontal"
||--                    ,background = ||DEBUG
||--                        {if i mod 2 == 0 then "lime" else "orange"},
||--                    border-width = 1in/300
                }
            {self.h-spacers.append spacer}
            def left = self.col-edges[i*2]
            def right = self.col-edges[(i + 1)*2]
||--            {dump left, right}
            {super.add spacer,
                left = left, right = right,
                top = {self.top}, bottom = self.top-edge
            }
        }
     else
||--        {dump "refresh-h-spacers", self.name}
        {for spacer key si in self.h-spacers do
            set spacer.width = {self.h-ruler.get-total-size si}
        }
    }
  }

  || Rebuild the spacers
  {method protected open {clear-v-spacers}:void
    {for spacer in self.v-spacers do
        {spacer.detach}
    }
    {self.v-spacers.clear}
  }

  {method protected open {refresh-v-spacers}:void
    {if self.v-spacers.size != self.rows then
||--        {dump "refresh-v-spacers (from scratch)", self.name}
        {self.clear-v-spacers} || Rebuild completely
        {for i = 0 below self.rows do
            def spacer =
                {Spacer
                    width = 0mm,
                    height = {self.v-ruler.get-total-size i},
                    style-class = "vertical"
||--                    ,background =||DEBUG
||--                    border-width = 1in/300,
||--                      {if i mod 2 == 0 then "lime" else "orange"}
                }
            {self.v-spacers.append spacer}
            {super.add spacer,
                top = self.row-edges[i*2], bottom = self.row-edges[(i + 1)*2],
                left = {self.left}, right = self.left-edge
            }
        }
     else
        {for spacer key si in self.v-spacers do
            set spacer.height =
                {self.v-ruler.get-total-size si}
        }
    }
  }

  {method public open {refresh-resizers}:void
    ||FIXME: Could make this a RefreshMixin and have this override update
    {if-non-null resizer = self.h-resizer then
        {resizer.refresh}
    }
    {if-non-null resizer = self.v-resizer then
        {resizer.refresh}
    }
  }

  || Override
  {method public open {clear}:void
    {self.clear-h-spacers}
    {self.clear-v-spacers}
    {super.clear}
    {if-non-null resizer = self.h-resizer then
        {resizer.clear}
    }
    {if-non-null resizer = self.v-resizer then
        {resizer.clear}
    }
  }

  || Override
  || Insert or delete rows, but only insofar as they are visible in self.
  || first and count are model coordinates. The model is updated separately,
  || before calling this method.
  {method public open {insert-rows 
                          first:int, count:int,
                          init-proc:#{proc-type {r:int, c:int}:Graphic} = null
                      }:void
    || Compute the first and last included in this grid, in positional coords
    def delete? = count < 0
    def (r0, r1) = {self.v-ruler.clip first, count}
    {if r0 >= 0 then
        let gcount:int = r1 - r0 + 1
        {for ri = first below self.rows do
            {for ci = 0 below self.cols do
                {type-switch self.cells[ri, ci]
                 case gc:GridCell do
                    {inc gc.row, count}
                    set gc.stale? = true
                }
            }
        }

        {if delete? then
            set gcount = -gcount
        }
||--        {dump "insert-rows", self.name, first, count, r0, r1, gcount}
        {super.insert-rows r0, gcount, init-proc = init-proc}

        || Re-insert all of the spacers
||--        {self.clear-v-spacers} || Force full re-build
        {self.refresh-v-spacers}
    }
    || Refresh synchronously to create the GridCells needed
    {self.refresh}
  }


  {method public open {reveal-rows 
                          first:int, count:int,
                          init-proc:#{proc-type {r:int, c:int}:Graphic} = null
                      }:void
    || Compute the first and last included in this grid, in positional coords
    def delete? = count < 0
    def (r0, r1) = {self.v-ruler.clip first, count}
    {if r0 >= 0 then
        let gcount:int = r1 - r0 + 1

        {if delete? then
            set gcount = -gcount
        }
||--        {dump "insert-rows", self.name, first, count, r0, r1, gcount}
        {super.insert-rows r0, gcount, init-proc = init-proc}

        || Re-insert all of the spacers
||--        {self.clear-v-spacers} || Force full re-build
        {self.refresh-v-spacers}
    }
    || Refresh synchronously to create the GridCells needed
    {self.refresh}
  }

  || Override
  {method public open {insert-cols 
                          first:int, count:int,
                          init-proc:#{proc-type {r:int, c:int}:Graphic} = null
                      }:void

    def delete? = count < 0
    def (c0, c1) = {self.h-ruler.clip first, count}
    {if c0 >= 0 then
        let gcount:int = c1 - c0 + 1
        {for ri = 0 below self.rows do
            {for ci = first below self.cols do
                {type-switch self.cells[ri, ci]
                 case gc:GridCell do
                    {inc gc.col, count}
                }
            }
        }

        {if delete? then
            set gcount = -gcount
        }
||--        {dump "insert-cols", self.name, first, count, c0, c1, gcount}
        {super.insert-cols c0, gcount, init-proc = init-proc}

        || Re-insert all of the spacers
||--        {self.clear-h-spacers} || Force full re-build
        {self.refresh-h-spacers}
    }
    || Refresh synchronously to create the GridCells needed
    {self.refresh}
  }


  {method public open {reveal-cols 
                          first:int, count:int,
                          init-proc:#{proc-type {r:int, c:int}:Graphic} = null
                      }:void

    def delete? = count < 0
    def (c0, c1) = {self.h-ruler.clip first, count}
    {if c0 >= 0 then
        let gcount:int = c1 - c0 + 1

        {if delete? then
            set gcount = -gcount
        }
||--        {dump "reveal-cols", self.name, first, count, c0, c1, gcount}
        {super.insert-cols c0, gcount, init-proc = init-proc}

        || Re-insert all of the spacers
||--        {self.clear-h-spacers} || Force full re-build
        {self.refresh-h-spacers}
    }
    || Refresh synchronously to create the GridCells needed
    {self.refresh}
  }

  || Override
  {method protected open {handle-observer-message
                             sender:Observable,
                             message:any
                         }:void
      {type-switch sender
       case r:HorizontalRuler do
          {if r == self.h-ruler then
              {type-switch message
               case resizer:RulerResizer do
                  || If this grid has no resizer, it needs to track the resizer
                  || the user is dragging.
                  def cpos = resizer.resizer-pos
||--                  {dump self.name, cpos, resizer.state}
                  {if cpos < 0 or cpos >= self.cols then
                      || Adjusting a column not shown in this grid
                      {return}
                  }
                  def old-width = {self.get-column-width cpos}
                  {if old-width == 0m then
                      {return}
                  }
                  def new-width = {max 1mm, resizer.new-x + old-width}
                  let x:Distance = 0m
                  {for i = 0 below cpos do
                      {inc x, {self.get-column-width i}}
                  }
||--                  {dump resizer.state, cpos, old-width/1pt, new-width/1pt, x/1pt}
                  
                  {switch resizer.state
                   case "press" do ||""
                      || Insert a graphic to track the cursor
                      set self.h-resize-spacer.width =
                          x + new-width
||--                          {make-elastic
||--                              compress-order = min-size-stretch-order,
||--                              minimum-size = x + new-width,
||--                              preferred-size = x + new-width
||--                          }
                      {self.add
                          self.h-resize-spacer,
                          left = self.col-edges[0],
                          right = self.h-resize-fiducial,
                          top = {self.top}
                      }
                      {self.add
                          self.h-resize-rule,
                          left = self.h-resize-fiducial,
                          top = {self.top},
                          bottom = {self.bottom}
                      }
                   case "move" do ||""
                      || Adjust the line to track the new cursor position
                      set self.h-resize-spacer.width =
                          x + new-width
||--                              {make-elastic
||--                                  compress-order = min-size-stretch-order,
||--                                  minimum-size = x + new-width,
||--                                  preferred-size = x + new-width
||--                              }
                   case "release" do ||""
                      || Remove the graphic that tracks the cursor
                      {self.h-resize-rule.detach}
                      {self.h-resize-spacer.detach}
                   else
                      {error "Internal error: unrecognized message '%s'", message}
                  }
               else
                  || Sender is our h-ruler, but not a resize
                  {for cpos = 0 below self.cols do
                      set self.h-spacers[cpos].width =
                          {r.get-spacer-size cpos}
                  }
              }
          }
       case r:VerticalRuler do
          {if r == self.v-ruler then
              {type-switch message
               case resizer:RulerResizer do
                  || If this grid has no resizer, it needs to track the resizer
                  || the user is dragging.
                  def rpos = resizer.resizer-pos
||--                  {dump self.name, gri, resizer.state}
                  {if rpos < 0 or rpos >= self.rows then
                      || Adjusting a column not shown in this grid
                      {return}
                  }
                  def old-height = {self.get-row-height rpos}
                  {if old-height == 0m then
                      {return}
                  }
                  def new-height = {max 1mm, resizer.new-y + old-height}
                  let x:Distance = 0m
                  {for i = 0 below rpos do
                      {inc x, {self.get-row-height i}}
                  }
||--                  {dump resizer.state, rpos, old-height/1pt, new-height/1pt, x/1pt}
                  
                  {switch resizer.state
                   case "press" do ||""
                      || Insert a graphic to track the cursor
                      set self.v-resize-spacer.height =
                          x + new-height
||--                          {make-elastic
||--                              compress-order = min-size-stretch-order,
||--                              minimum-size = x + new-height,
||--                              preferred-size = x + new-height
||--                          }
                      {self.add
                          self.v-resize-spacer,
                          top = self.row-edges[0],
                          bottom = self.v-resize-fiducial,
                          left = {self.left}
                      }
                      {self.add
                          self.v-resize-rule,
                          top = self.v-resize-fiducial,
                          left = {self.left},
                          right = {self.right}
                      }
                   case "move" do ||""
                      || Adjust the line to track the new cursor position
                      set self.v-resize-spacer.height =
                          x + new-height
||--                              {make-elastic
||--                                  compress-order = min-size-stretch-order,
||--                                  minimum-size = x + new-width,
||--                                  preferred-size = x + new-width
||--                              }
                   case "release" do ||""
                      || Remove the graphic that tracks the cursor
                      {self.v-resize-rule.detach}
                      {self.v-resize-spacer.detach}
                   else
                      {error "Internal error: unrecognized message '%s'", message}
                  }
               else
                  || Sender is our v-ruler, but not a resize
                  {for rpos = 0 below self.rows do
||--                      {dump self.name, rpos, self.v-offset}
                      set self.v-spacers[rpos].height =
                          {r.get-spacer-size rpos}
                  }
              }
          }
      }
  }
}


{doc-next
    {purpose
        A rectangular grid of cells with automatic calculations invoked
        when cell values are changed.
    }
    {notes
        {bold This is a preview release. The API is subject to change}
    }
}
{define-class public open Worksheet
  {inherits
    SelectionContext, ContainerDragScroller, CommandContext,
    StandardActiveTraversalContainer, Observer,
    RefreshMixin
  }

  {doc-next
    {purpose
        Default height for a newly created row, if not specified
        by {docref Worksheet.v-ruler-spec}.
    }
  }
  {local-option public default-row-height:any = 18pt
  }

  {doc-next
    {purpose
        Default width for a newly created column, if not specified
        by {docref Worksheet.h-ruler-spec}.
    }
  }
  {local-option public default-column-width:any = 60pt
  }


  {doc-next
    {purpose The number of rows at the left of the {ctext Worksheet}
        that do not scroll horizontally if the {ctext Worksheet} has
        scrollbars.
    }
  }
  {local-option public frozen-rows:int = 0
    {if frozen-rows < 0 then
        {error {hlformat "frozen-rows=%s: must not be negative", frozen-rows}}
    }
    {self.update}
  }

  {doc-next
    {purpose The number of columns at the top of the {ctext Worksheet}
        that do not scroll vertically if the {ctext Worksheet} has
        scrollbars.
    }
  }
  {local-option public frozen-cols:int = 0
    {if frozen-cols < 0 then
        {error {hlformat "frozen-rows=%s: must not be negative", frozen-cols}}
    }
    {self.update}
  }

  {getter public open {visible-frozen-rows}:int
    {return self.v-ruler-top.visible-count}
  }

  {getter public open {visible-frozen-cols}:int
    {return self.h-ruler-left.visible-count}
  }

  {getter public open {visible-scrolling-rows}:int
    {return self.v-ruler-main.visible-count}
  }

  {getter public open {visible-scrolling-cols}:int
    {return self.h-ruler-main.visible-count}
  }

  || Set to 0m to make the row selectors disappear
  {doc-next
    {purpose The width of the row selectors a the far left
        of the grid.
    }
  }
  {local-option public row-selector-width:Distance = 5pt
    {self.update}
  }

  || Set to 0m to make the column selectors disappear
  {doc-next
    {purpose The height of the column selectors a the top
        of the grid.
    }
  }
  {local-option public column-selector-height:Distance = 5pt
    {self.update}
  }

  {doc-next
    {purpose
        If true, the {docref Worksheet} will have scrollbars if the
        width or height is constrained so that not all cells can be
        visible at once.
    }
  }
  {local-option public scrollable?:bool = true
    {self.make-grid-frames}
  }

  ||FIXME: these should be local options, and/or set in the style sheet
  def public readonly-bg = "#f0f0f0" asa FillPattern
  def public editable-bg = "white" asa FillPattern
  def public header-bg = "#f0f0f070" asa FillPattern
  def public header-color = "#ccc" asa FillPattern

||--  ||FIXME: is this a good idea?
||--  {nonlocal-option public grid-line-color:FillPattern
||--||--    set self.border-color = grid-line-color
||--  }

  {doc-next
    {purpose The model associated with this {docref Worksheet}.}
  }
  field public-get protected-set model:WorksheetModel =
      {uninitialized-value-for-type WorksheetModel}

  ||FIXME: move these to the model ASAP
  {doc-next
    {purpose Specifies the widths of the columns.}
  }
  field public-get protected-set h-ruler-spec:RulerSpec =
      {uninitialized-value-for-type RulerSpec}

  {doc-next
    {purpose Specifies the heights of the rows.}
  }
  field public-get protected-set v-ruler-spec:RulerSpec =
      {uninitialized-value-for-type RulerSpec}

  {doc-next
    {purpose A {docref VerticalRuler} for the frozen rows.}
  }
  field public-get protected-set v-ruler-top:VerticalRuler =
      {uninitialized-value-for-type VerticalRuler}

  {doc-next
    {purpose A {docref VerticalRuler} for the scrollable rows.}
  }
  field public-get protected-set v-ruler-main:VerticalRuler =
      {uninitialized-value-for-type VerticalRuler}

  {doc-next
    {purpose A {docref HorizontalRuler} for the frozen columns.}
  }
  field public-get protected-set h-ruler-left:HorizontalRuler =
      {uninitialized-value-for-type HorizontalRuler}

  {doc-next
    {purpose A {docref HorizontalRuler} for the scrollable columns.}
  }
  field public-get protected-set h-ruler-main:HorizontalRuler =
      {uninitialized-value-for-type HorizontalRuler}

  {doc-next
    {purpose
        The row containing the current cell.
        (See {docref Worksheet.active?})
    }
  }
  field public-get protected-set active-row:int

  {doc-next
    {purpose
        The column containing the current cell.
        (See {docref Worksheet.active?})
    }
  }
  field public-get protected-set active-col:int

  || Selection support
  field protected _selection:WorksheetSelection
  field protected selecting?:bool = false
  field protected point-row:int
  field protected point-col:int
  field protected anchor-row:int
  field protected anchor-col:int
  field private shift?:bool = false

  || for context menu handling
  field private _context-row:int = -2
  field private _context-column:int = -2


  || The main container
  field protected grid:Grid

  || Containers for the four independently scrolling parts
  field protected top-left-frame:#Frame
  field protected top-frame:#Frame
  field protected left-frame:#Frame
  field protected main-frame:#Frame

  field protected top-left-grid:#WorksheetGrid
  field protected top-grid:#WorksheetGrid
  field protected left-grid:#WorksheetGrid
  field protected main-grid:#WorksheetGrid


  ||FIXME: Enough for any single-line control (but smaller would be better!)
  ||FIXME: use the existing cell-margin nonlocal option
||--  field protected _cell-margin:PixelDistance = 4px

  field protected last-frozen-cols:int = -1
  field protected last-frozen-rows:int = -1

  field protected last-row-map:{Array-of int} =
      {uninitialized-value-for-type {Array-of int}}

  field protected last-col-map:{Array-of int} =
      {uninitialized-value-for-type {Array-of int}}

  field private last-row-edit-count:int
  field private last-col-edit-count:int
  field private argn:int
  field private irows:int
  field private model?:bool
  field private row-heights:Array = {Array}
  field private col-widths:Array = {Array}

  field protected vmid:GridFiducial
  field protected hmid:GridFiducial

  {doc-next
    {purpose
        Create a new {docref Worksheet}.
    }
    {notes
        {bold This is a preview release. The API is subject to change}
    }
    {details
        This constructor is designed to allow the {ctext Worksheet} to
        be created in the declarative style so far as possible. A
        number of keyword arguments can be used in the constructor,
        some of which can be repeated (this is similar to {docref
        Canvas.add}). In addition, the handling of non-keyword
        arguments will depend on the data type.

        The first one or two parameters will define the data model and
        can be either a {docref WorksheetModel} or a pair of integers
        representing the number of rows and number of columns in the
        model.

        The next argument may be a call to the procedure {docref
        widths}, which returns a {docref RulerSpec}. This will
        determine the widths of the columns. If it is ommitted, or
        if it doesn't specify a width for every column, the value
        of {docref Worksheet.default-column-width} is used. In a
        similar way, row heights can be specified by calling
        {docref heights}, and the {docref Worksheet.default-row-height}
        is used for the height of a row that is not otherwise
        specified.

        The {param scrollable?} argument specifies whether or not
        the {ctext Worksheet} will have internal scrollbars. If it is
        true, and you constrain the width or height of the worksheet
        scrollbars will appear as necessary. If there are 
        {docref-abbr Worksheet.frozen-rows} or
        {docref-abbr Worksheet.frozen-cols}, they will be outside
        of the scrollable area.

        Additional positional arguments define the cells in the
        worksheet.  Use {param row \= int} and {param col \= int} to
        specify the insertion position. The keyword arguments {param
        rowspan \= int} and {param colspan \= int} can also be used to
        set a rowspan or colspan for the next positional argument when
        it is inserted into the worksheet.

        After a value is inserted, the insertion column position is
        automatically advanced to the next available cell,
        taking {param colspan} into account.

        The keywords {param row-height} and {param column-width} are
        used to specify the height of the row or width of the column
        at the current insertion position. These values will replace
        values in the ruler, if one was specified earlier.

        The keyword {param cell} allows a {docref CellRef} determine
        the location where the next cell will be inserted.  The
        keyword argument {param cell \= String} is handled by
        calling {ctext self.model.get-ref} to obtain a {docref
        CellRef}. You can also use {param cell \= CellRef} to specify
        a {ctext CellRef} you have already constructed or obtained by
        calling {docref WorksheetModel.get-ref}. This is useful when
        you have set a variable to a {ctext CellRef} and want to
        define the cell at that location.

        Any other keyword argument will be interpreted as an option
        setting for the {ctext Worksheet}.

        The non-keyword arguments are handled according to their
        data type.

        The calls {docref row-group} and {docref col-group} return
        a {docref GroupProto}. These are used to define the hierarchy
        of row and column groups. They must be specified from the top
        down, with the highest level {ctext row-group}s in column 0
        and the highest level {ctext col-group}s in row 0.

        The following calls are used to insert a cell of a particular
        type. They are all just different ways to create a
        {docref WksCellSpec}, and any of they keyword arguments
        accepted by the {ctext WksCellSpec} constructor can be passed
        to these procedures. Any options that are valid on a {docref
        Graphic} can also be passed to these procedures. They will be
        applied to the cell contents when the cell is created or
        updated.

        {docref currency-cell}: The cell will use the {docref
        CurrencyDomain} and be right justified.

        {docref formula-cell}: The cell contains a formula.
        The domain is {docref WorksheetModel.double-domain} by default.

        {docref editable-cell}: A cell that will be editable when
        the user clicks on it.

        {docref cell-spec}: Used when none of the above procedures
        is applicable.

        If a non-keyword argument is an event handler, it is attached
        to the {ctext Worksheet}.

        Any other argument is used as the value of the next available
        cell. Such a cell will not be editable, and will have a domain
        chosen according to the data type.

        {bold Worksheet Example}

        The following example defines a simple worksheet. The numbers
        in the Hours column are editable. They are added up to get
        the value in the total cell.

        The first Date field is editable. The remaining dates, and
        the names of the days, are computed from the value you choose.

        The line items are grouped under the headings. Click the
        small triangle to expand and contract the group.

        The formulas use relative cell references so the same formulas
        can be used on each line. Note that the formula for column 2
        has to be entered before the formula for column 1, because
        formulas are computed in the order that they are added.

        At the bottom of the worksheet there is a button that will
        call {docref WorksheetModel.get-data} and display the result.
        Note that only editable cells are captured in the JSON
        representation. Other cells will be recomputed when the data
        is restored (using {docref WorksheetModel.put-data}).
    }
    {paragraph
    {example
        title = "Weekly Time Sheet Example",
        {import * from CURL.IO.JSON}
        {import * from COM.CURL.EXT.WORKSHEET}
        || A procedure to sum a range of cells
        {def sum =
            {proc {dest:DataRef, src:DataRef}:void
                let sum:double = 0.0
                {for v in src do
                    {inc sum, {if-non-null v then v asa double else 0.0}}
                }
                {dest.set-value sum}
            }
        }

        || A procedure to compute the next day from a cell containing a date
        {def next-day =
            {proc {dest:DataRef, src:DataRef}:void
                {dest.set-value {src.get-value} + 1d}
            }
        }

        || A procedure to compute the day name from a cell containing a date
        {def day-name =
            {proc {dest:DataRef, src:DataRef}:void
                {dest.set-value
                    ({src.get-value} asa DateTime).info.locale-weekday
                }
            }
        }

        || A procedure that concatenates any number of cell values
        {def concat =
            {proc {dest:DataRef, ...:DataRef}:void
                def buf = {StringBuf}
                {for r in ... do
                    {buf.concat {r.get-String}}
                }
                {dest.set-value {buf.to-String}}
            }
        }

        || A cell with a formula to compute the next day from the cell above
        {def next-date-cell =
            {formula-cell
                domain = WorksheetModel.date-domain, next-day, {RelativeCellRef -1, 0}
            }
        }

        || A cell with a formula to compute the day name from the cell to the right
        {def day-cell =
            {formula-cell domain = String, day-name, {RelativeCellRef 0, 1}}}

        {Worksheet
            10, 6,
            default-column-width = 0.75in,
            {widths 1.75in, 1.25in, 1.25in},
            colspan = 2, {bold Example Worksheet},

            row = 1, col = 0, {row-group 6},
            {formula-cell domain = String, 
                concat, {ValueRef "Week of "}, {RelativeCellRef 1, 2}
            },
            "Day", "Date", {cell-spec halign = "right", "Hours"},

            row = 2, col = 1,
            {formula-cell domain = String, day-name, {RelativeCellRef 0, 1}},
            {editable-cell {DateTime.date "2010-10-11"}},
            {editable-cell halign = "right", 7},

            row = 3,
            col = 2, next-date-cell,
            col = 1, day-cell,
            col = 3, {editable-cell halign = "right", 9},

            row = 4,
            col = 2, next-date-cell,
            col = 1, day-cell,
            col = 3, {editable-cell halign = "right", 8},

            row = 5, 
            col = 2, next-date-cell,
            col = 1, day-cell,
            col = 3, {editable-cell halign = "right", 9},

            row = 6,
            col = 2, next-date-cell,
            col = 1, day-cell,
            col = 3, {editable-cell halign = "right", 4},

            row = 7, col = 2,
            "Total:", {formula-cell halign = "right", sum, {Ref "D3:D7"}},

            row = 9, col = 0,
            {CommandButton
                label = "Show Json Data",
                {on e:Action at cb:CommandButton do
                    {type-switch cb.selection-context
                     case wks:Worksheet do
                        {popup-message
                            title = "Time Sheet Data",
                            {Frame margin = 6pt,
                                text-preserve-whitespace? = true,
                                {JsonValue-to-String 
                                    {wks.model.get-data}, prettify? = true
                                }
                            }
                        }
                    }                    
                }
            }
        }
    }
    }
    ||FIXME: Does it make sense to have these clauses?
||--    {parameter {italic model:WorksheetModel}, If a {ctext WorksheetModel}
||--        is passed as the first argument, it is used as the data
||--        model. Otherwise the first two parameters must be {param
||--        row:int} and {param col:int}.
||--    }
||--    {parameter cs:WksCellSpec, Specifies the contents of a cell}
  }
  {constructor public {default
                          scrollable?:bool = false,
                          ...
                      }
    || Initialize the base classes
    {construct-super.RefreshMixin}
    {construct-super.ContainerDragScroller}
    {construct-super.SelectionContext}
    {construct-super.Observer}


    || Initialize the data structures that hold items passed in as rest args
    set self.grid =
        {Grid
            horigin = 0.0, vorigin = 0.0
        }

    || Fiducials to split the outermost grid
    set self.vmid =
        {self.grid.make-fiducial orientation = Orientation.vertical}
    set self.hmid =
        {self.grid.make-fiducial orientation = Orientation.horizontal}

    {self.add self.grid}

    || This is where the rest args get processed, so the grid must be ready
    {construct-super.StandardActiveTraversalContainer
        vstretch? = true, hstretch? = true,
        _style-element = "Worksheet",
        {splice ...}
    }
    {if self.v-ruler-spec == {uninitialized-value-for-type RulerSpec} then
        set self.v-ruler-spec =
            {RulerSpec Orientation.vertical, self.frozen-rows}
     else
        set self.h-ruler-spec.split-count = self.frozen-rows
    }
    {for i = 0 below self.row-heights.size step 2 do
        def ri = self.row-heights[i] asa int
        {self.v-ruler-spec.get-spec-size ri, self.default-row-height}
        {self.v-ruler-spec.set-spec-size ri, self.row-heights[i + 1]}
    }

    {if self.h-ruler-spec == {uninitialized-value-for-type RulerSpec} then
        set self.h-ruler-spec =
            {RulerSpec Orientation.horizontal, self.frozen-cols}
     else
        set self.h-ruler-spec.split-count = self.frozen-cols
    }
    {for i = 0 below self.col-widths.size step 2 do
        def ci = self.col-widths[i] asa int
        {self.h-ruler-spec.get-spec-size ci, self.default-column-width}
        {self.h-ruler-spec.set-spec-size ci, self.col-widths[i + 1]}
    }

    set self.scrollable? = scrollable?

||--    {self.refresh-rulers}
    {if self.top-left-grid == null then
        {self.make-grid-frames}
    }

    {if self.model == {uninitialized-value-for-type WorksheetModel} then
        {error 
            {hlmessage You must pass a WorksheetModel to the constructor,
                or the first two arguments must be integers specifying
                the number of rows and columns.
            }
        }
     else
        {self.observe self.model}
    }
    set self._selection = {WorksheetSelection.empty self}
    set self.selection-context = self

    || Start at the first traversable
    set self.active-row = self.model.rows - 1
    set self.active-col = self.model.cols - 1
    set (self.active-row, self.active-col) = {self.find-next-active}

    {after 0s do
        {self.model.refresh}
        {self.handle-event {SelectionChanged}}
    }        
  }

  {doc-next
    {purpose
        Return true if the cell at the specified row and column is the
        active cell.
    }
  }
  {method public open {active? row:int, col:int}:bool
    {return
        row == self.active-row and
        col == self.active-col
    }
  }

  {method protected open {refresh-rulers}:void
||--    def r1 = {self.model.row-tree.map-index-to-position self.frozen-rows}
||--    def r2 = {self.model.row-tree.map-index-to-position self.model.rows}
||--    def c1 = {self.model.col-tree.map-index-to-position self.frozen-cols}
||--    def c2 = {self.model.col-tree.map-index-to-position self.model.cols}

    {if self.v-ruler-main == {uninitialized-value-for-type VerticalRuler} then
        set self.v-ruler-top = {VerticalRuler self, 0}
        set self.v-ruler-main = {VerticalRuler self, 1}
        set self.h-ruler-left = {HorizontalRuler self, 0}
        set self.h-ruler-main = {HorizontalRuler self, 1}
    else
        {self.v-ruler-top.refresh}
        {self.v-ruler-main.refresh}
        {self.h-ruler-left.refresh}
        {self.h-ruler-main.refresh}
    }
  }

  {method protected open {make-grid-frames}:void
    set self.top-left-frame =
        {self.make-grid-frame false, self.top-left-frame}
    set self.top-left-frame.opaque-to-events? = true
    {self.grid.add self.top-left-frame,
        top = {self.grid.top}, bottom = self.hmid,
        left = {self.grid.left}, right = self.vmid
    }

    set self.top-frame =
        {self.make-grid-frame
            self.scrollable?, self.top-frame,
            name = "top-frame",
            always-disable-hscroll? = true,
            shrink-hscroll? = true,
            expanded-hscroll-bounds? = true,
            vscroll? = false
||--                             always-disable-vscroll? = true,
||--                             shrink-vscroll? = false,
||--                             expanded-vscroll-bounds? = true
        }
    {type-switch self.top-frame
     case top-frame:ScrollBox do
||--        set {top-frame.get-vscroll}.height = {make-compressible}
    }
    {self.grid.add self.top-frame,
        top = {self.grid.top}, bottom = self.hmid,
        left = self.vmid, right = {self.grid.right}
    }

    set self.left-frame =
        {self.make-grid-frame
            self.scrollable?, self.left-frame,
            name = "left-frame",
            always-disable-hscroll? = true,
            shrink-hscroll? = true,
            expanded-hscroll-bounds? = true,
||--                              hscroll? = false,
            always-disable-vscroll? = true,
            shrink-vscroll? = true,
            expanded-vscroll-bounds? = true
        }
    || Adjust scrollboxes if necessary
    {type-switch self.left-frame
     case left-frame:ScrollBox do
        set {left-frame.get-hscroll}.visible? = false
    }
    {self.grid.add
        self.left-frame,
        top = self.hmid, bottom = {self.grid.bottom}, 
        left = {self.grid.left}, right = self.vmid
    }

    set self.main-frame =
        {self.make-grid-frame
            self.scrollable?, self.main-frame,
            shrink-vscroll? = false,
            shrink-hscroll? = false,
            "main-graphic" ||DEBUG
        }
    {type-switch self.main-frame
     case main-frame:ScrollBox do
        def main-vscroll = {main-frame.get-vscroll}
        {main-vscroll.add-event-handler
            {on e:Adjustment at sb:Scrollbar do
                {(self.left-frame asa ScrollBox).scroll-to
                    x = 0m,
                    y = main-frame.vertical-position
                }
            }
        }

        def main-hscroll = {main-frame.get-hscroll}
        {main-hscroll.add-event-handler
            {on e:Adjustment at sb:Scrollbar do
                {(self.top-frame asa ScrollBox).scroll-to
                    x = main-frame.horizontal-position,
                    y = 0m
                }
            }
        }
    }
    {self.grid.add self.main-frame,
        top = self.hmid, bottom = {self.grid.bottom},
        left = self.vmid, right = {self.grid.right}
    }
  }

  {doc-next
    {purpose Create or replace one of the four inner frames.}
    {details
        The {docref Worksheet} is displayed in four separate frames
        to separate the scrolling rows and columns from the frozen
        rows and columns. If a quadrant is scrollable, the "frame"
        is a {docref ScrollBox} otherwise it is a {docref Frame}.
    }
  }   
  {method protected open {make-grid-frame scroll?:bool, f:#Frame, ...}:Frame
    let child:#Graphic = null
    {if-non-null f then
        {f.detach}
        {if-non-null fl = f.child then
            set child = fl.graphic
        }
    }
    def frame =
        {if scroll? then
            {ScrollBox
                valign = "top", halign = "left",
                {splice ...}
            }
         else
            {Frame valign = "top", halign = "left",
                style-class = "grid-frame"
            }
        }
    {if-non-null child then
        {frame.add child}
    }
    {return frame}
  }

  field protected insert-row:int = 0
  field protected insert-col:int = 0
  field protected insert-rowspan:int = 1
  field protected insert-colspan:int = 1

  ||FIXME: need to look out for cells that span multiple rows/cols
  ||maybe increment to first cell after rowspan and colspan
  || Need to specify the correct behavior and implement it. 
  || Right now we only increment the column position
  {method private {increment-insertion-pos}:void
    def cv = self.model.vals[self.insert-row, self.insert-col]
    {inc self.insert-col, cv.colspan}
    {if self.insert-col >= self.model.cols then
||--        set self.insert-col = 0
||--        {inc self.insert-row, cv.rowspan}
    }
    set self.insert-rowspan = 1
    set self.insert-colspan = 1
  }

  {method private {verify-cell-empty}:void
    {if self.insert-row < self.model.rows and
        self.insert-col < self.model.cols
     then
        def cv = self.model.vals[self.insert-row, self.insert-col]
        {if cv.value != null then
            {error
                {hlformat
                    "Cell at row=%1!s! col=%2!s! already contains value='%3!s!'",
                    self.insert-row, self.insert-col, cv.value
                }
            }
        }
    }
  }

  || Add something to the current cell location
  {method public open {non-keyword-init-arg a:any}:void
    let editable?:bool = false
    let rowspan:int = self.insert-rowspan
    let colspan:int = self.insert-colspan
    let domain:#Domain
    let value:any = a
    let ui-spec:any = null
    let args:Arguments = {Arguments}
    let refs:#{Array-of DataRef} = null
    {inc self.argn}

    {type-switch value
     case eh:EventHandler do
        {super.non-keyword-init-arg eh}
        {return}
     case i:int do
        {if self.argn == 1 then
            set self.irows = i
            {return}
         elseif self.argn == 2 then
            {self.init-model {WorksheetModel self.irows, i}}
            {return}
||--         else
||--            {error
||--                {hlmessage The first two arguments may be of type int
||--                    to specify the model rows and columns.
||--                }
||--            }
        }
     case model:WorksheetModel do
        {if self.model? then
            {error {hlmessage A model has already been specified}}
        }
        {if self.irows > 0 then
            {error {hlmessage A model should not be specified after the
                       rows have been specified.
                   }
            }
        }
        {self.init-model model}
        {return}

     case cs:WksCellSpec do
        set editable? = cs.editable?
        set rowspan = cs.rowspan
        set colspan = cs.colspan
        set domain = cs.domain
        set value = cs.v
        set ui-spec = cs.ui-spec
        set args = cs.args
        set refs = cs.refs

     case ruler:RulerSpec do
        {if ruler.orientation == Orientation.horizontal then
            set self.h-ruler-spec = ruler
         else
            set self.v-ruler-spec = ruler
        }
        {return}
    }

    {type-switch value
     case gp:GroupProto do
        {self.insert-group self.insert-row, self.insert-col, gp}

     case erf:EmbeddedRecordForm do
        {self.verify-cell-empty}
        {self.model.embedded-forms.append
            {EmbeddedFormInfo erf, self.insert-row, self.insert-col}
        }
        {self.init-cell
            self.insert-row, self.insert-col, value,
            domain = domain,
            rowspan = rowspan, colspan = colspan,
            editable? = editable?, args = args, refs = refs
        }
        {inc self.insert-row, 1}
        set self.insert-col = 0

     else
        {self.verify-cell-empty}
        {self.init-cell
            self.insert-row, self.insert-col, value,
            ui-spec = ui-spec, domain = domain,
            rowspan = rowspan, colspan = colspan,
            editable? = editable?, args = args, refs = refs
        }
        {self.increment-insertion-pos}
    }
  }

  {method protected open {keyword-init-arg key:String, value:any}:void
    {if key == "row" then ||""
        set self.insert-row = value asa int
     elseif key == "col" or key == "column" then ||""
        set self.insert-col = value asa int
     elseif key == "rowspan" then ||""
        set self.insert-rowspan = value asa int
     elseif key == "row-height" then ||""
        {self.row-heights.append self.insert-row}
        {self.row-heights.append value}
     elseif key == "column-width" then ||""
        {self.col-widths.append self.insert-col}
        {self.col-widths.append value}
     elseif key == "colspan" then ||""
        set self.insert-colspan = value asa int
     elseif key == "cell" then ||""
        let ref:#CellRef = null
        {type-switch value
         case cr:CellRef do
            set ref = cr
         case s:String do
            def sr = {self.model.get-ref s}
            {if sr isa CellRef then
                set ref = sr asa CellRef
             else
                {error 
                    {hlformat "Expected a CelLRef: '%s'", value}
                }
            }
         else
            {error 
                {hlformat "Unexpected argument: '%s'", value}
            }
        }
        def insert-cell = {CellRef self.model, self.insert-row, self.insert-col}
        def rref = {{non-null ref}.resolve insert-cell} asa CellRef
        set self.insert-col = rref.col
        set self.insert-row = rref.row
     else
        {super.keyword-init-arg key, value}
    }
  }

  {doc-next
    {purpose
        Insert a group specification at the indicated row and column.
    }
  }
  {method public open {insert-group row:int, col:int, gp:GroupProto}:void
    def cv = self.model.vals[row, col]
    {if gp.row? then
        set cv.rowspan = 
            {if gp.expanded? then
                gp.span
             else
                1
            }
        {self.model.row-tree.insert-group
            {GroupSpec
                true, col, row,
                row + gp.span - 1,
                expanded? = gp.expanded?
            }
        }
     else
        set cv.colspan =
            {if gp.expanded? then
                gp.span
             else
                1
            }
        {self.model.col-tree.insert-group
            {GroupSpec
                false, row, col,
                col + gp.span - 1,
                expanded? = gp.expanded?
            }
        }
    }
  }

  {doc-next
    {purpose Insert or delete rows in the worksheet.}
    {details
        Insert {param count} empty rows at the row indicated by
        {param first}, pushing existing rows down to make room. If
        count is negative, rows are removed.
    }
    {parameter first, The position where rows will be added or
        deleted. The value must range between 0 and the number of
        rows currently in the grid, or {docref ArrayBoundsException}
        will be thrown.
    }
    {parameter count, If positive, the number of rows to be
        added. If negative, the number of rows to be removed.
    }
  }
  {method public open {insert-rows first:int, count:int}:void
||--    {dump "insert-rows", first, count, self.model.rows}
    {self.check-invariants} ||qfix
    {if count == 0 then
        {return}
    }
    def cols = self.model.cols
    def rows = self.model.rows

    || Do this first or GridCells will acquire attributes from the wrong cells
    {self.model.insert-rows first, count}
    {self.v-ruler-spec.insert first, count, self.default-row-height}

||--    || If adding, update the model and rulers first
||--    {if count > 0 then
||--        {self.model.insert-rows first, count}
||--        {self.v-ruler-spec.insert first, count, self.default-row-height}
||--    }

    || Now update the individual grids
    {if-non-null g = self.top-left-grid then
        {g.note-insert-rows first, count}
    }
    {if-non-null g = self.top-grid then
        {g.note-insert-rows first, count}
    }
    {if-non-null g = self.left-grid then
        {g.note-insert-rows first, count}
    }
    {if-non-null g = self.main-grid then
        {g.note-insert-rows first, count}
    }
    
||--    || If deleting, update the model and rulers last
||--    {if false and count < 0 then
||--        {self.model.insert-rows first, count}
||--        {self.v-ruler-spec.insert first, count, self.default-row-height}
||--    }

    {self.check-invariants}
    {self.update}
  }

  {doc-next
    {purpose Insert or delete columns in the worksheet.}
    {details
        Insert {param count} empty columns at the column indicated by
        {param first}, pushing existing columns right to make room. If
        count is negative, columns are removed.
    }
    {parameter first, The position where columns will be added or
        deleted. The value must range between 0 and the number of
        columns currently in the grid, or {docref ArrayBoundsException}
        will be thrown.
    }
    {parameter count, If positive, the number of columns to be
        added. If negative, the number of columns to be removed.
    }
    {parameter init-proc, If cells are added, this procedure is called
        to provide the initial value for each cell.
    }
  }
  {method public open {insert-cols first:int, count:int}:void
    {if count == 0 then
        {return}
    }
    def cols = self.model.cols
    def rows = self.model.rows

    || If adding, update the model and rulers first
    {if count > 0 then
        {self.model.insert-cols first, count}
        {self.h-ruler-spec.insert first, count, self.default-column-width}
    }

    {if-non-null g = self.top-left-grid then
        {g.note-insert-cols first, count}
    }
    {if-non-null g = self.top-grid then
        {g.note-insert-cols first, count}
    }
    {if-non-null g = self.left-grid then
        {g.note-insert-cols first, count}
    }
    {if-non-null g = self.main-grid then
        {g.note-insert-cols first, count}
    }

    || If deleting, update the model and rulers last
    {if count < 0 then
        {self.model.insert-cols first, count}
        {self.h-ruler-spec.insert first, count, self.default-column-width}
    }

    {self.update}
  }

  {method public open {note-group-changing gs:GroupSpec, expanded?:bool}:void
    def first = gs.first + 1
    def last = gs.last
    let count:int = last - first + 1
    {if count <= 0 then
        {return}
    }

    {if not expanded? then
        set count = -count
    }
    {if gs.row? then
        {if-non-null g = self.top-left-grid then
            {g.reveal-rows first, count}
        }
        {if-non-null g = self.top-grid then
            {g.reveal-rows first, count}
        }
        {if-non-null g = self.left-grid then
            {g.reveal-rows first, count}
        }
        {if-non-null g = self.main-grid then
            {g.reveal-rows first, count}
        }
     else
        {if-non-null g = self.top-left-grid then
            {g.reveal-cols first, count}
        }
        {if-non-null g = self.top-grid then
            {g.reveal-cols first, count}
        }
        {if-non-null g = self.left-grid then
            {g.reveal-cols first, count}
        }
        {if-non-null g = self.main-grid then
            {g.reveal-cols first, count}
        }
    }
  }


  ||FIXME: keep this?
  || Add more things just the way you would in the constructor
  {method public open {add-items
                          ...
                      }:void
    {for (arg,k) in ... do
        {if-non-null k then
            {self.keyword-init-arg k, arg}
         else
            {self.non-keyword-init-arg arg}
        }
    }
  }


  || All arguments must be stored in the CellValue to ensure that the
  || UI can be properly rebuilt from a serialized version, etc.
  {doc-next
    {purpose Initialize a cell in the {docref Worksheet}.}
  }
  ||FIXME: more doc
  {method public open {init-cell
                          row:int, col:int,
                          value:any,
                          rowspan:int = 1, colspan:int = 1,
                          ui-spec:any = null,
                          domain:#Domain = null,
                          editable?:bool = false,
                          args:Arguments = {Arguments},
                          field-spec:#WksCellSpec = null,
                          init-proc:#{proc-type {r:#Record}:any} = null,
                          refs:#{Array-of DataRef} = null
                      }:void
    {if row + rowspan > self.model.rows then
        {error
            {hlformat
                "Item at row %1!s! with rowspan=%2!s! exceeds model size",
                row, rowspan
            }
        }
    }
    {if col + colspan > self.model.cols then
        {error
            {hlformat
                "Item at column %1!s! with colspan=%2!s! exceeds model size",
                col, colspan
            }
        }
    }

    def cv = self.model.vals[row, col]

    set cv.value = value
    set cv.ui-spec = ui-spec
    set cv.args = args
    set cv.editing? = false
    set cv.formula = null
    set cv.domain = domain
    set cv.dataref = null
    set cv.rowspan = {max cv.rowspan, rowspan}
    set cv.colspan = {max cv.colspan, colspan}
    set cv.field-spec = field-spec
    set cv.init-proc = init-proc
    set cv.editable? = editable?

    {if cv.ui-spec != null then
        set cv.editable? = true
    }
    || If it is not editable, lock it in that state
    set cv.locked? = not cv.editable?

    ||FIXME: need an extensible mechanism... at a minimum, a
    ||method on WksCellSpec so a subclass could be created...

    || non-null refs means inserting a Formula
    {if {proc? value} then
        {self.model.make-formula-at
            self.insert-row, self.insert-col,
            value asa CalcProc,
            cv.domain,
            {splice refs}
        }
        set cv.value = cv.domain.default-value
     else
        {type-switch value
         case vc:ValueControl do
            set cv.editable? = true
            set cv.editing? = true
            set cv.locked? = true
            set cv.value = vc.value-as-any
            set cv.ui-spec = vc
         case erg:EmbeddedRecordGrid do
            set erg.worksheet = self
            set cv.ui-spec = erg
         case ctl:Control do
            set cv.locked? = true
            set cv.ui-spec = ctl
         case erf:EmbeddedRecordForm do
            set cv.embedded-form = erf
            set erf.worksheet = self
            set domain = WorksheetModel.any-domain
            set cv.value = null
         case v:Visual do
            set cv.locked? = true
            set cv.editing? = v isa ActiveTraversor
            set cv.ui-spec = v
         case ref:DataRef do
            set cv.dataref = ref
            set cv.value = {ref.get-value}
        }
    }

    set cv.domain = {if-non-null domain then
                        domain
                     else
                        {WorksheetModel.get-default-domain cv.value}
                    }
  }

  {method public open {get-value row:int, col:int}:any
    def val = {self.model.get-value row, col}
||--    {dump "get-value", row, col, val}
    {return val}
  }


  {method public open {set-value row:int, col:int, val:any}:void
    def cv = self.model.vals[row, col]
    let nv:any = {cv.domain-value val}
    {if-non-null spec = cv.field-spec then
        {if-non-null rf = spec.form then
||--            {dump "rf.update"}
            || Use the data binding to update the underlying record
            {rf.update}
        }
    }
    {if nv != cv.value then
        {if-non-null ref = cv.dataref then
            {ref.set-value nv}
         else
            || Use model.set-value so a recalc will be scheduled
            {self.model.set-value row, col, val}
        }
    }
  }


  ||FIXME: optional-resizers
||--  {method public open {refresh-resizers}:void
||--    {if-non-null g = self.top-left-grid then
||--        set g.resizable-rows?  = self.resizable-rows?
||--        set g.resizable-cols?  = self.resizable-cols?
||--    }
||--    {if-non-null g = self.top-grid then
||--        set g.resizable-cols?  = self.resizable-cols?
||--    }
||--    {if-non-null g = self.left-grid then
||--        set g.resizable-rows?  = self.resizable-rows?
||--    }
||--  }

  || ensure that self.top-left-grid is a WorksheetGrid of the correct size
  {method private {refresh-top-left}:void
    def rows:int = self.visible-frozen-rows
    def cols:int = self.visible-frozen-cols

    {if self.top-left-grid == null then
        set self.top-left-grid =
            {WorksheetGrid
                self,
                rows, cols,
                name = "top-left-grid",
                self.h-ruler-left,
                self.v-ruler-top,
                h-resize? = true, v-resize? = true
            }
        {self.top-left-frame.add replace? = true, self.top-left-grid}
    }
    {if-non-null tlg = self.top-left-grid then
        {assert tlg.rows == rows}
        {assert tlg.cols == cols}
        {tlg.refresh}
    }
  }

  || Build the grid at the left containing frozen column cells
  || Strategy is to clear and rebuild if frozen-cols changes
  {method private {refresh-left}:void
    let rows:int = self.visible-scrolling-rows
    def cols = self.visible-frozen-cols

    {if self.left-grid == null then
        set self.left-grid =
            {WorksheetGrid 
                self,
                rows, cols,
                name = "left-grid",
                self.h-ruler-left,
                self.v-ruler-main,
                h-resize? = false,
                v-resize? = true
            }
        {self.left-frame.add replace? = true, self.left-grid}
    }
    {if-non-null left-grid = self.left-grid then
        {left-grid.refresh}
    }
  }

  {method private {refresh-top}:void
    def rows = self.visible-frozen-rows
    let cols:int = self.visible-scrolling-cols

    {if self.top-grid == null then
        set self.top-grid =
            {WorksheetGrid
                self,
                rows, cols,
                name = "top-grid",
                self.h-ruler-main,
                self.v-ruler-top,
                h-resize? = true, v-resize? = false
            }
        {self.top-frame.add replace? = true, self.top-grid}
    }
    {if-non-null top-grid = self.top-grid then
        {top-grid.refresh}
    }
  }

  {method private {refresh-main}:void
    def rows = self.visible-scrolling-rows
    def cols = self.visible-scrolling-cols

    {if self.main-grid == null then
        set self.main-grid =
            {WorksheetGrid
                self,
                rows, cols,
                name = "main-grid",
                self.h-ruler-main,
                self.v-ruler-main,
                h-resize? = false, v-resize? = false
            }
        {self.main-frame.add replace? = true, self.main-grid}
    }
    {if-non-null main-grid = self.main-grid then
        {main-grid.refresh}
    }
  }

  {method public open {rebuild-cell-grid}:void
    ||FIXME: clear grids, reset last-whatever to force a rebuild
    {self.refresh}
  }

  ||FIXME: Need to restart iteration if number of rows changes?
  {method protected open {init-embedded-forms}:void
    {for ci = 0 below self.model.cols do
        {for ri = 0 below self.model.rows do
            {if-non-null erf = self.model.vals[ri, ci].embedded-form then
                def n = {erf.insert-embedded-form ri, ci}
            }
        }
    }
  }

  || Override
  {method public open {refresh}:void
    def rows = self.model.rows
    def cols = self.model.cols
||--    {dump "Worksheet.refresh", rows, cols}

    || Figure out which cells are covered due to rowspan/colspan
    ||FIXME: do this in the model and incrementally
    {self.model.update-covered}

    {if self.last-row-edit-count != self.model.row-tree.edit-count
        or self.last-col-edit-count != self.model.col-tree.edit-count
        or self.frozen-cols != self.last-frozen-cols
        or self.frozen-rows != self.last-frozen-rows
||--        or self._refresh-requested?
     then
        def refresh-forms? = self.main-grid == null
        {self.refresh-rulers}
        {self.refresh-top-left}
        {self.refresh-top}
        {self.refresh-left}
        {self.refresh-main}
        {if refresh-forms? then
            {self.init-embedded-forms}
        }

        set self.last-row-edit-count = self.model.row-tree.edit-count
        set self.last-col-edit-count = self.model.col-tree.edit-count
        set self.last-frozen-rows = self.visible-frozen-rows + 1
        set self.last-frozen-cols = self.visible-frozen-cols + 1
    }

    {self.top-left-grid.refresh-resizers}
    {self.top-grid.refresh-resizers}
    {self.left-grid.refresh-resizers}
    {self.main-grid.refresh-resizers}
  }

  {doc-next
    {purpose
        Attach a cell in the proper quadrant of the {docref Worksheet}.
    }
  }
  {method public open {attach-cell
                          gc:GridCell
                      }:void
    def row = gc.row
    def col = gc.col
    def cv = self.model.vals[row, col]

||--    let gs:#GroupSpec = {self.model.row-tree.get-group col, row, row}
||--    {if gs == null then
||--        set gs = {self.model.col-tree.get-group row, col, col}
||--    }
||--    {if-non-null gs then
||--        {if gs.expanded? then
||--            {if gs.row? and gs.first == row then
||--                set cv.rowspan = gs.span
||--             elseif not gs.row? and gs.first == col then
||--                set cv.colspan = gs.span
||--            }
||--         else
||--            {if gs.row? then
||--                set cv.rowspan = 1
||--             else
||--                set cv.colspan = 1
||--            }
||--        }
||--    }

    def (grid, rpos, cpos) = {self.get-grid-coordinates row, col}
    ||FIXME: Should omit covered cells?
    {if ||true or 
        not cv.covered? then
        {grid.add-cell
            rpos, cpos, gc,
            rowspan = cv.rowspan, colspan = cv.colspan
        }
    }
  }

  {doc-next
    {purpose
        Determine which quadrant contains the cell at the specified
        row and column. Return it if it exists.
    }
  }
  {method public open {get-grid-cell
                          row:int, col:int
                      }:#GridCell
    {if self.main-grid == null then
        {return null}
    }
    def (g, gr, gc) = {self.get-grid-coordinates row, col}
    {return
        {if gr < 0 then
            null
         else
            g.cells[gr, gc] asa #GridCell
        }
    }
  }

||--  {getter public open {header-width}:Distance
||--    def margin = {self.any-to-Distance self.cell-margin}
||--    {return {min margin, 4pt}}
||--  }

  field private zero-width-notifier:SizeNotifier = {SizeNotifier false}

  {doc-next
    {purpose
        Return the {docref SizeNotifier} at the top of the specified
        column.
    }
  }
  {method public open {get-width-notifier
                          col:int
                      }:SizeNotifier
    def (g, gr, gc) = {self.get-grid-coordinates 0, col}
    {if gr < 0 then
        {return self.zero-width-notifier}
     else
        {return {non-null {g.h-ruler.get-notifier col}}}
    }
  }

  {doc-next
    {purpose
        Determine which quadrant contains the cell at the specified
        row and column. That {docref WorksheetGrid} and the position
        of the cell within it.
    }
  }
  {method public open {get-grid-coordinates
                          row:int, col:int
                      }:(grid:WorksheetGrid, rpos:int, cpos:int)
    def left? = {self.h-ruler-left.includes? col}
    def top? = {self.v-ruler-top.includes? row}
    def grid =
        {if left? then
            {if top? then
                self.top-left-grid
             else
                self.left-grid
            }
         else
            {if top? then
                self.top-grid
             else
                self.main-grid
            }
        }
    def rpos = {grid.v-ruler.get-position row}
    def cpos = {grid.h-ruler.get-position col}
    {return ({non-null grid}, rpos, cpos)}
  }


  {doc-next
    {purpose
        Called during construction to initialize the model.
    }
  }
  {method protected open {init-model model:WorksheetModel}:void
    set self.model = model
    set self.model? = true
    set self.last-row-map =
        {{self.model.row-tree.get-position-map self.model.rows}.clone}
    set self.last-col-map =
        {{self.model.col-tree.get-position-map self.model.cols}.clone}

||--    set self.cells = {new {ResizableArray-of GridCell},
||--                         self.model.rows, self.model.cols
||--                     }
  }

||--  {method protected open {make-col-header ci:int}:Frame
||--    ||FIXME: give it a style-element
||--    def sn = {Frame style-class = "col-header",
||--                 width = {make-elastic},
||--                 height = {make-elastic}
||--             }
||--    set sn.halign = "center"
||--    set sn.margin = self._cell-margin
||--    {sn.add replace? = true, {bold {format "%c", 'A' + ci}}}
||--    {return sn}
||--  }
||--
||--  {method protected open {make-row-header ri:int}:Frame
||--    let label:Visual = {bold {format "%s", ri + 1}}
||--    def sn = {Frame style-class = "row-header",
||--                 width = {make-elastic},
||--                 height = {make-elastic}
||--             }
||--    set sn.halign = "center"
||--    set sn.valign = "center"
||--    set sn.margin = self._cell-margin
||--    {sn.add label}
||--    {return sn}
||--  }

  {method private {check-cell-parms
                          row:int, row-count:int,
                          col:int, col-count:int
                      }:void
    {if row >= self.model.rows then
        {error {hlmessage Can't insert row beyond bottom edge}}
    }
    {if col >= self.model.cols then
        {error {hlmessage Can't insert colomn beyond right edge}}
    }
    {if row < 0 then
        {error {hlmessage Row index must be zero or more.}}
    }
    {if col < 0 then
        {error {hlmessage Column index must be zero or more.}}
    }
  }

  || Find any embedded forms that reference rsds and rebuild them.
  || If records are deleted, return so the scan can start over again
  {method private {adjust-embedded-forms
                      rsds:RecordSetDataSource, first-row:int
                  }:int
    let next-row:int = -1
    let rows:int = self.model.rows
    {for ri = first-row below self.model.rows do
        {for ci = 0 below self.model.cols do
            def cv = self.model.vals[ri, ci]
            {if-non-null erf = cv.embedded-form then
                {if erf.data-source == rsds then
                    {erf.insert-embedded-form ri, ci}
                    {if self.model.rows < rows then
                        set next-row = ri + 1
                     else
                        set rows = self.model.rows
                    }
                }
            }

            {if-non-null fs = cv.field-spec then
                {if-non-null rf = fs.form then
                    {if-non-null cr = rf.current-record then
                        set cv.value = cr[fs.v asa String]
                        {if-non-null gc = {self.get-grid-cell ri, ci} then
                            {if gc.data-binding-context == null then
                                set gc.data-binding-context = rf
                             else
                                {assert gc.data-binding-context == rf}
                            }
                            set gc.value = null
                        }
||--                        {dump "update from rsds", ri, ci, cv.value}
                    }
                }
            }
        }
        {if next-row >= 0 then
            {break}
        }
    }
    {return next-row}
  }

  {method protected open {handle-observer-message
                             sender:Observable,
                             message:any
                         }:void
||--    {dump sender, message, self}
    ||FIXME: need an interface to support this cleanly
    {super.handle-observer-message sender, message}
    {type-switch sender
     case rsds:RecordSetDataSource do
        let first-row:int = 0
        {while first-row >= 0 do
            set first-row = {self.adjust-embedded-forms rsds, first-row}
        }
    }
    {self.update}
  }


  {doc-next
    {purpose
        Request that the cell at the specified row and column become
        active when the worksheet is refreshed.
    }
  }
  {method public open {set-active row:int, col:int}:void
||--    {dump "set-active", row, col}
    {if self.active-row != row or self.active-col != col then
        set self.active-row = row
        set self.active-col = col
    }
  }

  {method private {traversable? cv:CellValue}:bool
    {if-non-null v = cv.value then
        {type-switch v
         case at:ActiveTraversor do
            {return at.takes-focus?}
         case v:Visual do
            {return false}
        }
    }
    {return cv.editable?}
  }

  {doc-next
    {purpose
        Find the next editable cell relative to the current active cell
        and request that it become active.
    }
  }
  {method public open {find-next-active forward?:bool = true}:(row:int, col:int)
    {if forward? then
||--        {dump forward?, self.active-row, self.active-col}
        let first-col:int = self.active-col + 1
        || Look for an editable cell after the current cell
        {for ri = self.active-row below self.model.rows do
            {for ci = first-col below self.model.cols do
                def cv = self.model.vals[ri, ci]
                {if {self.traversable? cv} then
                    {return (ri, ci)}
                }
            }
            set first-col = 0
        }

        || Not found yet. Wrap to the first cell and keep looking
        {for ri = 0 to self.active-row do
            {for ci = 0 below self.model.cols do
                {if ri == self.active-row and ci == self.active-col then
                    {break}
                }
                def cv = self.model.vals[ri, ci]
                {if {self.traversable? cv} then
                    {return (ri, ci)}
                }
            }
        }
     else
        || Iterate in reverse, with wraparound
        let first-row:int = self.active-row
        let first-col:int = self.active-col - 1
        {if self.active-col <= 0 then
            set first-col = self.model.cols - 1
            set first-row = self.active-row - 1
        }

        || Look for an editable cell before the current cell
        {for ri = first-row downto 0 do
            {for ci = first-col downto 0 do
                def cv = self.model.vals[ri, ci]
                {if {self.traversable? cv} then
                    {return (ri, ci)}
                }
            }
            set first-col = self.model.cols - 1
        }

        || Not found yet. Wrap to the last cell (lower right)
        {for ri = self.model.rows - 1 downto first-row do
            {for ci = self.model.cols - 1 downto 0 do
                {if ri == self.active-row and ci == self.active-col then
                    {break}
                }
                def cv = self.model.vals[ri, ci]
                {if {self.traversable? cv} then
                    {return (ri, ci)}
                }
            }
        }
    }
    {return (self.active-row, self.active-col)}
  }

  {doc-next
    {purpose
        Make the specified cell active or inactive, after committing
        any pending edit.
    }
  }
  {method public open {activate-cell
                          row:int,
                          col:int,
                          active?:bool = true
                      }:void
    {if row != self.active-row or col != self.active-col then
        {if-non-null gc = {self.get-grid-cell row, col} then
            {gc.activate-cell active?}
        }
    }
  }

  || Override
  {method public open {traverse forward?:bool = true}:bool
    def (row, col) = {self.find-next-active forward? = forward?}
    def gc = {self.get-grid-cell row, col}
||--    {dump "traverse", row, col, gc}
    {if row == self.active-row and col == self.active-col then
        || Nothing to traverse to
||--        {dump "already there"}
        {return false}
     else
        {if-non-null gc then
            {gc.activate-cell true}
        }
    }
    {return true}
  }

  || ---------------
  || Event Handling
  || ---------------


||--  {method public open {note-selection-context-activated}:void
||--  }

  {method private {init-pending-selection row:int, col:int}:void
    set self.anchor-row = row
    set self.anchor-col = col
    set self.point-row = row
    set self.point-col = col
  }

  ||NOTE: based on TextEditPanel
  {method public open {on-focus-in e:FocusIn}:void
    ||FIXME: not needed?
||--    {self.selection-context-request-activate}
    {super.on-focus-in e}
  }

  {method public open {on-focus-out e:FocusOut}:void
    || True loss of key focus indicates we should give up ASC as well. 
    || However, if just the FocusManager itself is losing focus do 
    || nothing; Focus will eventually return to this object. This is critical 
    || to allowing the browser's menus to refer to the ASC (lwexler 5/04)
    {if-non-null fm:FocusManager = {self.get-focus-manager} then
        {if fm.active-selection-context == self and
            fm.have-keyboard-focus?
         then
            set fm.active-selection-context = null
        }
    }
    
    {super.on-focus-out e}
  }

  {doc-next
    {purpose
        Determine if the point (x, y) should affect the selection.
    }
    {details
        If the object at the point (x, y) has no effect on the
        selection, return (-2, -2). If it should select all rows,
        return (-1, c), where r is the column number to be
        selected. If it should select all columns, return (r, -1),
        where r is the row to be selected. If it should select all
        cells, return (-1, -1). If exactly one cell is selected,
        return (r, c), the row and column numbers of that cell.
    }
  }
  {method public open {describe-point x:Distance, y:Distance}:(r:int, c:int)
    def discloser =
        {self.find-graphic-at x, y,
            {proc {g:Graphic}:bool
                {return (g isa Discloser)}
            }
        }
    {if discloser != null then
        {return (-2, -2)}
    }
    def g =
        {self.find-graphic-at x, y,
            {proc {g:Graphic}:bool
                {return
                    (g isa GridCell)
                    or (g isa Fill and
                        {g.style-class.find-string "bottom-spacer"} >= 0 ||""
                        or {g.style-class.find-string "right-spacer"} >= 0 ||""
                        or {g.style-class.find-string "top-left"} >= 0 ||""
                       )
                    or (g isa BaseRuler)
                    or (g isa Resizer)
                    or (g isa GridLineFill)
                }
            }
        }
||--    {dump "describe-point", g}
    {type-switch g
     case gc:GridCell do
        {return (gc.row, gc.col)}
     case vr:VerticalRuler do
        def (rx, ry) = {transform-coordinates x, y, self, vr}
        def row = {vr.index-for-point rx, ry}
        {return (row, -1)}
     case hr:HorizontalRuler do
        def (rx, ry) = {transform-coordinates x, y, self, hr}
        def col = {hr.index-for-point rx, ry}
        {return (-1, col)}
     case d:Discloser do
        {return (-2, -2)}
     case r:Resizer do
        {return (-2, -2)}
     case f:GridLineFill do
        {return (-2, -2)}
     case f:Fill do
        {return (-1, -1)}
     case n:Null do
        {return (-2, -2)}
    }
    {return (-1, -1)}
  }

  {method public open {on-pointer-envelope-event 
                          ev:PointerEnvelopeEvent
                      }:void
    
    {if ev.consumed? or ev.contents.consumed? or not self.enabled? then
        {super.on-pointer-envelope-event ev}
        {return}
    }
    
    def (ex, ey, view) =
        {self.transform-from-graphical-root-coordinates
            ev.contents.x, ev.contents.y
        }

    {type-switch ev.contents
     case pp:PointerPress do
||--        {dump pp, self.selecting?, self.shift?}
        {if-non-null fm:FocusManager = {self.get-focus-manager} then
            {if fm.active-selection-context != self then
                {self.selection-context-request-activate}
            }
        }
        def (row, col) = {self.describe-point ex, ey}
||--        {assert not self.selecting?}
        {if row >= -1 or col >= -1 then
            set self.selecting? = true
            set self.shift? = ev.state-mask.shift?
            {if pp.button == left-button and not self.shift? then
                {self.init-pending-selection row, col}
                {if row >= 0 and col >= 0 then
                    def cv = self.model.vals[row, col]
                    {if cv.editable? then
||--                        {dump cv.editable?, cv.locked?}
                        {self.activate-cell row, col}
                    }
||--                    {dump "PointerPress: clear selection"}
                    {self.reset-selection}
                }
             elseif pp.button == right-button then
                set self._context-row = row
                set self._context-column = col
                {ev.consume}
            }
        }
     case pr:PointerRelease do
||--        {dump pr, self.selecting?, self.shift?}
        || Only get here with click-and-release
        {if self.selecting? and pr.button == left-button then
            def (row, col) = {self.describe-point ex, ey}
            {if row >= -1 then
                let editing?:bool = false
                {if {self.active? row, col} then
                    def cv = self.model.vals[row, col]
                    set editing? = cv.editing?
                }
                {if not editing? then
                    {if ev.state-mask.shift? then
                        set self.anchor-row = row
                        set self.anchor-col = col
                     else
                        {self.init-pending-selection row, col}
                    }
                    {self.update-selection}
                    {ev.consume}
                }
            }
        }
        set self.selecting? = false

     case cme:ContextMenuEvent do
||--        {dump cme, self.selecting?, self.shift?}
        def (row, col) = {self.describe-point ex, ey}
        {if row != self._context-row or col != self._context-column then
||--            {dump "consuming a ContextMenuEvent envelope"}
            {ev.consume}
        }
    } 
    {super.on-pointer-envelope-event ev}
  }

  {method public open {on-pointer-press ev:PointerPress}:void
||--    {dump ev, self.selecting?, self.shift?}
    {if ev.consumed? or not self.enabled? or not self.selecting? then
        {super.on-pointer-press ev}
        {return}
    }
    set self.shift? = ev.state-mask.shift?
    {if not self.shift? then
        def (row, col) = {self.describe-point ev.x, ev.y}
        {if row >= -1 then
            set self.point-row =  row
            set self.point-col =  col
            {ev.consume}
        }
    }
    {super.on-pointer-press ev}
  }

  || For ContainerDragScroller

  {method public open {on-drag-started ev:DragStarted}:void
||--    {dump ev, self.selecting?, self.shift?}
    {if self.enabled? and
        not ev.consumed? and
        ev.state-mask.button-1?
     then
        {ev.consume}
        set self.shift? = ev.state-mask.shift?
        set self.selecting? = true
||--        {dump "start-dragscroll"}
        {self.start-dragscroll ev}
    }
    {super.on-drag-started ev}
  }

  {method public open {note-dragscroll-started x:Distance, y:Distance}:void
||--    {dump "note-ds-started", self.selecting?, self.shift?}
    {if self.selecting? and not self.shift? then
||--        {dump "reset-selection", self.selecting?}
        {self.reset-selection}
    }
    def (row, col) = {self.describe-point x, y}
    {if row >= -1 then
        set self.selecting? = true
        set self.anchor-row = row
        set self.anchor-col = col
    }
    {super.note-dragscroll-started x, y}
  }

  {method public open {note-dragscroll-continued  x:Distance, y:Distance}:void
||--    {dump "note-ds-cont", self.selecting?, self.shift?}
    def (row, col) = {self.describe-point x, y}
    {if row < -1 then
        || nothing?
     elseif self.point-row == -1 and self.point-col == -1 then
        || ignore because everything is already selected
     elseif self.point-col == -1 then
        || selecting entire rows
||--||--        {dump row, col}
||--        set self.anchor-row = row
||--     elseif self.point-row == -1 then
||--        || selecting entire columns
||--        {dump row, col}
        set self.anchor-col = col
     else
        set self.anchor-row = row
        set self.anchor-col = col
    }
    ||FIXME: ev.consume?
    {super.note-dragscroll-continued x, y}
    {self.update-selection}
  }

  {method public open {note-dragscroll-ended}:void   
||--    {dump "note-ds-ended", self.selecting?, self.shift?}
    {self.update-selection}
    set self.selecting? = false
    {super.note-dragscroll-ended}
  }

  || ----------
  || Overrides
  || ----------

  {method public open {create-command name:String}:#Command
    
    {return
        {switch name
         case "delete" do ||""
            {WorksheetDelete self}
         case "select-all" do ||""
            {WorksheetSelectAll self}
         case "copy" do ||""
            {WorksheetCopy self}
         case "paste" do ||""
            {WorksheetPaste self}
         case "Worksheet.insert" do ||""
            {WorksheetInsert self}
||--         case "grid-move-next" do ||""
||--            {WorksheetMoveNextCommand self}
||--         case "grid-move-previous" do ||""
||--            {WorksheetMovePreviousCommand self}
||--         case "grid-move-to" do ||""
||--            {WorksheetMoveToCommand self}
         else
            {super.SelectionContext.create-command name}
        }
    }
  }
  

  {method public open {insist-active at:#ActiveTraversor}:void
    {super.insist-active at}
    {type-switch at
     case erg:EmbeddedRecordGrid do
        {if-non-null cg = erg.grid-cell then
            {self.set-active cg.row, cg.col}
        }
    }
  }


||--  {method public open {get-range-as-selected-text
||--                          into:StringBuf,
||--                          start-bound:#GuiMark=null,
||--                          end-bound:#GuiMark=null
||--                      }:void
||--    let sel:GuiRangeSelection = {GuiRangeSelection}
||--    {sel.adjust-to self, {non-null start-bound}, {non-null end-bound}}
||--    let inside?:bool = false
||--    {if-non-null range = sel.range then
||--        {for ri = 0 below self.model.rows do
||--            {for ci = 0 below self.model.cols do
||--                def gc = self.model.cells[ri, ci]
||--                {if {range.intersects-graphic? gc} then
||--                    set inside? = true
||--                    {if-non-null editor = gc.editor then
||--                        def cv = self.model.vals[ri, ci]
||--                        {into.concat cv.formatted-value}
||--                     else
||--                        {gc.get-range-as-selected-text into}
||--                    }
||--                    {into.append '\t'}
||--                }
||--            }
||--            {if inside? then
||--                {into.append '\n'}
||--            }
||--            set inside? = false
||--        }
||--        {if into.size > 0 and into[into.size - 1] == '\n' then
||--            set into.size = into.size - 1
||--        }
||--    }
||--  }

  || SelectionContext
||--  {getter public abstract open {selection}:Selection}
||--  {method public abstract open {select-nothing}:void}  
||--  {method public open {overdraw-selection g:Graphic,  gc:Renderer2d}:void}


  {doc-next
    {purpose Return the current selection in the worksheet.}
  }
  {getter public open {selection}:WorksheetSelection
    {return self._selection}
  }  

  {getter public open {container}:Graphic
    {return self}
  }

  {doc-next
    {purpose Reset the selection but do not notify.}
  }
  {method protected open {reset-selection}:void
    set self._selection = {WorksheetSelection.empty self}
  }

  {doc-next
    {purpose
        Update the selection and fire a {docref SelectionChanged}
        event at self.
    }
  }
  {method protected open {update-selection}:void
    def nsel = {WorksheetSelection.from-corners
                   self,
                   self.anchor-row, self.anchor-col,
                   self.point-row, self.point-col
               }
    {if not {nsel.equal? self._selection} then
        set self._selection = nsel
||--        def new-selection =
||--            {format "%d,%d -> %d,%d (%d x %d)",
||--                nsel.first-row, nsel.first-column,
||--                nsel.row-anchor, nsel.column-anchor,
||--                nsel.model.rows, nsel.column-count
||--            }
||--        {dump new-selection}
        {self.handle-event {SelectionChanged}}
    }
  }


  {doc-next
    {purpose
        Update the selection to be empty and fire a {docref
        SelectionChanged} event at self.
    }
  }
  {method public open {select-nothing}:void
    {if not self._selection.empty? then
        set self._selection = {WorksheetSelection.empty self}
        {self.handle-event {SelectionChanged}}
    }
  }
  
  {doc-next
    {purpose
        Select all records, columns, and/or regions and fire a {docref
        SelectionChanged} event at self.
    }
  }
  {method public open {select-all}:void
    {if not self._selection.all-cells? then
        set self._selection = {WorksheetSelection.all self}
        {self.handle-event {SelectionChanged}}
    }
  }

  {doc-next 
    {purpose
        Delete the current selection.
    }
  }
  {method public open {delete-selection}:void
||--    {if not self.editable? then
||--        {error
||--            {hlmessage 
||--                Attempted to delete selection in non-editable RecordGrid.
||--            }
||--        }   
||--    }
    let selection:WorksheetSelection = self._selection
    ||FIXME: NYI delete-selection
  }
  
  {method public open {on-selection-changed sc:SelectionChanged}:void
    {self.update}
    {self.request-update-commands}
  }

  || Debugging
  {method private {check-invariants}:void
    {return}
    {for ri = 0 below self.model.rows do
        {for ci = 0 below self.model.cols do
            def cv = self.model.vals[ri, ci]
            {for erfi in self.model.embedded-forms do
                {if erfi.row == ri and erfi.col == ci then
||--                    {assert cv.embedded-form == erfi.erf}
                }
            }
            def (g, grow, gcol) = {self.get-grid-coordinates ri, ci}
            {assert grow >= 0}
            def gc = g.cells[grow, gcol] asa #GridCell
            {if gc != null then
                {assert gc.row == ri}
                {assert gc.col == ci}
                {if ri >= self.frozen-rows then
                    {if ci >= self.frozen-cols then
                        {assert g == self.main-grid}
                    }
                }
             else
||--                {dump gc, ri, ci}
            }
        }
    }

  }
    
}

|| -------------------------------------------------------------------------

|| Embedded RecordGrid
|#
  - A SizeNotifier notifies listeners when the width option changes
  - The top of the Worksheet is a HorizontalRuler, which as a SizeNotifier for
    each column
  - An EmbeddedGridHeader will observe a SizeNotifier and change the width option
  - The header-spec on an embedded RecordGrid will create a EmbeddedGridHeader
    to contain the header text while tracking the column size.
#|

{doc-next
    {purpose 
        A {docref Frame} that observes a column header so that it can
        set the RecordGridColumn width to match.
    }
}
{define-class public open EmbeddedGridHeader {inherits Frame, Observer}

  field public-get protected-set pos:int
  field public-get protected-set rgc:RecordGridColumn
  field public-get protected-set worksheet:Worksheet

  {nonlocal-option public vertical-grid-line-width:any
    def notifier = {self.worksheet.get-width-notifier self.pos}
    {self.adjust-size notifier}
  }

  {constructor public {default
                          worksheet:Worksheet,
                          rgc:RecordGridColumn,
                          pos:int,
                          ...
                      }
    {construct-super.Observer}
    {construct-super.Frame _style-element = "EmbeddedGridHeader", {splice ...}}
    set self.worksheet = worksheet
    set self.rgc = rgc
    set self.pos = pos
    def notifier = {self.worksheet.get-width-notifier pos}
    {self.adjust-size notifier}
||--    {dump "EGH observing", notifier, self.pos}
    {notifier.add-observer self}
  }

  {method protected open {adjust-size notifier:SizeNotifier}:void
    def dx = {self.any-to-Distance self.vertical-grid-line-width}
    def w = {max 0m, notifier.cell-width - dx}
||--    {dump "adjust-size", self.pos, dx, w}
    set self.rgc.width = w
  }

  {method protected open {handle-observer-message
                        source:Observable, message:any
                    }:void
    {type-switch source
     case sn:SizeNotifier do
        {if not sn.row? then
||--            {dump "observed", self.pos, sn.cell-width/1pt, sn.cell-height/1pt}
            {self.adjust-size sn}
        }
    }
  }
} 

{doc-next
    {purpose
        Subclass of RecordGrid that can be embedded in a {docref Worksheet}.
    }
}
{define-class public open EmbeddedRecordGrid {inherits RecordGrid}

  field public-get protected-set worksheet:#Worksheet
  field public-get protected-set grid-cell:#GridCell

  {constructor public {default
                          worksheet:#Worksheet = null,
                          record-source:#RecordSet = null,
                          sort:#RecordSort  = null,
                          filter:#RecordFilter = null,
                          key-spec:any = null,
                          header-options:RecordGridRowOptions =
                              {RecordGridRowOptions},
                          ui-object:#RecordGridUI =
                              {ProtoSkinnableRecordGridUI},
                          ...
                      }
    set self.worksheet = worksheet
    {construct-super
        record-source = record-source,
        sort = sort,
        filter = filter,
        key-spec = key-spec,
        header-options = header-options,
        ui-object = ui-object,

||--        halign = 1.0,
        display-record-selectors? = false,
        display-navigation-panel? = false,
        display-filler-column? = false,
        region-selection-enabled? = true,
        width = {add-stretch},
        height = {add-stretch},
        {splice ...},
||--        header-spec = {proc {rgc:RecordGridColumn}:Graphic
||--                          {return {self.make-header rgc}}
||--                      },
        display-column-headers? = true
    }

    ||HACK
    || Need to wait for the record grid columns to stabilize
    {after 0.2s do || .1s is too little
||--        {dump "+Add notifiers to RGC"}
        set self.header-spec =
            {proc {rgc:RecordGridColumn}:Graphic
                {return {self.make-header rgc}}
            }
    }
  }

  {method public open {make-header rgc:RecordGridColumn}:Graphic
    {if-non-null worksheet = self.worksheet then
||--        let pos:int = {self.record-source.fields.get-index rgc.field-name}
        let pos:int = {self.columns.find rgc}
        {if-non-null gc = self.grid-cell then
            {inc pos, gc.col}
         else
||--            {dump worksheet}
        }
        {return
            {EmbeddedGridHeader
                worksheet,
                rgc,
                pos,
                halign = "right",
                font-weight = "bold",
                font-size = 8pt,
                rgc.field.caption
            }
        }
     else
        {error 
            {hlmessage
                Attempt to use an EmbeddedRecordGrid before setting
                the 'worksheet' field.
            }
        }
    }
  }

  {method public open {test-record action:String, ...}:void
    {super.test-record action, ...}
||--    {dump action, {splice ...}}
  }

  {method public open {become-active forward?:bool=true}:bool
||--    {dump "become-active", self}
    {return {super.become-active forward? = forward?}}
  }

  {method public open {become-active-from-traversal forward?:bool=true}:bool
||--    {dump "become-active-from-traversal", self}
    {return {super.become-active-from-traversal forward? = forward?}}
  }

}

|| -------------------------------------------------------------------------

{doc-next
    {purpose
        Store parameters for adding an object to the {docref WorksheetModel}.
    }
}
{define-class public final WksCellSpec
  field public constant editable?:bool
  field public constant rowspan:int
  field public constant colspan:int
  field public domain:#Domain
  field public constant ui-spec:any
  field public constant v:any
  field public constant args:Arguments

  || For formula
  field package refs:#{Array-of DataRef}

  || For EmbeddedRecordForm (could use a subclass instead)
  field package form:#RecordForm
  field package embedded-form:#EmbeddedRecordForm
  || self.v is the field name to bind to

  {constructor public {default
                          v:any,
                          domain:#Domain = null,
                          editable?:bool = false,
                          rowspan:int = 1,
                          colspan:int = 1,
                          refs:#{Array-of DataRef} = null,
                          ui-spec:any = null,
                          ...
                      }
    set self.editable? = editable?
    set self.colspan = colspan
    set self.rowspan = rowspan
    set self.domain = domain
    set self.refs = refs
    set self.ui-spec = ui-spec
    set self.v = v
    {for (arg,k) in ... do
        {if-non-null k then
            || OK
         else
            {error 
                {hlformat "Extra argument: '%1!s!'", arg}
            }
        }
    }
    set self.args = {Arguments ...}
  }

  {constructor public {clone cs:WksCellSpec}
    set self.editable? = cs.editable?
    set self.rowspan = cs.rowspan
    set self.colspan = cs.colspan
    set self.domain = cs.domain
    set self.v = cs.v
    set self.ui-spec = cs.ui-spec
    set self.args = cs.args    
    set self.refs = cs.refs
    set self.form = cs.form
||FIXME: is this correct? If it is, maybe this should be stored somewhere else.
||--    set self.embedded-form = cs.embedded-form
  }

}

{define-proc public {widths ...}:RulerSpec
  {return {RulerSpec Orientation.horizontal, 0, ...}}
}

{define-proc public {heights ...}:RulerSpec
  {return {RulerSpec Orientation.vertical, 0, ...}}
}

|| Specify parameters to be used when g is added to the Worksheet
|| The rest args are evenutally applied to the GridCell
{define-proc public {cell-spec
                        rowspan:int = 1,
                        colspan:int = 1,
                        domain:#Domain = null,
                        editable?:bool = false,
                        v:any,
                        ...
                    }:WksCellSpec
    {return
        {WksCellSpec
            v,
            domain = domain,
            editable? = editable?,
            rowspan = rowspan, colspan = colspan,
            {splice ...}
        }
    }
}

{define-proc public {currency-cell
                        rowspan:int = 1,
                        colspan:int = 1,
                        editable?:bool = false,
                        v:any,
                        ...
                    }:WksCellSpec
    {return
        {WksCellSpec
            v,
            domain = WorksheetModel.currency-domain,
            editable? = editable?,
            rowspan = rowspan, colspan = colspan,
            halign = "right",
            {splice ...}
        }
    }
}

{define-proc public {formula-cell
                        rowspan:int = 1,
                        colspan:int = 1,
                        domain:Domain = WorksheetModel.double-domain,
                        formula:CalcProc,
                        ...
                    }:WksCellSpec
    def args = {Arguments}
    def refs = {new {Array-of DataRef}}
    {if formula == null or not {proc? formula} then
        {error {hlmessage The formula parameter must be a procedure.}}
    }
    {for (a,k) in ... do
        {if-non-null k then
            {args.append a, keyword = k}
         else
            {type-switch a
||FIXME: self is undefined in this proc
||--             case s:String do
||--                {refs.append {(self asa DataSource).get-ref s}}
             case cr:DataRef do
                {refs.append cr}
             else
                {error
                    {hlformat "Unexpected argument: '%s'", a}
                }
            }
        }
    }
    {return
        {WksCellSpec
            formula,
            domain = domain,
            editable? = false,
            rowspan = rowspan, colspan = colspan,
            refs = refs,
            {splice args}
        }
    }
}

||FIXME: drop this?
{define-proc public {editable-cell
                        v:any,
                        rowspan:int = 1,
                        colspan:int = 1,
                        domain:Domain = {WorksheetModel.get-default-domain v},
                        ...
                    }:WksCellSpec
    {return
        {WksCellSpec
            v,
            domain = domain,
            editable? = true,
            rowspan = rowspan, colspan = colspan,
            {splice ...}
        }
    }
}

{define-proc public {row-group
                        rows:int,
                        expanded?:bool = true
                    }:GroupProto
    {return
        {GroupProto true, rows, expanded? = expanded?}
    }
}
{define-proc public {col-group
                        cols:int,
                        expanded?:bool = true
                    }:GroupProto
    {return
        {GroupProto false, cols, expanded? = expanded?}
    }
}


{doc-next
    {purpose
        Define a {docref RecordForm} that will be repeated in a
        {docref Worksheet} for each record in a {docref RecordSetDataSource}.
    }
}
{define-class public open EmbeddedRecordForm {inherits InitRestArgParser}

  field public-get protected-set row:int = -1
  field public-get protected-set col:int = -1
  field protected _worksheet:#Worksheet

  field protected data-source:RecordSetDataSource
  {getter protected open {_record-source}:#RecordSet
    {return self.data-source.record-set}
  }

  field protected id-field:String

  field protected items:{Array-2-of #WksCellSpec}

  ||FIXME: Only used during construction. Should be private?
  field protected insert-row:int
  field protected insert-col:int
  field protected insert-rowspan:int = 1
  field protected insert-colspan:int = 1
  field protected init-rows:int
  field protected init-cols:int
  field protected _init?:bool = false

  field private _internal-view:RecordView

  field protected forms:{Array-of RecordForm}

  {getter public open {row-count}:int
    def (form-rows, form-cols) = {self.items.size}
    {return form-rows}
  }

  {getter public open {total-row-count}:int
    def (form-rows, form-cols) = {self.items.size}
    {return form-rows * self.forms.size}

  }

  {constructor public {default
                          data-source:RecordSetDataSource,                          
                          worksheet:#Worksheet = null,
                          id-field:String = "id",
                          sort:#RecordSort = null,
                          filter:#RecordFilter = null,
                          ...
                      }
    set self.id-field = id-field
    set self.data-source = data-source
    {if-non-null ws = worksheet then
        set self.worksheet = ws
    }
    {if-non-null record-source = self._record-source then
        {if record-source.load-state == RecordSetLoadState.unloaded 
         then
            {record-source.load}
        }
    }
    || Count the cells so we can allocate the items array
    {with self._init? = true do
        {self.process-rest-args ...}
    }
    set self.items =
        {new {Array-2-of #WksCellSpec}, self.init-rows, self.init-cols}

    set self.forms = {new {Array-of RecordForm}}

    set self.insert-row = 0
    set self.insert-col = 0
    set self.insert-rowspan = 1
    set self.insert-colspan = 1
    {self.process-rest-args ...}
    set self._internal-view = 
        {RecordView
            self.record-source,
            sort = sort,
            filter = filter
        }

  }

  ||FIXME: same method in Worksheet. Refactor into a mixin?
  {method private {increment-insertion-pos}:void
    {inc self.insert-col, self.insert-colspan}
    {if-non-null worksheet = self.worksheet then
        {if self.insert-col >= worksheet.model.cols then
            set self.insert-col = 0
            {inc self.insert-row, self.insert-rowspan}
        }
    }
    set self.insert-rowspan = 1
    set self.insert-colspan = 1
  }

  {method protected open {keyword-init-arg key:String, value:any}:void
    {switch key
     case "row" do
        set self.insert-row = value asa int
     case "col", "column" do
        set self.insert-col = value asa int
     case "rowspan" do ||""
        set self.insert-rowspan = value asa int
     case "colspan" do ||""
        set self.insert-colspan = value asa int
     else
        {if true or not self._init? then
            {super.keyword-init-arg key, value}
        }
    }
  }

  {method public open {non-keyword-init-arg a:any}:void
    def spec =
        {type-switch a
         case cs:WksCellSpec do
            {assert cs.rowspan != 0 and cs.colspan != 0}
            cs
         else
            {WksCellSpec
                a,
                rowspan = self.insert-rowspan,
                colspan = self.insert-colspan
            }
        }

    {if self._init? then
        || During initialization; need to count the rows and columns
        set self.init-rows = {max self.init-rows, self.insert-row + spec.rowspan}
        set self.init-cols = {max self.init-cols, self.insert-col + spec.colspan}
     else
        set self.items[self.insert-row, self.insert-col] = spec
    }
    {self.increment-insertion-pos}
  }

  {getter public open {worksheet}:#Worksheet
    {return self._worksheet}
  }

  {setter public open {worksheet w:Worksheet}:void
    {if self._worksheet == null then
        set self._worksheet = w
        {self.worksheet.observe self.data-source}
     elseif self._worksheet != w then
        {error {hlmessage worksheet already set}}
    }
  }

  {getter public open {record-source}:RecordSet
    {if-non-null src = self._record-source then
        {return src}
     else
        {return {EmptyRecordSet}}
    }
  }

||FIXME: can't set RecordView.record-source
||--  {setter public open {record-source val:#RecordSet}:void
||--    {if val != self._record-source then
||--        {if val != null and
||--            val.load-state == RecordSetLoadState.unloaded
||--         then
||--            {val.load}
||--        }
||--        
||--        set self._record-source = val
||--        set self._internal-view.record-source =
||--            {if-non-null val then val else {EmptyRecordSet}}
||--        
||--        set self.current-index = 0  || Setter keeps in bounds.
||--    }
||--  }

  {doc-next
    {purpose 
        Records currently being displayed.
    }
    {details
        Represents the view of the data being actually shown.
        
        Modify this {docref RecordView}'s properties in order 
        to change the data being shown.
    }
  }
  {getter public open {records}:RecordView
    {return self._internal-view}
  }

  {doc-next
    {purpose Sort to be applied to the {ctext records}.}
    {details 
        The default implementation of this method simply 
        sets the property with the same name on the 
        {ctext records} collection.
    }
    {override Not typically overridden}
  }
  {getter public open {sort}:#RecordSort
    {return self.records.sort}
  }
  {setter public open {sort value:#RecordSort}:void
    set self.records.sort = value
  }
        
    
  {doc-next
    {purpose Filter to be applied to the {ctext records}.}
    {details 
        The default implementation of this method simply
        sets the property with the same name on 
        the {ctext records} collection.
    }
    {override Not typically overridden}
  }
  {getter public open {filter}:#RecordFilter
    {return self.records.filter}
  }
  {setter public open {filter value:#RecordFilter}:void
    set self.records.filter = value
  }

  || Create an editor for a field, unless there is one already
  {method public open {get-field-editor
                          cv:CellValue,
                          gc:GridCell
                      }:#ValueControl
    def spec = {non-null cv.field-spec}
    def field-name = spec.v asa String
    def form = {non-null gc.data-binding-context} asa RecordForm
    {if spec.editable? then
        def vc = {non-null {gc.get-editor cv}}
||--        set vc.value-as-any = cv.value
||--        set cv.editing? = gc.active?
||--        set cv.locked? = false
        ||FIXME: should allow subclasses of String too?
        {if vc.value-type == String then
            {vc.add-data-binding
                {bind value to field-name,
                    {format v:any as {cv.domain.format v}},
                    {parse v:String as
                        {try
                            {cv.domain.parse v}
                         catch e:Exception do
                            cv.value
                        }
                    }
                }
            }
         else
            {vc.add-data-binding
                {bind value to field-name}
            }
        }
        || Make sure the control matches the data it is bound to
        {form.refresh vc}
        {return vc}
     else
        {assert cv.editing? == false}
        {assert cv.locked? == true}
    }
    {return null}
  }

  {method private {clear-forms}:void
    def (form-rows,form-cols) = {self.items.size}
    {for rf:RecordForm key ri in self.forms do
        {for fri = 0 below form-rows do
            {for fci = 0 below form-cols do
                def frow = self.row + ri * form-rows + fri
                def fcol = self.col + fci
                {if-non-null spec = self.items[fri, fci] then
                    {self.worksheet.model.vals[frow, fcol].clear-form-cell}
                    {if-non-null gc = {self.worksheet.get-grid-cell frow, fcol}
                     then
                        {gc.clear}
                    }
                }
            }
        }
    }
    {self.forms.clear}
  }

  {method private {validate-forms}:bool
    let valid?:bool = true
    {for form in self.forms do
        {if form.current-record == null then
            set valid? = false
            {break}
        }
    }
    {return valid?}
  }

  {doc-next
    {purpose Embed a form in the worksheet.}
    {details
        Use the form template given by the {docref EmbeddedRecordForm}
        associated with the {docref CellValue} at the specified row
        and column to create a form for each record in the data source.
    }
  }
  {method public open {insert-embedded-form
                          row:int, col:int
                      }:int

    || Somewhat of a kludge. The Worksheet constructor syntax uses one
    || row to specify the EmbeddedRecordForm. So that is one less row
    || to insert.
    ||FIXME: add a method init-embedded-form to be called from constructor
    let rows-reserved:int = 0

    {if self.row == -1 then
        set self.row = row
        set self.col = col
        set rows-reserved = 1
     else
        {assert row == self.row and col == self.col}
    }
    def (form-rows,form-cols) = {self.items.size}
    def old-nrecs = self.forms.size
    def nrecs = self.records.size
    def nrows = (nrecs - old-nrecs) * form-rows

    || If the number of records is unchanged, data bindings should
    || ensure the form fields are correct, so can return immediately.
    {if old-nrecs == nrecs and {self.validate-forms} then
||--        {dump "insert-embedded-form: no new records"}
        {return nrecs}
    }

    {self.clear-forms}
    {if nrows > 0 then
        {self.worksheet.insert-rows
            row + old-nrecs + rows-reserved, nrows - rows-reserved
        }
     else
        def erf = self.worksheet.model.vals[self.row, self.col].embedded-form
        {assert erf == self}
        {self.worksheet.insert-rows
            row + rows-reserved, nrows - rows-reserved
        }
        set self.worksheet.model.vals[self.row, self.col].embedded-form = erf
    }
    || Clear the first row
    {for fci = 0 below form-cols do
        def fcol = col + fci
        def cv = self.worksheet.model.vals[row, fcol]
        def gc = {self.worksheet.get-grid-cell row, fcol}
||--        {dump row, fci, cv.value, gc.value, rows-reserved}
    }
    {if nrecs == 0 then
        {return 0}
    }

    {if nrecs != old-nrecs  then
        ||FIXME: adjust heights of newly inserted rows to match existing
        {if old-nrecs == 0 and rows-reserved == 0 then
            || Move the EmbeddedRecordForm back to it's original location
            def tcv = self.worksheet.model.vals[row + nrows, col]
            set self.worksheet.model.vals[row + nrows, col] =
                self.worksheet.model.vals[row, col]
            set self.worksheet.model.vals[row, col] = tcv
        }
    }

    {for r:Record key ri in self.records do
        def filter = {RecordData}
        set filter[self.id-field] = r[self.id-field] || this record only
        def form = {RecordForm
                       record-source = self.record-source,
                       filter = filter,
                       display-navigation-panel? = false
                   }
        {form.request-current-record-change 0}
        {self.forms.append form}
        {for fri = 0 below form-rows do
            {for fci = 0 below form-cols do
                def frow = row + ri * form-rows + fri
                def fcol = col + fci
||--                {self.worksheet.ensure-cell-fits frow, fcol}
                def gc = {self.worksheet.get-grid-cell frow, fcol}
                {if-non-null gc then
                    set gc.data-binding-context = form
                 else
||--                    {dump "no GridCell", frow, fcol}
                }
                {if-non-null spec = self.items[fri, fci] then
                    def cv = self.worksheet.model.vals[frow, fcol]
                    || If this is a field reference, stash info needed later in cv
                    ||FIXME: If there were an explicit field object this could
                    || be done in init-cell, which would be much better
                    let fs:#WksCellSpec = null
                    let value:any = spec.v
                    let domain:Domain = cv.domain
                    let init-proc:#{proc-type {r:#Record}:any} = null
                    {type-switch value
                     case field-name:String do
                        set fs = {WksCellSpec.clone spec}
                        set fs.embedded-form = self
                        set fs.form = form ||FIXME: not needed now?
                        set domain =
                            self.record-source.fields[field-name].domain
                        set fs.domain = domain
                        set value = r[field-name]
                     case p:{proc-type {r:#Record}:any} do
                        set init-proc = p
                        set value = {init-proc form.current-record}
                     case v:Visual do
                        set value = {v.clone-appearance}
                    }
                    {self.worksheet.init-cell
                        frow, fcol, value,
                        domain = domain,
||--                        rowspan = cv.rowspan, colspan = cv.colspan,
                        rowspan = spec.rowspan, colspan = spec.colspan,
                        editable? = spec.editable?, args = spec.args,
                        field-spec = fs, init-proc = init-proc
                    }
                    {assert cv.locked? == (not spec.editable?)} || or else assign here
                    {if-non-null gc then
                        {gc.refresh}
                    }
||--                    set cv.editing? =
||--                        self.worksheet.model.active-col == fcol and
||--                        self.worksheet.model.active-row == frow
                }
            }
        }
    }
    {return form-rows * self.records.size}
  }
}

|| ---------------------------------------------------------------------------

{doc-next
    {purpose 
        Selection returned by a {docref Worksheet}.
    }    
    {details
        NOTE: Applications should {italic not} attempt to make 
        changes or call modifying methods on this object.  In order
        to change the contents of this selection, call methods 
        directly on the related {docref RecordGrid} instead.  See 
        {docref Selection} for more information.
    }
}
{define-class public open WorksheetSelection
  {inherits Selection}


  field public-get protected-set worksheet:Worksheet

  {doc-next
    {purpose
        Index of the first row in the selection.
    }
    {details
        If negative, it means all rows are selected. Use {docref-abbr
        WorksheetSelection.begin-row} if iterating over row indices in
        a loop.
    }
  }
  field public-get protected-set first-row:int

  {doc-next
    {purpose
        Index of the first column in the selection.
    }
    {details
        If negative, it means all columns are
        selected. Use {docref-abbr WorksheetSelection.begin-column} if
        iterating over column indices in a loop.
    }
  }
  field public-get protected-set first-column:int

  {doc-next
    {purpose
        Number of rows included in the selection.
    }
  }
  field public-get protected-set row-count:int
  
  {doc-next
    {purpose
        Number of columns included in the selection.
    }
  }
  field public-get protected-set column-count:int

  {doc-next
    {purpose
        The row index of the current cell within the selection.
    }
    {details
        Must be one of the four corners of the region.
    }
  }
  field public-get protected-set row-anchor:int

  {doc-next
    {purpose
        The column index of the current cell within the selection.
    }
    {details
        Must be one of the four corners of the region.
    }
  }
  field public-get protected-set column-anchor:int

  {doc-next
    {purpose
        Construct this object.
    }
    {parameter first-row,
        Index of the first record in this region.
    }
    {parameter first-column,
        Index of the first column in this region.
    }
    {parameter row-count,
        Number of rows included in this region.
        A value of -1 means all rows.
    }
    {parameter column-count,
        Number of columns included in this region.
        A value of -1 means all columns.
    }
    {parameter row-anchor,
        Row index of the current cell in the selection. If not
        specified, it will be the last row.
    }
    {parameter column-anchor,
        Column index of the current cell in the selection. If not
        specified, it will be the last column.
    }
  }
  {constructor public {default
                          worksheet:Worksheet,
                          first-row:int,
                          first-column:int,
                          row-count:int,
                          column-count:int,
                          row-anchor:int = -1,
                          column-anchor:int = -1
                      }
    {if first-row < 0 or first-column < 0 then
        {error {hlmessage Invalid WorksheetSelection specification.}}
    }

    set self.worksheet = worksheet
    set self.first-row = first-row
    set self.first-column = first-column
    set self.row-count = row-count
    set self.column-count = column-count
    set self.row-anchor =
        {min {max row-anchor, first-row}, first-row + row-count - 1}
    set self.column-anchor =
        {min {max column-anchor, first-column}, first-column + column-count - 1}
  }


  {doc-next
    {purpose
        Construct this object from two corner points.
    }
    {parameter row-anchor,
        Index of the start record in this region.
    }
    {parameter column-anchor,
        Index of the start column in this region.
    }
    {parameter row-point,
        Index of the end record in this region.
    }
    {parameter column-point,
        Index of the end column in this region.
    }
    {since 7.0}
  }
  {constructor public {from-corners
                          worksheet:Worksheet,
                          row-anchor:int,
                          column-anchor:int,
                          row-point:int,
                          column-point:int
                      }
||--    {if row-anchor < 0 or column-anchor < 0 or
||--        row-point < 0 or column-point < 0
||--     then
||--        {error {hlmessage Invalid WorksheetSelection specification.}}
||--    }

    set self.worksheet = worksheet
    set self.first-row = {min row-anchor, row-point}
    set self.first-column = {min column-anchor, column-point}
    set self.row-count = {abs row-anchor - row-point} + 1
    set self.column-count = {abs column-anchor - column-point} + 1
    set self.row-anchor = row-anchor
    set self.column-anchor = column-anchor
  }

  {constructor public {empty
                          worksheet:Worksheet
                      }
    set self.worksheet = worksheet
    set self.first-row = 0
    set self.first-column = 0
    set self.row-count = 0
    set self.column-count = 0
    set self.row-anchor = 0
    set self.column-anchor = 0
  }

  {constructor public {all
                          worksheet:Worksheet
                      }
    set self.worksheet = worksheet
    set self.first-row = -1
    set self.first-column = -1
    set self.row-count = -1
    set self.column-count = -1
    set self.row-anchor = 0
    set self.column-anchor = 0
  }

  {doc-next
    {purpose
        Determine whether two {ctext WorksheetSelection}s are equal.
    }
    {parameter r,
        the selection to be compared with {ctext self}.
    }
  } 
  {method public open {equal? r:WorksheetSelection}:bool
    {return
        self.worksheet == r.worksheet and
        self.first-row == r.first-row and
        self.first-column == r.first-column and
        self.row-count == r.row-count and
        self.column-count == r.column-count
    }
  }

  {doc-next
    {purpose
        Determine whether this region contains a cell location.
    }
    {parameter row-index,
        {ctext int}. Row index of cell of interest. 
    }
    {parameter column-index,
        {ctext int}. Column index of cell of interest. 
    }
    {return-vals 
        {ctext true} if this cell location is within the region.
        Otherwise {ctext false}.
    }
  }
  {method public open {contains-cell? 
                          row-index:int,
                          column-index:int
                      }:bool
    {return
        {if self.all-cells? then
            true
         elseif self.all-rows? then
            column-index >= self.first-column and
            column-index < self.first-column + self.column-count
         elseif self.all-cols? then
            row-index >= self.first-row and
            row-index < self.first-row + self.row-count
         else
            row-index >= self.first-row and 
            row-index < self.first-row + self.row-count and
            column-index >= self.first-column and 
            column-index < self.first-column + self.column-count
        }
    }
  }

  {getter public open {empty?}:bool
    {return self.row-count == 0 and self.column-count == 0}
  }

  {getter public open {all-rows?}:bool
    {return self.first-row == -1}
  }
  {getter public open {all-cols?}:bool
    {return self.first-column == -1}
  }
  {doc-next 
    {purpose 
        Return true when the selection covers the entire {docref Worksheet}.
    }
  }
  {getter public open {all-cells?}:bool
    {return self.first-column == -1 and self.first-row == -1}
  }

  {doc-next
    {purpose The index of the first row in the selection.}
  }
  {getter public open {begin-row}:int
    {return {max 0, self.first-row}}
  }

  {doc-next
    {purpose The index of the last row in the selection.}
  }
  {getter public open {end-row}:int
    {return {if self.first-row < 0 then
                self.worksheet.model.rows - 1
             else
                self.first-row + self.row-count - 1
            }
    }
  }

  {doc-next
    {purpose
        Return the number of rows intersected by the current selection.
    }
  }
  {getter public open {rows}:int
    {return
        {if self.empty? then
            0
         else
            self.end-row - self.begin-row + 1
        }
    }
  }

  {doc-next
    {purpose The index of the first column in the selection.}
  }
  {getter public open {begin-column}:int
    {return {max 0, self.first-column}}
  }

  {doc-next
    {purpose The index of the last column in the selection.}
  }
  {getter public open {end-column}:int
    {return {if self.first-column < 0 then
                self.worksheet.model.cols - 1
             else
                self.first-column + self.column-count - 1
            }
    }
  }

  {doc-next
    {purpose
        Return the number of columns intersected by the current selection.
    }
  }
  {getter public open {cols}:int
    {return 
        {if self.empty? then
            0
         else
            self.end-column - self.begin-column + 1
        }
    }
  }
}

|| -------------------------------------------------------------------------
||--{define-proc public {make-header rgc:RecordGridColumn}:Graphic
||--    {return
||--        {EmbeddedGridHeader
||--            worksheet, rgc,
||--            {rs.fields.get-index rgc.field-name},
||--            font-weight = "bold",
||--            font-size = 8pt,
||--            rgc.field.caption
||--        }
||--    }
||--}

|| Register EmbeddedRecordGrid with the LookAndFeel
{define-proc package {register-control-group
                         control-type:Type,
                         skinnable-ui-type:Type,
                         control-skin:#Type,
                         control-feel:#Type
                     }:void
||--    || Debug code:
||--    {if not {control-type.subtype-of? Control} or
||--        not {skinnable-ui-type.subtype-of? SkinnableControlUI} or
||--        not {skinnable-ui-type.subtype-of? ControlUI}
||--     then
||--        {error}
||--    }
||--    {if-non-null control-skin then
||--        {if not {control-skin.subtype-of? ControlSkin} then
||--            {error}
||--        }
||--    }
||--    {if-non-null control-feel then
||--        {if not {control-feel.subtype-of? ControlFeel} then
||--            {error}
||--        }
||--    }
    def lnf = the-standard-look-and-feel
    {type-switch skinnable-ui-type
     case ct:ClassType do
        {if-non-null maker = {ct.get-constructor "default"} then ||""
            {lnf.register-ui-proc
                control-type,
                {proc {}:ControlUI
                    {return {maker.new} asa ControlUI}
                }
            }
            {if-non-null control-feel then
                {lnf.register-control-feel skinnable-ui-type, control-feel}
            }
            {if-non-null control-skin then
                {lnf.register-control-skin skinnable-ui-type, control-skin}
            }
        }
    }
    
    || FIXME: error on fall-through?
}

||""((
{do
    def lnf = the-standard-look-and-feel
    def skinnable-ui-type =  ProtoSkinnableRecordGridUI
    {register-control-group
        EmbeddedRecordGrid,
        ProtoSkinnableRecordGridUI,
        ProtoRecordGridSkin,
        StandardRecordGridFeel
||--            ProtoRecordGridSkin,
||--            ProtoRecordGridFeel
    }
||--    {lnf.register-control-feel skinnable-ui-type, ProtoRecordGridFeel}
||--    {lnf.register-control-skin skinnable-ui-type, ProtoRecordGridSkin}

    ||FIXME: need ability to add these rules to user's rules
    {install-style-sheet
        {StyleSheet
            {StyleRule "Worksheet",
                grid-line-color = "silver",
                selected-background = "#FDF6B0",
                selected-color = "black",
                background = Worksheet.readonly-bg
            },

||--            {StyleRule "TextField",
||--                border-spec =
||--                    {BorderSpec top-margin = 1px, bottom-margin = 1px}
||--            },

            {StyleRule "RecordGrid/internal-grid",
                border-spec = null
            },

||--            {StyleRule "RecordGrid", ||FIXME: is this needed?
||--                grid-line-color = "silver"
||--            },

            {StyleRule "HorizontalRuler",
                vorigin = "top", horigin = "left",
                vstretch? = true, valign = "top"
            },
            {StyleRule "VerticalRuler",
                vorigin = "top", horigin = "left",
                hstretch? = true, halign = "left"
            },

            {StyleRule "WorksheetGrid/h-resize-rule",
                width = 1px,
                background = "black",
                vorigin = "top", horigin = "left"
            },
            {StyleRule "WorksheetGrid/v-resize-rule",
                height = 1px,
                background = "black",
                vorigin = "bottom", horigin = "left"
            },

            {StyleRule "GridCell",
                width = {make-elastic},
                height = {make-elastic},
                halign = "left",
                background = Worksheet.readonly-bg
            },

            {StyleRule
                "Resizer.vertical",
                height = 2mm,
                background = "transparent",
                width = {make-elastic minimum-size = 2mm},
                cursor = {Cursor.get-top-bottom-resize-cursor}
||--                ,background = "#d0f0f0a0", ||FIXME: DEBUG
            },
            {StyleRule
                "Resizer.horizontal",
                background = "transparent",
                width = 2mm,
                height = {make-elastic minimum-size = 2mm},
                cursor = {Cursor.get-left-right-resize-cursor}
||--                ,background = "#d0f0f0a0", ||FIXME: DEBUG
            },
            {StyleRule
                "SizeNotifier",
                vorigin = "top", horigin = "left"
            },
            {StyleRule
                "SizeNotifier.horizontal",
                background = Worksheet.header-bg,
                color = Worksheet.header-color
            },
            {StyleRule
                "SizeNotifier.vertical",
                background = Worksheet.header-bg,
                color = Worksheet.header-color
            }

            || Debugging style rules
||--            ,
||--            {StyleRule "Fill.top-left",
||--                background = "pink"
||--            }
||--            ,{StyleRule
||--                "Fill/vertical-grid-line",
||--                border-width = 1px, border-color = "green"
||--            },
        }
    }
}
||""))

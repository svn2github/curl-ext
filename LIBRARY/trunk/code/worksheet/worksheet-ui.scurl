||| Copyright 1998-2010, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.
|||
||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.
||| ----------------------------------------------------------------------------

|| Move to CURL.EXT
{doc-next
    {purpose
        Create a JSON representation of the records in {param rs}.
    }
    {details
        ||FIXME: also include fields:<field descriptions>
        The result is a {docref JsonArray} with one {docref JsonObject}
        for each record. The {ctext JsonObject} has entries field:value
        for each field in the {ctext RecordSet}. You can use {docref
        RecordSet-from-Json} to restore the records.

        The field values are converted to strings using the {docref
        Domain.format} method.
    }
}
{define-proc public {RecordSet-to-Json rs:RecordSet}:JsonObject
    def data = {JsonObject}
    def records = {JsonArray}
    ||FIXME: add fields
    set data["records"] = records
    {for r in rs do
        def rdata = {JsonObject}
        {for f in rs.fields do
            set rdata[f.name] = {f.domain.format r[f.name]}
        }
        {records.append rdata}
    }
    {return data}
}

{doc-next
    {purpose Replace all of the records in {param rs} with data from
        {param records}.
    }
    {details
        Each element in the {param records} array is expected to be
        a {docref JsonObject} containing strings named by the field
        names in {param rs}. Each string value is parsed using the
        field domain.

        All records in {param rs} are deleted (and committed).  For
        each object in {param records}, a new record is created
        in {param rs} with fields initialized from the next {docref
        JsonObject}. The result is then committed to
        {param rs}.
    }
    {parameter rs, The {docref RecordSet} to be updated. The fields
        are used to parse the data.
    }
    {parameter records, An array of {docref JsonObject}s containing
        the record data.
    }
    {parameter append?, If false, the existing record data is cleared
        before the {param records} are added.
    }
}
{define-proc public {RecordSet-from-Json
                        rs:RecordSet,
                        records:JsonArray,
                        append?:bool = false
                    }:void
    {with rs.batch-events? = true do
        {if not append? then
            {rs.delete-all}
            {rs.commit}
        }
        {for rd in records do
            def rdo = rd asa JsonObject
            def r = {rs.new-record}
            {for f in rs.fields do
                set r[f.name] = {f.domain.parse rdo[f.name] asa String}
            }
            {rs.append r}
        }
        {rs.commit}
    }
}

{doc-next
    {purpose Construct an array of {docref RecordData} from a JSON
        object.
    }
    {details
        Each element in the {param records} array is expected to be
        a {docref JsonObject} containing strings named by the field
        names in {param rs}. Each string value is parsed using the
        field domain.

        For each object in {param records}, a new {ctext RecordData}
        is created with values initialized from the {docref
        JsonObject}.
    }
}
{define-proc public {RecordData-from-Json
                        rs:RecordSet,
                        rs-json:JsonObject
                    }:{Array-of RecordData}
    def rda = {new {Array-of RecordData}}
    def records = rs-json["records"] asa JsonArray
    {for rdj in records do
        def rdo = rdj asa JsonObject
        def rd = {RecordData}
        {for f in rs.fields do
            set rd[f.name] = {f.domain.parse rdo[f.name] asa String}
        }
        {rda.append rd}
    }
    {return rda}
}

|| -------------------------------------------------------------------------
|#

What's in the Model?
  o 2-D array of cell values and attributes
  o List of formulas
  o List of CellRefs
  o List of RangeRefs

What's in the UI?
  o Grid that holds four WorksheetGrids, one for each independently
    scrollable region (some are empty if there are no frozen rows/cols)
  o Row selectors and resizers at the left
  o Column selectors and resizers at the top
  o 2-D array of GridCells, which contain UI or displayed value

Worksheet Life Cycle
  - Create a model big enough to hold everything you need
  - Instantiate the data sources
  - Instantiate datarefs as needed
  - Construct the Worksheet
    - Text and visuals as needed
    - Editable cells
    - EmbeddedRecordGrid
    - EmbeddedRecordForm

How does the edit/update cycle work?
  o Steady state: all calcs have run and UI shows current values
  o User edits a cell, commits
  o Recalc everything
  o notify observers, including the UI
  o Look at every cell. If (formatted) value is different than it was,
    rebuild the cell. Same for attributes.

#|

|| --------------------------
|| Cell and Range References
|| --------------------------

||FIXME: Not yet used
{define-class package final CellRefInfo
  field public constant rc-ref?:bool
  field public constant row:int
  field public constant col:int
  field public constant abs-row?:bool
  field public constant abs-col?:bool
  field public constant rel-row?:bool
  field public constant rel-col?:bool

  {constructor package {default
                          rc-ref?:bool,
                          row:int,
                          col:int,
                          abs-row?:bool,
                          abs-col?:bool,
                          rel-row?:bool,
                          rel-col?:bool
                      }
    set self.rc-ref? = rc-ref?
    set self.row = row
    set self.col = col
    set self.abs-row? = abs-row?
    set self.abs-col? = abs-col?
    set self.rel-row? = rel-row?
    set self.rel-col? = rel-col?
  }
}

||FIXME: Not yet used
|| Parse Excel style r4c2 or r[0]c[-1]
{define-proc package {parse-rc-ref s:String}:#CellRefInfo
    let rc-ref?:bool
    let row:int
    let col:int
    let abs-row?:bool
    let abs-col?:bool
    let rel-row?:bool
    let rel-col?:bool
    let state:int = 0
    ||States: 0:start 1:[ 2:row 3:] 4:c 5:[ 6:row 7:]
    {for c:char in s do
        def uc = {char-upcase c}
        {if uc == 'R' then
            {if state == 0 then
                set state = 1
             else
                {bad-ref s}
            }
         elseif uc == '[' then

         elseif uc == ']' then

         elseif {digit? c, 10} then
            {if state == 2 or state == 3 or state == 4 then
                set state = 4
                set row = row * 10 + c - '0'
             else
            }
        }
    }
    {return null}
}

|| Helper proc to parse A1, $B$3, etc.
{define-proc package {parse-cellref s:String}:(r:int, c:int, ra?:bool, ca?:bool)
    ||FIXME: also parse a sheet ref
    ||FIXME: what about named ranges, and named sheets?
    let state:int = 0 || start => 0 $ => 1 letter => 2 $ => 3 digit => 4
    let abs-c?:bool = false
    let abs-r?:bool = false
    let col:int = 0
    let row:int = 0
    {for c:char in s do
        {if c == '$' then
            {if state == 0 then
                set abs-c? = true
                set state = 1
             elseif state == 2 then
                set abs-r? = true
                set state = 3
             else
                {bad-ref s}
            }
         elseif {digit? c, 10} then
            {if state == 2 or state == 3 or state == 4 then
                set state = 4
                set row = row * 10 + c - '0'
             else
                {bad-ref s}
            }
         elseif {CharClass.letter-chars.member? c} then
            {if state == 0 or state == 1 or state == 2 then
                set state = 2
                set col = col * 26 + {char-upcase c} - 'A'
             elseif state == 3 then
                {bad-ref s}
||--             elseif state == 4 then
||--                || Saw letter, digit. Letter again might mean r1c1 notation
||--                {return {parse-rc-ref s}}
            }
         else
            {bad-ref s}
        }
    }
    {return (row - 1, col, abs-r?, abs-c?)}
}


{doc-next
    {purpose
        Base class for cell reference or range reference in a {docref
        Worksheet}.
    }
}
{define-class abstract public open SheetRef {inherits DataRef}

  {doc-next
    {purpose The data source for this reference.}
  }
  {getter public open {worksheet}:WorksheetModel
    {return self.source asa WorksheetModel}
  }

  {doc-next
    {purpose Initialize a new {docref SheetRef}.}
    {parameter worksheet, The data source for this reference.}
  }
  {constructor public {default
                          worksheet:WorksheetModel
                      }
    {construct-super worksheet}
  }

  {doc-next
    {purpose Return true if the reference is absolute.}
  }
  {getter abstract public open {absolute?}:bool
  }

  {doc-next
    {purpose
        Adjust for {param row-count} rows added (negative means
        deleted) at {param row} and {param col-count} added/deleted
        at {param col}.
    }
  }
  {method abstract public open {adjust
                                   row:int, row-count:int,
                                   col:int, col-count:int
                               }:void
  }
}

|# About CellRefs

  - Both absolute and relative cellrefs are adjusted when rows or
    columns are inserted or deleted.a
  - The difference between "absolute" and "relative" is what
    happens when the reference is resolved to a "target" in
    CalcMixin.eval. Absolute refs are not changed. Relative
    refs are adjusted to the target.

#|


{doc-next
    {purpose A reference to a cell defined by its position relative
        to the target cell of a formula.
    }
}
{define-class public open RelativeCellRef {inherits ValueRef}

  {doc-next
    {purpose
        {docref CellRef.resolve} will add this number to the target row to
        determine the actual row.
    }
  }
  field public-get protected-set row-offset:int

  {doc-next
    {purpose
        {docref CellRef.resolve} will add this number to the target column
        to determine the actual column.
    }
  }
  field public-get protected-set col-offset:int
  
  {doc-next
    {purpose Initialize a new {docref RelativeCellRef}.}
    {parameter row-offset, This offset is added to the row number
        of the target cell of a formula.
    }
    {parameter col-offset, This offset is added to the column number
        of the target cell of a formula.
    }
  }
  {constructor public {default row-offset:int, col-offset:int}
    {construct-super 0}
    set self.row-offset = row-offset
    set self.col-offset = col-offset
  }

  || doc inherited
  {method public open {resolve target:DataRef}:DataRef
    {return {target.source.get-ref target, self.row-offset, self.col-offset}}
  }


  || doc inherited
  {getter public open {domain}:Domain
    {error
        {hlmessage
            The domain is not known. Use self.resolve to get a usable DataRef.
        }
    }
  }
}


{doc-next
    {purpose Reference to a single cell in a {docref Worksheet}.}
}
{define-class public open CellRef {inherits SheetRef}

  {doc-next
    {purpose Compute a hash value for a {docref CellRef}.}
  }
  {define-proc public {hash-proc ref:CellRef}:int
    let v:int = ref.row * WorksheetModel.max-cols + ref.col
    {if not ref.row-abs? then set v = v * 7}
    {if not ref.col-abs? then set v = v * 111}
    {return {value-hash v}}
  }

  {doc-next
    {purpose Compare two {docref CellRef}s and return true if they are equal.}
  }
  {define-proc public {equal-proc a:CellRef, b:CellRef}:bool
    {return a.row == b.row and a.col == b.col
        and a.row-abs? == b.row-abs?
        and a.col-abs? == b.col-abs?
    }
  }

  {doc-next
    {purpose The row number for this cell reference.}
  }
  field public-get protected-set row:int

  {doc-next
    {purpose This field is true if the row number is absolute.}
  }
  field public-get protected-set row-abs?:bool

  {doc-next
    {purpose The column number for this cell reference.}
  }
  field public-get protected-set col:int

  {doc-next
    {purpose This field is true if the column number is absolute.}
  }
  field public-get protected-set col-abs?:bool

  || Actually, this is an easy way to construct relative refs
  || def cell-above = {CellRef -1, 0}
  || def cell-right = {CellRef 0, 1}
  {doc-next
    {purpose Initialize a {docref CellRef}.}
    {notes
        Normally a {docref CellRef} is created by calling {docref
        WorksheetModel.get-ref}, which will register the reference and
        update it if rows or columns are added or removed.
    }
    {parameter worksheet, the {docref DataSource} for this reference.}
    {parameter row, the row index, with 0 meaning the first row.}
    {parameter col, the column index, with 0 meaning the leftmost column.}
    {parameter row-abs?, if true, the row index is never adjusted to a target
        cell.
    }
    {parameter col-abs?, if true, the column index is never be adjusted to
        a target cell.
    }
  }
  {constructor public {default
                          worksheet:WorksheetModel,
                          row:int, col:int,
                          row-abs?:bool = false,
                          col-abs?:bool = false
                      }
    {construct-super worksheet}
    set self.row = row
    set self.row-abs? = row-abs?
    set self.col = col
    set self.col-abs? = col-abs?
    {self.check-invariants}
  }

  {method private {check-invariants}:void
    {if (self.row-abs? and self.row < 0) or (self.col-abs? and self.col < 0)
     then
        {error {hlmessage Absolute row or column value must be 0 or higher.}}
    }
  }

  {method public open {equal? cr:CellRef}:bool
    {return {CellRef.equal-proc self, cr}}
  }

  {method public open {resolve target:DataRef}:DataRef
    {if self.absolute? then
        {return self}
     else
        {type-switch target
         case tr:CellRef do
            def row = {if self.row-abs? then
                          self.row
                       else
                          tr.row + self.row
                      }
            def col = {if self.col-abs? then
                          self.col
                       else
                          tr.col + self.col
                      }
            def ref = {CellRef.absolute tr.worksheet, row, col}
            || Note: this is not interned.
            {return ref}
         else
            {error
                {hlformat "The target must be a CellRef: %s", target}
            }
        }
    }
  }


  {doc-next
    {purpose Initialize a {docref CellRef}.}
    {notes
        Normally a {docref CellRef} is created by calling {docref
        WorksheetModel.get-ref}, which will register the reference and
        update it if rows or columns are added or removed.
    }
    {parameter worksheet, The {docref DataSource} that this reference
        points into.
    }
    {parameter row, The row of the cell referred to.}
    {parameter col, The column of the cell referred to.}
  }
  {constructor public {absolute
                          worksheet:WorksheetModel,
                          row:int,
                          col:int
                      }
    {construct-super worksheet}
    set self.row = row
    set self.row-abs? = true
    set self.col = col
    set self.col-abs? = true
    {self.check-invariants}
  }

  || This constructor is primarily for use by a GUI formula builder, which
  || will know what cell to user for reference (for relative references).
  {doc-next
    {purpose Initialize a {docref CellRef}.}
    {notes
        Normally a {docref CellRef} is created by calling {docref
        WorksheetModel.get-ref}, which will register the reference and
        update it if rows or columns are added or removed.
    }
    {parameter worksheet, The {docref DataSource} that this reference
        points into.
    }
    {parameter s, A string that describes a cell location, such as "D7".}
    {parameter ref, The base cell for a relative reference.}
  }
  {constructor public {from-String
                          worksheet:WorksheetModel, s:String, ref:#CellRef
                      }
    {construct-super worksheet}
    set (self.row, self.col, self.row-abs?, self.col-abs?) = {parse-cellref s}
    {self.adjust-to-ref ref}
  }

  {method private {adjust-to-ref ref:#CellRef}:void
    {if-non-null ref then
        {assert self.worksheet == ref.worksheet}
        {if not self.row-abs? then
            set self.row = self.row - ref.row
        }
        {if not self.col-abs? then
            set self.col = self.col - ref.col
        }
    }
  }
    
  {doc-next
    {purpose Create a {docref CellRef} by adding offsets to a reference CellRef.}
    {parameter ref, The reference CellRef.}
    {parameter row-offset, The row offset.}
    {parameter col-offset, The column offset.}
    {notes
        If a row or column of the {param ref} is absolute, the
        row or column of the result will be absolute.

        Normally a {docref CellRef} is created by calling {docref
        WorksheetModel.get-ref}, which will register the reference and
        update it if rows or columns are added or removed.
    }
  }
  {constructor public {relative-to
                          ref:CellRef,
                          row-offset:int, col-offset:int
                      }
    {construct-super ref.worksheet}
    set self.row = ref.row + row-offset
    set self.row-abs? = ref.row-abs?
    set self.col = ref.col + col-offset
    set self.col-abs? = ref.col-abs?
    {self.check-invariants}
  }

  || Override
  {getter public open {absolute?}:bool
    {return (self.row-abs? and self.col-abs?)}
  }

  || Override
  {method public open {adjust
                          row:int, row-count:int,
                          col:int, col-count:int
                      }:void
    {if row-count == 0 and col-count == 0 then
        {return}
    }

    {if row-count < 0 then
        {if self.row >= row - row-count then
            {inc self.row, row-count}
        }
     else
        {if self.row >= row then
            {inc self.row, row-count}
        }
    }

    {if col-count < 0 then
        {if self.col >= col - col-count then
            {inc self.col, col-count}
        }
     else
        {if self.col >= col then
            {inc self.col, col-count}
        }
    }

  }

  {method private {check-reference}:void
    ||FIXME: what should this do?
  }

  {getter public open {value}:any
    {self.check-reference}
    {return {self.worksheet.get-value self.row, self.col}}
  }

  {getter public open {domain}:Domain
    {self.check-reference}
    {return self.worksheet.vals[self.row, self.col].domain}
  }

  {setter public open {value val:any}:void
    ||FIXME: notify observers
    {self.check-reference}
    {self.worksheet.set-value self.row, self.col, val}
  }

  {getter public open {as-String}:String
    {self.check-reference}
    def cv = self.worksheet.vals[self.row, self.col]
    {return
        {if-non-null v = {self.worksheet.get-value self.row, self.col} then
            {cv.domain.format v}
         else
            ""
        }
    }
  }

  {getter public open {as-double}:double
    {self.check-reference}
    {return {any-to-double self.value}}
  }

  || Override
  {getter public open {composite?}:bool
    {return false}
  }
}


{doc-next
    {purpose
        A reference to a range of cells defined by positions
        relative to the target cell of a formula.
    }
}
{define-class public open RelativeRangeRef {inherits ValueRef}

  {doc-next
    {purpose The base row for the range.}
  }
  field public-get protected-set row:int

  {doc-next
    {purpose The base column for the range.}
  }
  field public-get protected-set col:int

  {doc-next
    {purpose The number of rows in the range.}
  }
  field public-get protected-set rows:int

  {doc-next
    {purpose The number of columns in the range.}
  }
  field public-get protected-set cols:int
  
  {doc-next
    {purpose Initialize a new {docref RelativeRangeRef}.}
    {parameter row, This offset is added to the row number
        of the target cell of a formula.
    }
    {parameter col, This offset is added to the column number
        of the target cell of a formula.
    }
    {parameter cols, The number of columns to include in the range.}
    {parameter rows, The number of rows to include in the range.}
  }
  {constructor public {default
                          rows:int,
                          cols:int,
                          row:int = 0,
                          col:int = 0
                      }
    {construct-super 0}
    set self.rows = rows
    set self.cols = cols
    set self.row = row
    set self.col = col
  }

  {method public open {resolve target:DataRef}:DataRef
    {return {target.source.get-ref target, self}}
  }

}

{doc-next
    {purpose Compute a hash value for a {docref RangeRef}.}
}
{define-proc public {RangeRef-hash-proc ref:RangeRef}:int
    let h:int = {CellRef.hash-proc ref.cell1}
    {inc h, {CellRef.hash-proc ref.cell2}}
    {return h}
}

{doc-next
    {purpose Compare two {docref RangeRef}s and return true if they are equal.}
}
{define-proc public {RangeRef-equal-proc a:RangeRef, b:RangeRef}:bool
    {return
        {CellRef.equal-proc a.cell1, b.cell1}
        and {CellRef.equal-proc a.cell2, b.cell2}
    }
}

{doc-next
    {purpose
        Reference to a rectangular range of cells in a {docref Worksheet}.
    }
    {details
        A range is defined by two corners, represented by {docref CellRef}s.

        Note that if the row (or column) of {param cell1} is greater thatn
        the row (or column) of {param cell2} then the range is considered
        empty (iterating through it will yield no values).
    }
}
{define-class public open RangeRef {inherits SheetRef}


  {doc-next
    {purpose
        A constant that indicate that all rows or columns are
        included in a range.
    }
  }
  let public constant all:int = -1

  {doc-next
    {purpose The top left corner of the range.}
  }
  field public-get protected-set cell1:CellRef

  {doc-next
    {purpose The lower right corner of the range.}
  }
  field public-get protected-set cell2:CellRef

  {doc-next
    {purpose Initialize a {docref RangeRef}.}
    {notes
        Normally a {docref CellRef} is created by calling {docref
        WorksheetModel.get-ref}, which will register the reference and
        update it if rows or columns are added or removed.
    }
    {parameter worksheet, The worksheet data that this object refers to.}
    {parameter row, The upper row of the range.}
    {parameter col, The left column of the range.}
    {parameter row2, The lower row of the range.}
    {parameter col2, The right column of the range.}
  }
  {constructor public {default
                          worksheet:WorksheetModel,
                          row:int,
                          col:int,
                          row2:int,
                          col2:int
                      }
    {construct-super worksheet}
    ||FIXME: canonicalize
    set self.cell1 = {CellRef.absolute worksheet, row, col}
    set self.cell2 = {CellRef.absolute worksheet, row2, col2}
  }

  {method public open {resolve target:DataRef}:DataRef
    ||FIXME: NYI
    {return self}
  }

  {doc-next
    {purpose
        Create a new {docref RangeRef} from {docref RelativeRangeRef}
        and a target or reference cell.
    }
    {parameter ref, An absolute cell reference used to determine
        the location of the new range.
    }
    {parameter rr, A relative range that will be adjusted to {param ref}.} 
  }
  {constructor public {from-relative-ref
                          ref:CellRef,
                          rr:RelativeRangeRef
                      }
    {construct-super ref.worksheet}
    {assert ref.absolute?}
    def r0 = ref.row + rr.row
    def c0 = ref.col + rr.col
    def r1 = r0 + rr.rows - 1
    def c1 = c0 + rr.cols - 1
    set self.cell1 = {CellRef.absolute ref.worksheet, r0, c0}
    set self.cell2 = {CellRef.absolute ref.worksheet, r1, c1}
  }

  {doc-next
    {purpose Initialize a {docref RangeRef}.}
    {notes
        Normally a {docref CellRef} is created by calling {docref
        WorksheetModel.get-ref}, which will register the reference and
        update it if rows or columns are added or removed.
    }
    {parameter s, This string should consist of two CellRef
        strings separated by a colon (':'). For example "B3:D9".
        (see {docref CellRef.from-String})
    }
    {parameter ref, If the CellRef strings are relative, they
        are interpreted as relative to this reference cell.
    }
  }
  {constructor public {from-String
                          worksheet:WorksheetModel,
                          s:String,
                          ref:#CellRef
                      }
   
    {construct-super worksheet}
    def cells = {s.split split-chars = {CharClass ".:"}}
    {if cells.size == 3 then
        def sheet = cells[0]
        {cells.remove 0}
        ||FIXME: deal with sheet prefix
    }
    set self.cell1 = {CellRef.from-String worksheet, cells[0], ref}
    set self.cell2 = {CellRef.from-String worksheet, cells[1], ref}
  }

  {doc-next
    {purpose Construct a RangeRef from {docref CellRef}s for the two corners.}
  }
  {constructor public {from-CellRefs
                          cr1:CellRef,
                          cr2:CellRef
                      }
    {if cr1.worksheet != cr2.worksheet then
        {error
            {hlmessage The two arguments must reference the same WorksheetModel.}
        }
    }
    {construct-super cr1.worksheet}
    set self.cell1 = cr1
    set self.cell2 = cr2
  }


  || Override
  {getter public open {absolute?}:bool
    {return self.cell1.absolute? and self.cell2.absolute?}
  }

  || Override
  {method public open {adjust
                          row:int, row-count:int,
                          col:int, col-count:int
                      }:void
    ||FIXME: NYI RangeRef.adjust
  }

  {getter public open {value}:any
    ||FIXME: Is this OK? should be error?
    {return self.cell1.value}
  }

  || Update the value that is the target of this reference
  {setter public open {value val:any}:void
    ||FIXME: notify observers
    ||FIXME: Is this OK? should be error?
    set self.cell1.value = val
  }

  || Get the value that this reference points to as a String
  {getter public open {as-String}:String
    ||FIXME: Is this OK? should be error?
    {return self.cell1.as-String}
  }

  || Get the value that this reference points to asa double
  {getter public open {as-double}:double
    ||FIXME: Is this OK? should be error?
    {return self.cell1.as-double}
  }

  || Override
  {getter public open {composite?}:bool
    {return true}
  }

  {doc-next
    {purpose
        Return an iterator over all of the objects within the range
        specified by this reference.
    }
  }
  {method public open {to-Iterator}:{Iterator-of DataRef}
    {return {RangeIterator self}}
  }
}


{doc-next
    {purpose
        Iterator for the cells covered by a {docref  RangeRef}.
    }
}
{define-class public final RangeIterator
  {inherits {Iterator-of DataRef}, DataRefIteratorMixin}

  field private ref:RangeRef
  field private done?:bool
  field private ri:int
  field private ci:int

  {doc-next
    {purpose Initialize an iterator for the values covered by {param ref}.
    }
  }
  {constructor public {default ref:RangeRef}
    {construct-super.{Iterator-of DataRef}}
    {construct-super.DataRefIteratorMixin}
    set self.ref = ref
    {self.reset}
    {assert ref.cell1.row <= ref.cell2.row and ref.cell1.col <= ref.cell2.col}
  }

  || Override
  {method public open {reset}:void
    set self.done? = false
    set self.ri = self.ref.cell1.row
    set self.ci = self.ref.cell1.col
  }

  || Override
  {method public open {read-one}:(v:DataRef, eof?:bool)
    {if self.done? then
        {return ({uninitialized-value-for-type DataRef}, true)}
    }

    || Get the current value to return
    def nv = {self.ref.cell1.worksheet.get-cell self.ri, self.ci}
    {self.set-ref nv.value, nv.domain}

    || Increment for next call
    {inc self.ci}
    {if self.ci > self.ref.cell2.col then
        set self.ci = self.ref.cell1.col
        {inc self.ri}
    }
    {if self.ri > self.ref.cell2.row then
        set self.done? = true
    }
    {return (self.value-ref, false)}
  }
}

|| ---------------------------------------------------------------------------

||--{define-class public open WorksheetRefTable
||--
||--  field protected row-hash:{HashTable-of int, CellRef} =
||--      {new {HashTable-of int, CellRef}}
||--
||--  field protected col-hash:{HashTable-of int, CellRef} =
||--      {new {HashTable-of int, CellRef}}
||--
||--  field protected cell-hash:{HashTable-of int, CellRef} =
||--      {new {HashTable-of int, CellRef}
||--        key-hash-proc = cellref-hash-proc,
||--        key-equality-proc = cellref-equal-proc
||--      }
||--
||--  || FIXME: Doing a linear search for ranges. Need something better eventaully.
||--  field protected ranges:{Array-of RangeRef} = {new {Array-of RangeRef}}
||--
||--  {constructor public {default}
||--  }
||--
||--  || Return an interned CellRef for the cell at row,col
||--  {method public open {get-cell-ref row:int, col:int}:CellRef
||--    def (ref, found?) = {self.cell-hash.get-if-exists row * max-cols + col}
||--    {if found? then
||--        {return ref}
||--     else
||--        def ref = {CellRef.absolute row, col}
||--        set self.cell-hash[row * max-cols + col] = ref
||--        {return ref}
||--    }
||--  }
||--
||--  || Return all interned RangeRefs that overlap row,col
||--  {method public open {get-range-refs row:int, col:int}:{Array-of RangeRef}
||--  }
||--
||--  || Remove all refs
||--  {method public open {clear}:
||--  }
||--
||--  || Adjust any refs that overlap count rows at row.
||--  {method public open {adjust-rows row:int count:int}:void
||--  }
||--
||--  || Adjust any refs that overlap count columns at col.
||--  {method public open {adjust-cols col:int count:int}:void
||--  }
||--
||--  || Get ref
||--  {method public open {get-}:
||--  }
||--
||--  || 
||--  {method public open {}:
||--  }
||--
||--
||--}

|| ---------------------------------------------------------------------------

{doc-next
    {purpose
        When inserted in a particular cell, it specifies that
        adjacent rows or columns should be grouped together in a
        {docref GroupTree}.
    }
}
{define-value-class public final GroupProto

  {doc-next
    {purpose 
        If true, it specifies a group of rows. Otherwise, a group
        of columns.
    }
  }
  field public constant row?:bool

  {doc-next
    {purpose The number of rows or columns that are in the group.}
  }
  field public constant span:int

  {doc-next
    {purpose Create an object to specify a group of rows or columns.}
  }
  {constructor public {default
                          row?:bool,
                          span:int
                      }
    set self.row? = row?
    set self.span = span
  }
}


||FIXME: GroupSpec could contain links to parent if that helps performance
{doc-next
    {purpose
        Specifies parameters for a group of rows or columns in a
        {docref GroupTree}.
    }
}
{define-class public open GroupSpec

  {doc-next
    {purpose If true it means this is a group of rows.}
  }
  field public row?:bool

  {doc-next
    {purpose The nesting depth for this group.}
  }
  field public level:int

  {doc-next
    {purpose The first row or column in the group.}
  }
  field public first:int

  {doc-next
    {purpose The last row or column in the group.}
  }
  field public last:int

  {doc-next
    {purpose The container for this group.}
  }
  field public group-tree:#GroupTree


  {doc-next
    {purpose Indicates if this group is expanded (showing all members) or not.}
  }
  field protected _expanded?:bool = true

  {doc-next
    {purpose Returns true if the group is in the expanded state.}
  }
  {getter public open {expanded?}:bool
    {return self._expanded?}
  }
  {setter public open {expanded? v:bool}:void
    set self._expanded? = v
    {if-non-null gt = self.group-tree then
        {inc gt.edit-count}
    }
  }

  {doc-next
    {purpose Initialize a {docref GroupSpec} to specify one node
        in the row or column group tree.
    }
    {details Usually row and column groups are created by calling
        {docref row-group} and {docref col-group}.
    }
    {parameter row?, If true it means that this represents a group of rows.}
    {parameter level, The depth of the group, where 0 is the root level.}
    {parameter first, The first row or column in the group.}
    {parameter last, The last row or column in the grup.}
    {parameter expanded?, If true, it means the group is in the expanded state.}
  }
  {constructor public {default
                          row?:bool,
                          level:int,
                          first:int,
                          last:int,
                          expanded?:bool = true
                      }
    {if level < 0 then
        {IllegalArgumentException
            {hlmessage level must be 0 or greater.}
        }
    }
    {if first > last then
        {IllegalArgumentException
            {hlmessage The argument first must be less than or equal to last.}
        }
    }
    set self.row? = row?
    set self.level = level
    set self.first = first
    set self.last = last
    set self.expanded? = expanded?
  }

  {doc-next
    {purpose Return true if the group contains index {param n}.}
  }
  {method public open {contains? n:int}:bool
    {return (self.expanded? and n >= self.first and n <= self.last)
        or n == self.first
    }
  }

  ||FIXME: handle deletes that remove entire groups
  {method protected open {adjust
                             pos:int, count:int
                         }:void
    {if count == 0 then
        {return}
    }
    {if pos <= self.first then
        || Inserting before this group
        {inc self.first, count}
        {inc self.last, count}
     elseif pos <= self.last then
        || Inserting within this group
        {inc self.last, count}
        {assert self.last >= self.first} || Can't delete beyond end of group
        || NOTE: must remove the group first
    }
  }

  {method public open {object-describe
                          out:TextOutputStream,
                          locale:Locale
                      }:void
    {format out = out, locale = locale,
        "[GroupSpec level=%s first=%s last=%s]",
        self.level, self.first, self.last
    }
  }

}

{doc-next
    {purpose
        An array of {docref GroupSpec}
    }
}
{def GroupSpecArray = {Array-of GroupSpec}}


{doc-next
    {purpose
        Represents a hierarchy of groups of rows or columns in a
        {docref Worksheet}.
    }
}
{define-class public open GroupTree {inherits RefreshMixin}
  {doc-next
    {purpose A counter that is incremented any time the tree is changed.}
  }
  field protected edit-count:int = 0

  {doc-next
    {purpose Contains an array of groups for each level in the tree.}
  }
  field protected levels:{Array-of GroupSpecArray} =
      {new {Array-of GroupSpecArray}}

  {doc-next
    {purpose Return the number of levels in the group tree.}
  }
  {getter public open {depth}:int
    {return self.levels.size}
  }

  {doc-next
    {purpose Create an empty {docref GroupTree}.}
  }
  {constructor public {default}
  }

||--  {method public open {validate group:GroupSpec}:bool
||--    {return true}||FIXME: NYI
||--  }

  {doc-next
    {purpose
        Return group at {param level} that includes both {param i}
        and {param j}, if any, or null otherwise.
    }
  }
  {method public open {get-group
                          level:int, i:int, j:int
                      }:#GroupSpec
    ||FIXME: Could sort and use a binary search if performance is a problem
    {if level < self.depth then
        {for group in self.levels[level] do
            {if i >= group.first and i <= group.last then
                {if j > group.last then
                    {throw
                        {IllegalArgumentException
                            {hlmessage 
                                Upper bound not included in group that
                                contains lower bound.
                            }
                        }
                    }
                }
                {return group}
            }
        }
    }
    {return null}
  }

  {doc-next
    {purpose Insert {param group} into this group tree.}
  }
  {method public open {insert-group group:GroupSpec}:GroupSpec
    {self.update}
    set group.group-tree = self
    def missing-parent =
        {hlmessage
            There is no parent group to contain the new group.
        }
    def group-interferes =
        {hlmessage Group interferes with existing group.}

    {if group.level > self.depth then
        {error missing-parent}
     elseif self.depth == 0 then
        || The very first group
        {self.levels.append {GroupSpecArray group}}
     else
        {if group.level == self.depth then
            {self.levels.append {GroupSpecArray}}
        }
        {if group.level > 0 then
            {if {self.get-group
                    group.level - 1, group.first, group.last
                } != null
             then
                || There is a parent. Does this overlap anything at same level?
                {try
                    {for n = group.first to group.last do
                        {if-non-null {self.get-group group.level, n, n}
                         then
                            {error group-interferes}
                        }
                    }
                 catch e:Exception do
                    {error group-interferes}
                }
             else
                {error missing-parent}
            }
         else
            {for n = group.first to group.last do
                {if-non-null {self.get-group 0, n, n}
                 then
                    {error group-interferes}
                }
            }
        }
        def groups = self.levels[group.level]
        {for g key gi in groups do
            {if group.first <= g.first then
                {groups.insert group, gi}
                {return group}
            }
        }
        {groups.append group}
    }
    {return group}
  }

  {doc-next
    {purpose
        Return an iterator over the groups at the nesting depth given by
        {param level}.
    }
  }
  {method public open {get-Iterator level:int}:{Iterator-of GroupSpec}
    {return {self.levels[level].to-Iterator}}
  }

  {doc-next
    {purpose Modify the tree to account for inserting (or deleting, if
        {param count} is negative) items.
    }
  }
  {method public open {adjust pos:int, count:int}:void
    {if count == 0 then
        {return}
    }
    {self.update}
    {for gsa in self.levels do
        {for gs in gsa do
            {if pos < gs.first then
                {inc gs.first, count}
                {inc gs.last, count}
             elseif pos > gs.last + 1 then
                || do nothing
             else
                {inc gs.last, count}
            }
        }
    }
  }


  field private last-edit-count:int
  field private index-size:int||FIXME: sync this with the model size
  field private position-map:#{Array-of int}
  field private index-map:#{Array-of int}

  {doc-next
    {purpose
        Rebuild the maps from position to index and back.
    }
  }
  {method public open {refresh}:void
    {if self.position-map == null or
        self.last-edit-count != self.edit-count
     then
        {self.make-position-map}
        {self.make-index-map}
        set self.last-edit-count = self.edit-count
    }
  }

  || Override
  {method public open {update}:void
    {super.update}
    {inc self.edit-count}
  }

  {doc-next
    {purpose Return an iterator over the visible indexes in the group tree.}
  }
  {method public open {to-Iterator}:{Iterator-of int}
    {return {GroupTreeIterator self}}
  }

  || Array such that a[index-in-model] = position-in-grid
  {method private {make-position-map}:void
    def last = self.index-size
    def map = {new {Array-of int}, efficient-size = last}
    def gti = {GroupTreeIterator self}
    let last-i:int = 0
    {for i in gti do
        {for i = last-i + 1 below i do
            {map.append -1}
            {if map.size >= last then
                {break}
            }
        }
        {if map.size < last then
            {map.append gti.count - 1}
        }
        {if map.size >= last then
            {break}
        }
        set last-i = i
    }
    set self.position-map = map
  }

  {method private {make-index-map}:void
    def last = self.index-size
    def map = {new {Array-of int}, efficient-size = last}
    def gti = {GroupTreeIterator self}
    || Map with iterator results - just the visible numbers
    {for i in gti do
        {if map.size > last then
            {break}
        }
        {map.append i}
    }
    set self.index-map = map
  }

  {doc-next
    {purpose An array that maps a position to an index.}
  }
  {method public open {get-position-map last:int}:{Array-of int}
    {if self.index-size < last then
        set self.index-size = last
        {self.update}
    }
    {self.refresh}
    {return {non-null self.position-map}}
  }

  {doc-next
    {purpose
        Return an array that maps a position to the corresponding index.
    }
    {details
        If no groups are collapsed, the mapping is the identity
        (position and index are the same). If there is one group of
        three starting at 0 ({ctext {GroupSpec 0,3}}) and collapsed,
        then the resulting array is (0, 3, 4). This means that
        position 0 corresponds to index 0, position 1 to index 3
        (because two items are hidden), and position 2 corresponds to
        index 4.
    }
  }
  {method public open {get-index-map last:int}:{Array-of int}
    {if self.index-size < last then
        set self.index-size = last
        {self.update}
    }
    {self.refresh}
    {return {non-null self.index-map}}
  }

  {doc-next
    {purpose Map a position in a cell grid to an index in the data model.}
  }
  {method public open {map-position-to-index pos:int}:int
    {if self.index-size <= pos then
        set self.index-size = pos + 1
        {self.update}
    }
    {self.refresh}
    {return self.index-map[pos]}
  }

  {doc-next
    {purpose Map an index in the data model to a position in the cell grid.}
  }
  {method public open {map-index-to-position i:int}:int
    {if self.index-size <= i then
        set self.index-size = i + 1
        {self.update}
    }
    {self.refresh}
    {return self.position-map[i]}
  }

  {doc-next
    {purpose
        Return true if the cell the given {param index} in the data model
        not within a collapsed row or column group.
    }
  }
  {method public open {visible? index:int}:bool
    {return {self.map-index-to-position index} >= 0}
  }

  {doc-next
    {purpose
        Given an index {param i} within the data model, return the corresponding
        position in a grid, taking account of collapsed groups.
    }
  }
  {method public open {visible-position i:int, below?:bool = false}:int
    {while not {self.visible? i} do
        {if below? then
            {dec i}
         else
            {inc i}
        }
        {if i < 0 or i >= self.index-size then
            {return -1}
        }
    }
    {return {self.map-index-to-position i}}
  }
}


{doc-next
    {purpose
        Iterator for visible index values in a {docref GroupTree}.
    }
}
{define-class public open GroupTreeIterator {inherits {Iterator-of int}}

  {doc-next
    {purpose The tree that will be iterated over.}
  }
  field protected tree:GroupTree

  {doc-next
    {purpose If true it means that the iteration is complete.}
  }
  field protected done?:bool

  {doc-next
    {purpose The next item in the iteration.}
  }
  field protected next:int

  {doc-next
    {purpose The current level in the tree.}
  }
  field protected level:int

  {doc-next
    {purpose The current group being iterated through.}
  }
  field protected group:#GroupSpec

  {doc-next
    {purpose
        If non-negative, indicates that the iteration should terminate
        after this index is returned.
    }
  }
  field public-get protected-set last:int


  {doc-next
    {purpose The number of results returned so far.}
  }
  field public-get protected-set count:int


  {doc-next
    {purpose The number of items skipped so far.}
  }
  field public-get protected-set skipped:int

  {doc-next
    {purpose The current index.}
  }
  field public-get protected-set current:int

  {doc-next
    {purpose Initialize an iterator over the visible indices of
        {param tree}.
    }
    {notes
        The purpose of this iterator is to iterate over indices while
        skipping those that are within collapsed groups (the first
        member of a group is always visible, however, unless a parent
        node is collapsed). As such, there is no intrinsic limit to
        the iteration. The {param last} argument to the constructor
        allows you to specify a limit.
    }
    {parameter tree, The {docref GroupTree} to be iterated over.}
    {parameter last, An optional limit for iteration.}
  }
  {constructor public {default
                          tree:GroupTree,
                          last:int = -1
                      }
    set self.tree = tree
    set self.last = last
    {self.reset}
  }

  {method public open {reset}:void
    set self.done? = false
    set self.next = 0
    set self.group = null
    set self.level = 0
    set self.count = 0
    set self.current = 0
  }
  
  {doc-next
    {purpose Find the innermost group containing {ctext self.next}.}
  }
  {method private {find-current-group}:#GroupSpec
    let group:#GroupSpec = null
    {for level = 0 below self.tree.depth do
        {if-non-null g =
            {self.tree.get-group level, self.next, self.next}
         then
            set group = g
            {if not g.expanded? then
                {break}
            }
         else
            {break}
        }
    }
    {return group}
  }

  {doc-next
    {purpose Return the number of visible indices returned so far.}
  }
  {getter {current-pos}:int
    {return self.count - 1}
  }

  {method public open {read-one}:(v:int, eof?:bool)
    {if self.done? then
        {return (-1, true)}
    }

    def ngroup = {self.find-current-group}
    {if ngroup != self.group then
        set self.group = ngroup
    }

    set self.current = self.next
    {if self.last >= 0 and self.next >= self.last then
        set self.done? = true
    }

    || Find the next visible item
    {inc self.next}
    let ng:#GroupSpec = self.group
    {while ng != null do
        {if {ng.contains? self.next} then
            {break}
         else
            set self.next = ng.last + 1
            {inc self.skipped, ng.last - ng.first}
            set ng = {self.find-current-group}
        }
    }
||--
||--        {if ng != self.group then
||--            set self.next = ng.first
||--            set self.group = ng
||--         elseif not ng.expanded? then
||--            set self.next = ng.last + 1
||--            set ng = {self.find-current-group}
||--            set self.group = ng
||--         else
||--            {break}
||--        }
||--    }
    {inc self.count}
    {return (self.current, false)}
  }
}

{doc-next
    {purpose
        Specifies the widths or heights of the columns or rows in a 
        {docref Worksheet}.
    }
    {details
        This object contains one size specification for each row or
        column in a {docref Worksheet}. The size is used for the cell
        size and does not include the grid line width.

        The number of specs will match the number the number of rows
        (for a vertical ruler) or columns (for a horizontal ruler) in
        the model. There will be one {docref RulerSpec} for the rows
        and another for the columns.

        This class does not do any change notifications itself.
        Notifications are done by the objects that modify this object.
    }
}
{define-class public open RulerSpec

  {doc-next
    {purpose The sizes specified for each segment of the ruler.}
  }
  field public-get protected-set specs:Array

  {doc-next
    {purpose The {docref Orientation} of the ruler (vertical or horizontal).}
  }
  field protected _orientation:Orientation

  {doc-next
    {purpose
        Splits the ruler into two parts. The sizes up to and including the
        split index correspond to the frozen rows or columns.
    }
  }
  field protected _split-count:int

  {doc-next
    {purpose The {docref Orientation} of the ruler (vertical or horizontal).}
  }
  {getter public open {orientation}:Orientation
    {return self._orientation}
  }

  {doc-next
    {purpose
        Splits the ruler into two parts. The sizes up to and including the
        split index correspond to the frozen rows or columns.
    }
  }
  {getter public open {split-count}:int
    {return self._split-count}
  }
  {setter public open {split-count i:int}:void
    set self._split-count = i
  }

  {doc-next
    {purpose Initialize a new {docref RulerSpec}.}
    {parameter orientation,
        Provides the initial value for {docref RulerSpec.orientation}.
    }
    {parameter split-count,
        Provides the initial value for {docref RulerSpec.split-count}.
    }
    {parameter ...,
        Initial values for the sizes of each segment of the ruler.
        Each value must be a number (interpreted as a number of
        points), a {docref Distance}, or a {docref PixelDistance}.
    }
  }
  {constructor public {default
                          orientation:Orientation,
                          split-count:int,
                          ...
                      }
    set self._orientation = orientation
    set self._split-count = split-count
    set self.specs = {Array {splice ...}}
    {for a key ai in self.specs do
        {self.get-spec-size ai, 0m}
    }
  }

  {doc-next
    {purpose
        Return the specified size of a row (height) or column (width),
        given a row or column number in the model.
    }
  }
  {method public open {get-spec-size i:int, default-size:any}:any
    let spec:any =
        {if i < self.specs.size then
            self.specs[i]
         else
            default-size
        }
    let size:any =
        {if {number? spec} then
            spec asa double * 1pt
         else
            {type-switch spec
             case pd:PixelDistance do
                pd
             case d:Distance do
                d
             else
                {error
                    {hlformat
                        "Size %1!s! must be a Distance or PixelDistance: '%2!s!'",
                        i, spec
                    }
                }
            }
        }

    def n = self.specs.size
    {if i >= n then
        {self.insert n, i - n + 1, size}
    }
    {return size}
  }

  {doc-next
    {purpose
        Change the specified size of a row (height) or column (width),
        given a row or column number in the model and a new size.
    }
    {parameter i, The index of the value to be changed. This is a row
        or column number in the model (0-origin).
    }
    {parameter size, The new size. It must be a number (interpreted as
        a number of points), a {docref Distance}, or a {docref
        PixelDistance}.
    }
  }
  {method public open {set-spec-size i:int, size:any}:any
    {if i >= self.specs.size then
        {return {self.get-spec-size i, size}}
    }
    set self.specs[i] = size
    || Call get-spec-size to check for validity
    {return {self.get-spec-size i, 0m}}
  }

  {doc-next
    {purpose Insert or delete size specifications at the position
        indicated by {param first}. If count is negative, size specs
        are removed.
    }
  }
  {method public open {insert
                          first:int,
                          count:int,
                          size:any
                      }:void
    || Make sure specs exist up to first
    {if first >= self.specs.size then
        def n = first - self.specs.size
        {inc count, n}
        {dec first, n}
    }
    {if count < 0 then
        {self.specs.remove first, length = -count}
     elseif count > 0 then
        {for i = 0 below count do
            def ri = first + i
            {self.specs.insert size, ri}
        }
    }
  }

  {doc-next
    {purpose Return the state of the ruler as a JSON object.}
  }
  {method public open {get-json-data}:JsonObject
    def data = {JsonObject}
    set data["orientation"] = self.orientation.name
    set data["split-count"] = self.split-count
    def sizes:JsonArray = {JsonArray}
    {for i = 0 below self.specs.size do
        {type-switch {self.get-spec-size i, 0m}
         case d:Distance do
            {sizes.append {format "%spt", d/1pt}} ||""
         case pd:PixelDistance do
            {sizes.append {format "%spx", pd/1px}} ||""
         else
            {error "Internal error"} || get-spec-size returned unexpected value
        }
    }
    set data["specs"] = sizes
    {return data}
  }

  {doc-next
    {purpose Restore the state of the ruler from a JSON object.}
  }
  {method public open {put-json-data data:JsonObject}:void
    let s:String = data["orientation"] asa String
    set self._orientation = {if s == "horizontal" then
                               Orientation.horizontal
                            else
                               Orientation.vertical
                           }
    set self.split-count = data["split-count"] asa int
    def sizes = data["specs"]
    let d:any = 0m
    {self.specs.clear}
    {for s key si in sizes asa JsonArray do
        def ds = s asa String
        def (val, nc, err?) = {ds.to-double}
        def suffix = {ds.tail nc}
        {if suffix == "" then
            set d = val * 1pt
         elseif suffix == "px" then
            set d = val * 1px
         elseif suffix == "pt" then
            set d = val * 1pt
         else
            {error {hlmessage "Unexpected value '%s'", s}}
        }
        {self.specs.append d}
    }
  }
}


{doc-next
    {purpose An array of {docref CellValue}s.}
}
{def public ValueArray = {ResizableArray-of CellValue}}


{doc-next
    {purpose
        Represents one cell value in a {docref WorksheetModel}.
    }
}
{define-class public open CellValue

  {doc-next
    {purpose The current value of the cell.}
  }
  field protected _value:any = null    || Current cell value

  {doc-next
    {purpose Specifies properties and initial value of the cell.}
  }
  field public spec:#CellSpec = null   || Cell attributes


  {doc-next
    {purpose The current rowspan for the cell.}
  }
  field protected _rowspan:int

  {doc-next
    {purpose The current colspan for the cell.}
  }
  field protected _colspan:int

  {doc-next
    {purpose The formula associated with the cell, if any.}
  }
  field protected _formula:#Formula  || Formula, if any

  {doc-next
    {purpose If true, there was a computation error in this cell.}
  }
  field public error?:bool        || Error setting or editing value

  {doc-next
    {purpose
        If true, it means the cell is covered by another cell that
        spans more than one row or column.
    }
  }
  field public covered?:bool      || due to row/colspan

  {doc-next
    {purpose If true, it means the cell has an active editor.}
  }
  field public editing?:bool

  {doc-next
    {purpose The templat for an embedded form that is anchored at this cell.}
  }
  field public embedded-form:#EmbeddedRecordForm

  {doc-next
    {purpose The {docref Domain} for the value of this cell.}
  }
  {getter public {domain}:Domain
    {return
        {if-non-null spec = self.spec then
            spec.domain
         else
            {DataSource.get-default-domain self.value}
        }
    }
  }

  {doc-next
    {purpose Indicates if the value can be edited in the {docref Worksheet}.}
  }
  {getter public {editable?}:bool
    {return
        {if-non-null spec = self.spec then
            spec.editable?
         else
            false
        }
    }
  }

  {doc-next
    {purpose
        If the cell is locked, it means that it is always displaying an
        editor (if it is editable), or it never displays an editor.
    }
  }
  {getter public {locked?}:bool
    {return
        {if-non-null spec = self.spec then
            spec.locked?
         else
            false
        }
    }
  }

  {doc-next
    {purpose A convenient way to get the {docref CellSpec.ui-spec} property
        for this cell.
    }
  }
  {getter public {ui-spec}:any
    {return
        {if-non-null spec = self.spec then
            spec.ui-spec
         else
            null
        }
    }
  }

  {doc-next
    {purpose
        These options are specified when the cell is created and applied
        when the cell changes state (display or edit).
    }
  }
  {getter public {options}:#Arguments
    {return
        {if-non-null spec = self.spec then
            spec.options
         else
            null
        }
    }
  }

  {doc-next
    {purpose
        If this cell represents a field in an {docref EmbeddedRecordForm},
        return the {docref FieldSpec} that describes the field.
    }
  }
  {getter public {field-spec}:#FieldSpec
    {if-non-null spec = self.spec then
        {if spec isa FieldSpec then
            {return spec asa FieldSpec}
        }
    }
    {return null}
  }


  {doc-next
    {purpose Create a new {docref CellValue}.}
    {parameter value, the initial value of the cell}
    {parameter spec, An object that specifies the properties of the cell.}
    {parameter editing?, If true, the cell will start out in the editing state.}
    {parameter rowspan, The number of rows to be used to display the cell.}
    {parameter colspan, The number of columns to be used to display the cell.}
  }
  {constructor public {default
                          value:any = null,
                          spec:#CellSpec = null,
                          editing?:bool = false,
                          rowspan:int = 1,
                          colspan:int = 1
                      }
    set self.value = value
    set self.spec = spec
    set self.editing? = editing?
    set self.rowspan = rowspan
    set self.colspan = colspan
  }

  {doc-next
    {purpose
        Return the string that results from using the {docref-abbr
        CellValue.domain} to format the value of this cell.
    }
  }
  {getter public open {formatted-value}:String
    {if-non-null self._value then
        {return {self.domain.format self._value}}
     else
        {return ""}
    }
  }

  {doc-next
    {purpose The value of this cell.}
  }
  {getter public open {value}:any
    {return self._value}
  }

  {setter public open {value v:any}:void
    let err:#Exception = null
    let dv:any = null
    {try
        set dv = {self.domain.convert v}
     catch e:Exception do
        set err = e
    }
    {if err == null then
        set err = {self.domain.validate dv}
    }
    {if err == null then
        set self._value = dv
        set self.error? = false
     else
        set self._value = null
        set self.error? = true
    }
  }

  {doc-next
    {purpose
        Attempt to convert {param v} into the domain of this cell.
        The result is null if this is not possible.
    }
  }
  {method public open {domain-value v:any}:any
    let err:#Exception = null
    let dv:any = null
    {try
        set dv = {self.domain.convert v}
     catch e:Exception do
        set err = e
    }
    {if err == null then
        set err = {self.domain.validate dv}
    }
    {if err != null then
        set dv = null
    }
    {return dv}
  }

  {doc-next
    {purpose Return true if the value of this cell is numeric.}
  }
  {getter public open {number?}:bool
    {return {number? self.domain.default-value}}
  }

  {doc-next
    {purpose Return the value of this cell as a double value.}
  }
  {getter public open {numval}:double
    {if self.number? then
        {return self.value asa double}
     else
        {return {any-to-double self.value}}
    }
  }

  {doc-next
    {purpose Return the value of tis cell as a String.}
  }
  {getter public open {strval}:String
        {return {self.domain.format self.value}}
  }

  {doc-next
    {purpose Apply the options associated with this cell to {param v}.}
  }
  {method public open {apply-options v:Visual}:void
    {if-non-null options = self.options then
        {for (a,k) in options do
            {if-non-null k then
                {if k == "halign" then
                    {try
                        {v.set-option-by-name k, a}
                     catch ignored:Exception do
                    }
                 else
                    {v.set-option-by-name k, a}
                }
             else
                {error "Internal error"} || Should have been caught earlier
            }
        }
    }
  }

  {doc-next
    {purpose
        For each option associated with this cell, unset the option
        on {param v}.
    }
  }
  {method public open {unset-options v:Visual}:void
    {if-non-null options = self.options then
        {for (a,k) in options do
            {if-non-null k then
                {if k == "width" then
                 elseif k == "height" then
                 else
                    {v.unset-option-by-name k}
                }
             else
                {error "Internal error"} || Should have been caught earlier
            }
        }
    }
  }

  {doc-next
    {purpose Clear the information that comes from the {docref-abbr
        CellValue.field-spec}.
    }
    {details
        When records are deleted, this method is used to reset the cell
        values.
    }
  }
  {method public open {clear-form-cell}:void
    set self.value = null
    set self._rowspan = 1
    set self._colspan = 1
    set self._formula = null
    set self.error? = false
    set self.covered? = false
    set self.editing? = false

    ||FIXME: You can't clear this or adding a record to an embedded
    || form won't work. Should there be another method? Same for ui-spec
||--    set self.embedded-form = null
  }

  {doc-next
    {purpose Store a {docref Formula} on this cell.}
  }
  {setter public open {formula fval:#Formula}:void
    set self._formula = fval
  }

  {getter public open {formula}:#Formula
    {return self._formula}
  }

  {doc-next
    {purpose
        The number of rows occupied by this cell when it is displayed
        in the grid.
    }
  }
  {setter public open {rowspan val:int}:void
    ||FIXME: update the self.covered? flags for adjacent cells (on WorksheetModel)
    set self._rowspan = val
  }

  {getter public open {rowspan}:int
    {return self._rowspan}
  }

  {doc-next
    {purpose
        The number of columns occupied by this cell when it is displayed
        in the grid.
    }
  }
  {setter public open {colspan val:int}:void
    ||FIXME: update the self.covered? flags for adjacent cells (on WorksheetModel)
    set self._colspan = val
  }

  {getter public open {colspan}:int
    {return self._colspan}
  }
}


{doc-next
    {purpose
        Enumerate the operations on a worksheet that might need to
        be described in a notification message.
    }
}
{define-enum WorksheetOpcode
    none,
    insert-rows,    || a is first, b is count
    insert-cols,    || a is first, b is count
    toggle-group,   || a is row, b is col
    recalc          || a, b ignored. sender.row/col-min/max describes changes
}

||FIXME: Incomplete. Add more docstrings if it survives.
{doc-next
    {purpose
        A record of an operation on a {docref Worksheet}.
    }
}
{define-class public open WorksheetOperation
  field public operation:WorksheetOpcode
  field a:int
  field b:int
  field c:any

  {constructor public {default
                          operation:WorksheetOpcode,
                          a:int,
                          b:int,
                          c:any = null
                      }
    set self.operation = operation
    set self.a = a
    set self.b = b
    set self.c = c
  }

  {method public open {reset}:void
    set self.operation = WorksheetOpcode.none
    set self.a = -1
    set self.b = -1
    set self.c = null
  }

  {method public open {clone}:WorksheetOperation
    {return {WorksheetOperation self.operation, self.a, self.b, c = self.c}}
  }

  {method public open {to-String}:String
    {return {format "Operation:%s a:%s b:%s c:%s", ||""
                self.operation.name, self.a, self.b, self.c
            }
    }
  }
}

|| Note: models are easy to test. Put as much logic as possible in the model.

{doc-next
    {purpose The data model for a {docref Worksheet}.}
}
{define-class public open WorksheetModel {inherits DataSource, CalcMixin}

  {doc-next
    {purpose The maximum number of columns in a {docref Worksheet}.}
  }
  {def public max-cols = 1000}

  {doc-next
    {purpose The maximum number of rows in a {docref Worksheet}.}
  }
  {def public max-rows = 10000}

  {doc-next
    {purpose
        A version string to be used by the {docref WorksheetModel.migrate}
        method.
    }
  }
  field protected _data-version:String = ""


  {doc-next
    {purpose
        A name for the data model. It is stored in the JSON
        representation of the module (see
        {docref-abbr WorksheetModel.get-data} and
        {docref-abbr WorksheetModel.put-data}).
    }
  }
  field protected _model-name:String = ""


  ||FIXME: not supported yet.
  {doc-next
    {purpose A record of the last operation performed.}
  }
  field public-get protected-set last-operation:WorksheetOperation


  {doc-next
    {purpose A counter that is incremented each time the model is changed.}
  }
  field public-get protected-set change-count:int


  {doc-next
    {purpose An array to hold the cell values values.}
  }
  field public-get protected-set vals:ValueArray


  {doc-next
    {purpose A {docref GroupTree} for row groups.}
  }
  field public-get protected-set row-tree:GroupTree


  {doc-next
    {purpose A {docref GroupTree} for column groups.}
  }
  field public-get protected-set col-tree:GroupTree


  {doc-next
    {purpose The embedded forms in this model.}
    {notes
        Embedded forms cannot appear on the same row, so this array
        only has one column. It uses a {ctext ResizableArray-of} because
        it can be easily expanded and contracted when rows are added
        or removed.
    }      
  }
  field protected embedded-forms:{ResizableArray-of #EmbeddedRecordForm}

  {doc-next
    {purpose The number of rows in the model.}
  }
  {getter public open {rows}:int
    {return self.vals.rows}
  }

  {doc-next
    {purpose The number of columns in the model.}
  }
  {getter public open {cols}:int
    {return self.vals.cols}
  }


  {doc-next
    {purpose A table of the CellRefs used in formulas.}
  }
  field protected cellrefs:{OrderedSet-of CellRef,
                             key-hash-proc = CellRef.hash-proc,
                             key-equality-proc = CellRef.equal-proc
                           }

  {doc-next
    {purpose A table of the CellRefs used in formulas.}
  }
  field protected rangerefs:{OrderedSet-of RangeRef,
                             key-hash-proc = RangeRef-hash-proc,
                             key-equality-proc = RangeRef-equal-proc
                           }


  {doc-next
    {purpose Specifies the widths of the columns.}
  }
  field public-get protected-set h-ruler-spec:#RulerSpec = null

  {doc-next
    {purpose Specifies the heights of the rows.}
  }
  field public-get protected-set v-ruler-spec:#RulerSpec = null

  {doc-next
    {purpose Create an {docref WorksheetModel} with an initial size
        of {param rows} by {param cols}.
    }
    {parameter rows, The number of rows in the model.}
    {parameter cols, The number of columns in the model.}
  }
  {constructor public {default
                          rows:int,
                          cols:int
                      }
    {construct-super.DataSource}
    {construct-super.CalcMixin}

    set self.vals = {ValueArray rows, cols}
    set self.row-tree = {GroupTree}
    {self.row-tree.get-position-map rows}
    set self.col-tree = {GroupTree}
    {self.col-tree.get-position-map cols}

    set self.embedded-forms = {{ResizableArray-of #EmbeddedRecordForm} rows, 1}

    set self.cellrefs = {new {OrderedSet-of CellRef,
                                 key-hash-proc = CellRef.hash-proc,
                                 key-equality-proc = CellRef.equal-proc
                             }
                        }
    set self.rangerefs = {new {OrderedSet-of RangeRef,
                                 key-hash-proc = RangeRef-hash-proc,
                                 key-equality-proc = RangeRef-equal-proc
                             }
                        }
    {for ri = 0 below rows do
        {for ci = 0 below cols do
            set self.vals[ri, ci] = {CellValue}
        }
    }
    set self.last-operation = {WorksheetOperation "none", -1, -1}

||--    set self.rangerefs = {new {Array-of RangeRef}}

||--    || To support refs to "foreign" DataSources FIXME: NYI
||--    set self.sources = {new {HashTable-of String, DataSource}}

  }

  {method protected open {note-operation
                             operation:WorksheetOpcode,
                             a:int,
                             b:int,
                             c:any = null
                         }:void
||--    {dump self.last-operation.operation, operation}
    {inc self.change-count}
    set self.last-operation.operation = operation
    set self.last-operation.a = a
    set self.last-operation.b = b
    set self.last-operation.c = c
    set self.changed-row-min = self.rows
    set self.changed-row-max = 0
    set self.changed-col-min = self.cols
    set self.changed-col-max = 0
    {self.update}
  }

  {doc-next
    {purpose Return the embedded form at {param row} and {param col}, if any.}
    {parameter row, The row that contains the embedded form.}
    {parameter col, The column that contains the embedded form. If {param col}
        is -1 then it is ignored and if there is an embedded form anywhere
        on the row, it is returned.
    }
  }
  {method public open {get-embedded-form row:int, col:int}:#EmbeddedRecordForm
    {if-non-null erf = self.embedded-forms[row, 0] then
        {if erf.base-col == col or col == -1 then
            {return erf}
        }
    }
    {return null}
  }

  {doc-next
    {purpose Store the {docref EmbeddedRecordForm} for future use.}
  }
  {method public open {store-embedded-form erf:#EmbeddedRecordForm}:void
    {if-non-null xerf = self.embedded-forms[erf.base-row, 0] then
        {if xerf.base-col != erf.base-col then
            {error
                {hlformat
                    "An EmbeddedRecordForm already exists on row %s.", erf.base-row
                }
            }
        }
    }
    set self.embedded-forms[erf.base-row, 0] = erf
  }

  {doc-next
    {purpose Insert {param count} empty rows at the row indicated by
        {param first}, pushing existing rows down to make room. If
        count is negative, rows are removed.
    }
    {parameter first, The position where rows will be added or
        deleted. The value must range between 0 and the number of
        rows currently in the model, or {docref ArrayBoundsException}
        will be thrown.
    }
    {parameter count, If positive, the number of rows to be
        added. If negative, the number of rows to be removed.
    }
  }
  {method public open {insert-rows first:int, count:int}:void

    || Adjust the row tree
    {self.row-tree.adjust first, count}

    || Insert/delete rows from the vals array
    {self.vals.insert-rows first, count,
        init-proc = {proc {r:int, c:int}:CellValue
                        {return {CellValue}}
                    }
    }

    || Adjust embedded form info
    {for i = first + 1 below self.embedded-forms.rows do
        {if-non-null erf = self.embedded-forms[i, 0] then
            {inc erf.base-row, count}
        }
    }

    || Insert rows without moving the EmbeddedRecordForm
    {if first < self.embedded-forms.rows
        and first < self.embedded-forms.rows + count
     then
        def erf = self.embedded-forms[first, 0]
        set self.embedded-forms[first, 0] = null
        {self.embedded-forms.insert-rows first, count}
        set self.embedded-forms[first, 0] = erf
     else
        || Adding or removing at the end - can't move form
        {self.embedded-forms.insert-rows first, count}
    }

    || Adjust the CellRefs
    {for cr in self.cellrefs do
        {cr.adjust first, count, 0, 0}
    }

    || Adjust the RangeRefs
    ||FIXME: NYI - Adjust the RangeRefs

    || Notify
    {self.note-operation WorksheetOpcode.insert-rows, first, count}
  }

  {doc-next
    {purpose Insert {param count} empty columns at the column indicated by
        {param first}, pushing existing columns right to make room. If
        count is negative, columns are removed.
    }
    {parameter first, The position where columns will be added or
        deleted. The value must range between 0 and the number of
        columns currently in the model, or {docref ArrayBoundsException}
        will be thrown.
    }
    {parameter count, If positive, the number of columns to be
        added. If negative, the number of columns to be removed.
    }
  }
  {method public open {insert-cols first:int, count:int}:void
    || Adjust the column tree
    {self.col-tree.adjust first, count}

    || Insert/delete rows from the vals array
    {self.vals.insert-cols first, count,
        init-proc = {proc {r:int, c:int}:CellValue
                        {return {CellValue}}
                    }
    }

    || Adjust embedded form info
    {for erf in self.embedded-forms do
        {if-non-null erf then
            {if erf.base-col > first then
                {inc erf.base-col, count}
            }
            {if erf.base-col == first then
                def cv = self.vals[erf.base-row, erf.base-col]
||--                {dump "DEBUG: Moving erf", erf.base-row, erf.base-col, cv.embedded-form, erf}
                set cv.embedded-form = erf
            }
        }
    }

    || Adjust the CellRefs
    {for cr in self.cellrefs do
        {cr.adjust 0, 0, first, count}
    }

    || Adjust the RangeRefs
    ||FIXME: NYI - Adjust the RangeRefs

    || Notify
    {self.note-operation WorksheetOpcode.insert-cols, first, count}
  }


  {method private {invalid-get-ref}:void
    {error
        {hlmessage Too many positional arguments.}
    }
  }


  {doc-next
    {purpose Create a reference to a cell or range of cells in
        the cell array.
    }
    {details
        There are several ways to specify a cell or range of
        cells.

        The simplest way to specify the cell is to use the
        row and col keyword arguments

        {ctext def ref = {wks.get-ref row = 1, col = 4}}

        Rows and columns are numbered from 0, so this will create an
        absolute reference to the cell on the second row, fifth
        column.

        A cell may be also be specified as a string, using the same
        notation as Excel.  The following call is another way to
        specify the same reference:

        {ctext def ref = {wks.get-ref "E2"}}

        (Technically, this would be a relative reference in Excel.
        But since the default value of the {param absolute?} keyword
        argument to {docref WorksheetModel.get-ref} is true, it
        will produce an absolute reference here.)

        You can also specify a reference as relative to some other
        reference. For example, this is a reference to the cell
        above {param ref}.

        {ctext def above-ref = {wks.get-ref ref, row = -1}}

    }
  }
  ||FIXME: docstring needs to mention RelativeCell/RangeRef
  {method public open {get-ref
                          ...
                      }:SheetRef
    let row:int = 0
    let col:int = 0
    let row?:bool = false
    let col?:bool = false

    let cref:#CellRef = null
    let oref:#CellRef = null
    let rref:#RangeRef = null
    let rrr:#RelativeRangeRef = null

    let absolute?:bool = true || {get-ref row = r, col = c}

    || Postitional arguments
    || int, int            => row, col (absolute? also used)
    || CellRef             => make absolute if absolute? is true
    || CellRef, int, int   => absolute + offset (error if not absolute?)
    || RangeRef            => make absolute if absolute? is true
    || CellRef, CellRef    => absolute + relative (error if not absolute?)
    || CellRef, RangeRef   => absolute + relative (error if not absolute?)

    let argn:int = 0
    {for (a,k) in ... do
        {if-non-null k then
            {if k == "row" then
                set row = a asa int
                set row? = true
             elseif k == "column" or k == "col" then
                set col = a asa int
                set col? = true
             elseif k == "absolute?" then
                set absolute? = a asa bool
            }
         else
            {type-switch a
             case n:int do
                {if row? and col? then
                    {error
                        {hlformat "Unexpected int parameter %s.", n}
                    }
                 elseif not row? then
                    set row = n
                    set row? = true
                 elseif not col? then
                    set col = n
                    set col? = true
                }

             case ref-str:String do
                {if {ref-str.find ':'} >= 0 then
                    set rref = {RangeRef.from-String self, ref-str, cref}
                 else
                    def cr = {CellRef.from-String self, ref-str, cref}
                    {if-non-null cref then
                        set oref = cr
                     else
                        set cref = cr
                    }
                }

             case r:RelativeRangeRef do
                {if not rref == null then
                    {error
                        {hlmessage Only one RangeRef is allowed.}
                    }
                }
                set rrr = r

             case r:RangeRef do
                {if not rref == null then
                    {error
                        {hlmessage Only one RangeRef is allowed.}
                    }
                }
                set rref = r

             case cr:CellRef do
                {if cref == null then
                    set cref = cr
                 else
                    set oref = cr
                }

            }
        }
        {inc argn}
    }

    let ref:#SheetRef = null

    {if-non-null cref then
        {if oref != null or rref != null or rrr != null then
            {if not (cref.absolute? or absolute?) then
                {error
                    {hlmessage
                        The first CellRef must be absolute.
                    }
                }
            }
        }
        {if row? or col? then
            {if oref != null or rref != null then
                {self.invalid-get-ref}
            }
            set ref =
                {if absolute? then
                    {CellRef.absolute self, cref.row + row, cref.col + col}
                 else
                    {CellRef.relative-to cref, row, col}
                }
         elseif oref != null then
            {if rref != null then
                {self.invalid-get-ref}
            }
            set ref =
                {if absolute? then
                    {CellRef.absolute self, cref.row + oref.row, cref.col + oref.col}
                 else
                    {CellRef.relative-to cref, oref.row, oref.col}
                }
         elseif rrr != null then
            set ref = {RangeRef.from-relative-ref cref, {non-null rrr}}
         elseif rref != null then
            {if oref != null then
                {self.invalid-get-ref}
            }
            set ref =
                {if absolute? then
                    {RangeRef
                        self,
                        cref.row + rref.cell1.row, cref.col + rref.cell1.col,
                        cref.row + rref.cell2.row, cref.col + rref.cell2.col
                    }
                 else
                    ||FIXME: is this necessary?
                    {error {hlmessage Range must be absolute.}}
                }
         else
            set ref = 
                {if absolute? and not cref.absolute? then
                    {CellRef.absolute self, cref.row, cref.col}
                 else
                    cref
                }
        }
     else
         {if-non-null rref then
             {if row? or col? or oref != null then
                 {self.invalid-get-ref}
             }
             set ref = rref
          else
             set ref = {CellRef self, row, col, row-abs? = absolute?, col-abs? = absolute?}
         }
    }
    {assert ref != null}

    {type-switch ref
     case cr:CellRef do
        {if cr.row >= self.rows or cr.col >= self.cols then
            {error
                {hlformat
                    "Reference out of bounds: row=%1!s! col=%2!s!",
                    cr.row, cr.col
                }
            }
        }
        set ref = {self.intern-CellRef cr}

     case rr:RangeRef do
        set ref = {self.intern-RangeRef rr}
    }
    {return {non-null ref}}
  }

  {method private {intern-CellRef cr:CellRef}:CellRef
    {if cr.absolute? then
        def cr-set = {self.cellrefs.as-Set}
        def (ecr, exists?) = {cr-set.get-member-if-exists cr}
        {if exists? then
||--        {dump "interned earlier", ecr}
            {return ecr}
         else
            {self.cellrefs.insert cr}
            {return cr}
        }
     else
        {return cr}
    }
  }

  {method private {intern-RangeRef rr:RangeRef}:RangeRef
    {if rr.absolute? then
        def rr-set = {self.rangerefs.as-Set}
        def (oldrr, exists?) = {rr-set.get-member-if-exists rr}
        {if exists? then
            {return oldrr}
         else
            def newrr =
                {RangeRef.from-CellRefs
                    {self.intern-CellRef rr.cell1},
                    {self.intern-CellRef rr.cell2}
                }
            {self.rangerefs.insert newrr}
            {return newrr}
        }
     else
        {return rr}
    }
  }

  ||FIXME: Carefully maintain these and then refresh only withing these bounds
  || Call this if some attribute of a cell changes. If the cell value changes,
  || call self.refresh.
  field public changed-row-min:int
  field public changed-row-max:int
  field public changed-col-min:int
  field public changed-col-max:int


  {doc-next
    {purpose
        Take note of the fact that the call at ({param row}, {param col})
        was changed.
    }
  }
  {method public open {note-cell-changed row:int, col:int}:void
    {if row > self.changed-row-max then
        set self.changed-row-max = row
    }
    {if row < self.changed-row-min then
        set self.changed-row-min = row
    }
    {if col > self.changed-col-max then
        set self.changed-col-max = col
    }
    {if col < self.changed-col-min then
        set self.changed-col-min = col
    }
    ||FIXME: this happens too often, and can cause a stack overflow
||--    {self.note-operation WorksheetOpcode.recalc, row, col}
  }


  || ---------------------
  || Cell get/set methods
  || ---------------------

  {doc-next
    {purpose Get the cell at the specified {param row} and {param col}.}
  }
  {method public open {get-cell row:int, col:int}:CellValue
    {return self.vals[row, col]}
  }

  {doc-next
    {purpose Get the value of the cell at {param row} and {param col}.}
  }
  {method public open {get-value row:int, col:int}:any
    {return self.vals[row, col].value}
  }

  {doc-next
    {purpose Set the value of the cell at {param row} and {param col}.}
  }
  {method public open {set-value row:int, col:int, val:any}:void
    {if self.vals[row, col].value != val then
        set self.vals[row, col].value = val
        {inc self.change-count}
||--        {dump "wks.set-value", row, col, val}
        {self.update}
    }
  }


  {doc-next
    {purpose Create a formula with the target at {param row} and {param col}.
    }
    {parameter row, The row of the cell to contain the formula.}
    {parameter col, The column of the cell to contain the formula.}
    {parameter formula, A procedure for computing the formula result.}
    {parameter domain, The {docref Domain} of the formula result.}
    {parameter ..., References to the input values for the formula.}
  }
  {method public open {make-formula-at
                          row:int, col:int, 
                          formula:CalcProc,
                          domain:Domain,
                          ...:DataRef
                      }:void
    def target = {self.get-ref {CellRef.absolute self, row, col}}
    {self.make-formula target, domain, formula, ...}
  }

  || doc inherited
  {method public open {make-formula
                          target:DataRef,
                          domain:Domain,
                          formula:CalcProc,
                          ...:DataRef
                      }:Formula
    {type-switch target
     case cell-target:CellRef do
        ||FIXME: better error checking/message for target?
        {assert cell-target.absolute?}
        {self.cellrefs.insert cell-target, error-if-present? = false}
        def row = cell-target.row
        def col = cell-target.col
        def cv = self.vals[row, col]
        def f = {super.make-formula target, domain, formula, ...}
        set cv.formula = f
        {self.note-cell-changed row, col}
        {return f}
     case r:RangeRef do
        {error {hlmessage The target of a formula must be a CellRef.}}
     else
        ||FIXME: what about other cases? Is it an error?
        {error {hlmessage The target of a formula must be a CellRef.}}
||--        def f = {super.make-formula target, formula, ...}
||--        {return f}
    }
  }

  || Called because some other DataSource that we are observing changed
  {method protected open {handle-observer-message
                             sender:Observable,
                             message:any
                         }:void
||--    {dump sender, message, self, self._refresh-requested?}
    ||FIXME: This doesn't notify observers directly, but are they notified
    || in any case (because values are set)? Not sure we need both refresh
    || and recalc methods.
    {self.recalc} || no notification
||--    {self.refresh}
  }

  {doc-next
    {purpose
        Bring the model up to date by evaluating all formulas in
        order, then calling {docref Observable.notify-observers}.
    }
    {details
        This method is called when no event is being handled
        if an update was requested (see {docref RefreshMixin}).
    }
  }
  {method public open {refresh}:void
    {self.recalc}
    {self.notify-observers message = self.last-operation}
    {self.last-operation.reset}
||--    {dump {self.last-operation.to-String}} ||DEBUG
  }

  {doc-next
    {purpose
        Update a cell value. If the new value is different, update
        the change count and bounds of the updated cells.
    }
  }
  {method public open {update-cell-value r:int, c:int, v:any}:void
    def cv = self.vals[r, c]
    {if cv.value != v then
        set cv.value = v
        {self.note-cell-changed r, c}
    }
  }

  || Helper to mark cells covered by a cell that covers others
  {method private {update-covered-cells ri:int, ci:int}:void
    def cv = self.vals[ri, ci]
    {for r = 0 below cv.rowspan do
        {for c = 0 below cv.colspan do
            {if r > 0 or c > 0 then
                set self.vals[ri + r, ci + c].covered? = true
            }
        }
    }
  }

  {doc-next
    {purpose
        Scan the cell array and set the {docref CellValue.covered?} bit
        as appropriate.
    }
  }
  {method protected open {update-covered}:void
    def rows = self.rows
    def cols = self.cols
    {for ri = 0 below rows do
        {for ci = 0 below cols do
            set self.vals[ri, ci].covered? = false
        }
    }
    {for ri = 0 below rows do
        {for ci = 0 below cols do
            def cv = self.vals[ri, ci]
            {if cv.rowspan > 1 or cv.colspan > 1 then
                {self.update-covered-cells ri, ci}
            }
        }
    }
  }


  {doc-next
    {purpose Bring all values in the cell array up to date.}
    {details
        First go through the cell array in row-major order. If any
        cell is a data reference, update the cell value. Next, evaluate
        all formulas in order. Finally, update cell vaues that are
        data references once more.
    }
  }        
  {method public open {recalc}:void
    {for f in self.ordered-calcs do
        def target = f.target asa CellRef
        {assert target.absolute?}
        def cv = self.vals[target.row, target.col]
        def old-val = cv.value
        {self.eval f.formula, target, {splice f.args}}
        {if old-val != cv.value then
            {self.note-cell-changed target.row, target.col}
        }
    }
    {self.note-operation "recalc", 0, 0}
  }

  {doc-next
    {purpose
        If the is a group at the specified {param row} and {param col}, return
        the {docref GroupSpec}.
        }
    {parameter row, The cell row.}
    {parameter col, The cell column.}
    {parameter node?, If {param node?} is true, the result is non-null
        only if it is the location where the group was inserted.
    }
  }
  {method public open {get-group row:int, col:int, node?:bool = true}:#GroupSpec
    let gs:#GroupSpec = null
    let is-node?:bool = false
    {if-non-null rgs = {self.row-tree.get-group col, row, row} then
        set gs = rgs
        set is-node? = col == gs.level and gs.first == row
    }
    {if gs == null then
        {if-non-null cgs = {self.col-tree.get-group row, col, col} then
            set gs = cgs
            set is-node? = row == gs.level and gs.first == col
        }
    }
    {if node? and not is-node? then
        {return null}
    }
    {return gs}
  }


  {doc-next
    {purpose The version string to be saved with the data.}
  }
  {setter public open {data-version v:String}:void
    set self._data-version = v
  }
  {doc-next
    {purpose Return a version string to be saved with the data.}
  }
  {getter public open {data-version}:String
    {return self._data-version}
  }

  ||FIXME: Do we really need this? (if so, add to the spec)
  {doc-next
    {purpose A name that identifies the model.}
  }
  {getter public open {model-name}:String
    {return self._model-name}
  }
  {setter public open {model-name v:String}:void
    set self._model-name = v
  }

  {doc-next
    {purpose
        If necessary, upgrade data to the format required by the
        current version of the worksheet. If impossible, return null.
    }
    {details
        If {param data} has an entry "data-version" and it is the same
        as {ctext self.data-version}, or if there is no entry for
        "data-version", then simply return {param data}.  Otherwise
        return {ctext {migration data}}.

        In each new release of an application based on a
        {docref WorksheetModel}, you can maintain a migration proc
        to upgrade from older versions (or downgrade from newer
        versions).
    }
  }   
  {method public open {migrate
                          data:JsonObject,
                          migration:{proc-type {data:JsonObject}:#JsonObject}
                      }:#JsonObject
    {return {migration data}}
  }

  {doc-next
    {purpose Return a JSON representation of the data model.}
  }
  {method public open {get-data all?:bool = false}:JsonObject
    def data = {JsonObject
                   "data-version", self.data-version,
                   "model-name", self.model-name
               }
    def forms = {JsonArray}
    set data["forms"] = forms
    {for ri = 0 below self.rows do
        {if-non-null erf = {self.get-embedded-form ri, -1} then
            def ref = {format "$%c$%s", 'A' + erf.base-col, erf.base-row + 1}
            def rs = erf.data-source.record-set
            def jf = {RecordSet-to-Json rs}
            set jf["ref"] = ref
            {forms.append jf}
        }
        {for ci = 0 below self.cols do
            def ref = {format "$%c$%s", 'A' + ci, ri + 1}
            def cv = self.vals[ri, ci]
            {if-non-null erf = cv.embedded-form then
                || Already added the forms
             else
                {if cv.value != null and (all? or cv.editable?) then
                    set data[ref] = {cv.domain.format cv.value}
                }
            }
        }
    }
    {if-non-null hrs = self.h-ruler-spec then
        set data["h-ruler-spec"] = {hrs.get-json-data}
    }
    {if-non-null vrs = self.v-ruler-spec then
        set data["v-ruler-spec"] = {vrs.get-json-data}
    }
    {return data}
  }

  {doc-next
    {purpose Clear all data from the data model (usually so it can
        be reloaded from saved data).
    }
  }
  {method public open {clear-data}:void
    {for ri = 0 below self.rows do
        {for ci = 0 below self.cols do
            def cv = self.vals[ri, ci]
            {if-non-null erf = cv.embedded-form then
                def rs = erf.data-source.record-set
                {rs.delete-all}
                {rs.commit}
             else
                {if cv.editable? then
                    set cv.value = null
                }
            }
        }
    }
  }

  {doc-next
    {purpose Repopulate the data model from {param data}.}
    {details
        First call {ctext {self.migrate data}} in case
        the {docref-abbr WorksheetModel.data-version} of the data
        differs from the current version. Then call {docref-abbr
        WorksheetModel.clear-data} to clear out the model. Next,
        iterate recursively through {param data} and update the data
        model. Finally, notify observers that there has been an update.
    }
    {return-vals
        Returns true if the update is successful. A result of false
        means that the data could not be migrated to the current
        version.  An error may be thrown if there is an error of
        some kind detected when the model is being repopulated.
    }
  }
  {method public open {put-data data:JsonObject}:bool
    {if-non-null data = {self.migrate data, WorksheetModel.default-migration}
     then
        {self.clear-data}
        let forms:JsonArray = data["forms"] asa JsonArray
        let fi:int = 0
        {for erf in self.embedded-forms do
            {if-non-null erf then
                def rs = erf.data-source.record-set
                {assert rs.size == 0}
                def rda = {RecordData-from-Json rs, forms[fi] asa JsonObject}
                {for rd in rda do
                    {rs.append rd}
                }
                {inc fi}
            }
        }
        {for ri = 0 below self.rows do
            {for ci = 0 below self.cols do
                def cv = self.vals[ri, ci]
                def ref = {format "$%c$%s", 'A' + ci, ri + 1}
                let (v:any, exists?:bool) = {data.get-if-exists ref}
                {if exists? then
                    set cv.value = {cv.domain.parse v asa String}
                }
                {if v != null then
                    set cv.value = {cv.domain.parse v asa String}
                }
            }
        }

        ||FIXME: must adjust rulers after all forms are inserted/deleted
        let (vr:any, v-exists?:bool) = {data.get-if-exists "v-ruler-spec"}
        {if v-exists? then
            {if self.v-ruler-spec == null then
                set self.v-ruler-spec = {RulerSpec Orientation.vertical, 0}
            }
            {self.v-ruler-spec.put-json-data vr asa JsonObject}
        }

        let (hr:any, h-exists?:bool) = {data.get-if-exists "h-ruler-spec"}
        {if h-exists? then
            {if self.h-ruler-spec == null then
                set self.h-ruler-spec = {RulerSpec Orientation.horizontal, 0}
            }
            {self.h-ruler-spec.put-json-data hr asa JsonObject}
        }

        {self.update}
        {return true}
    }
    {return false}
  }

  {doc-next
    {purpose
        A migration procedure that simply returns the data that is passed to it.
    }
  }
  def public default-migration =
      {proc {data:JsonObject}:#JsonObject
        {return data}
      }
}

|| -------------------------------------------------------------------------

|| -------------
|| Worksheet UI
|| -------------

|#
  Important data structures to be maintained
  o WorksheetModel
    o GroupTrees
    o ValueCells
    o CellRefs and RangeRefs
  o Worksheet
    o h-ruler-spec, v-ruler-spec
    o WorksheetGrids
      - rows/cols/cells (handled by RowColGrid)
      o h-ruler, v-ruler (if adjustable in that dimension)
      o spacers (handled by the Rulers)
      o RulerResizers (currently Worksheet.refresh-x calls refresh-resizers)
      o resizer spacers (handled by the RulerResizer)

  Changes that have to be tracked
  o insert/delete row/column (command on a Worksheet)
    o Command calls Worksheet.insert-rows/cols
    o Worksheet modifies the model
    o Model notifies observers using a WorksheetOperation
    o Worksheet observes and notifies WorksheetGrids
    o each WorksheetGrid uses a WorksheetView and adjusts itself
      o insert/delete rows/cols
      o insert/delete in h-ruler or v-ruler
  o insert/delete rows due to embedded form
  o insert due to extra data in input

  o expand/contract row/column group
  o change cell value
  o change rowspan/colspan
  o change font size
  o change column width/row height

#|

|| Proc to handle certain events on any GridCell
{define-proc package {handle-grid-cell-event
                         gc:GridCell, e:GuiEvent, t:ActiveTraversor
                     }:void
    {type-switch e
||--     case foe:FocusOut do
||--        {dump foe, t, gc.row, gc.col, gc.refreshing?}
||--        {if not gc.refreshing? then
||--            {gc.activate-cell false}
||--        }
||--     case fie:FocusIn do
||--        {dump fie, g, gc.row, gc.col, gc.refreshing?}
||--        {if not gc.refreshing? then
||--            {gc.activate-cell true}
||--        }
     case vfe:ValueFinished do
||--        {dump "ValueFinished, commit", t, t.valid?}
        {if t.valid? then
            {gc.commit}
        }
    }
}



{doc-next
    {purpose The {docref Graphic} that displays one cell in a {docref
        Worksheet}.
    }
}
{define-class public open GridCell {inherits Frame}

  {getter public open {style-element}:String
    {if self._style-element == "" then
        {return "GridCell"} ||""
     else
        {return self._style-element}
    }
  }

  {getter package {event-hook}:EventHandler
    {return
||--        {on e:GuiEvent at t:ActiveTraversor do
        {on e:DialogEvent at t:ActiveTraversor do
            {handle-grid-cell-event self, e, t}
        }
    }
  }

  {nonlocal-option public alternate-row-background:Background
    {self.refresh-options}
  }


  {doc-next
    {purpose The graphical display and/or editor for this cell.}
  }
  field public-get private-set ui:#Visual || use insert-ui to set

  {doc-next
    {purpose The {docref Worksheet} that contains this cell.}
  }
  field public-get protected-set worksheet:Worksheet

  {doc-next
    {purpose The row in the model that contains this cell.}
  }
  field public-get protected-set row:int

  {doc-next
    {purpose The column in the model that contains this cell.}
  }
  field public-get protected-set col:int

  {doc-next
    {purpose If true the cell is in the {docref GridCell.refresh} method.}
  }
  field public-get protected-set refreshing?:bool = false

  {doc-next
    {purpose
        If true it means this cell has a discloser for a row or
        collum group.
    }
  }
  field public-get protected-set discloser?:bool = false

  {doc-next
    {purpose
        A {docref Frame} to hold the cell content if the cell
        needs to display a discloser.
    }
  }
  field protected discloser-frame:#Frame

  {doc-next
    {purpose If true it means that the cell should be refreshed.}
  }
  field public stale?:bool = false

  || Store last value displayed so that changes can be recognized

  {doc-next
    {purpose
        The value of the cell when this {docref GridCell} was last
        refreshed.
    }
  }
  field public-get protected-set value:any


  {doc-next
    {purpose Returns the value of this cell (from the data model).}
  }
  {getter public open {cell-value}:CellValue
    {return self.worksheet.model.vals[self.row, self.col]}
  }


  {doc-next
    {purpose
        The rowspan of the cell when this {docref GridCell} was last
        refreshed.
    }
  }
  || Store last row/colspan seen so self can notice changes and react
  field protected last-rowspan:int field protected last-colspan:int


  {doc-next
    {purpose
        The rowspan of this {ctext GridCell}, reduced to 1 if it is the
        home row of a collapsed group.
    }
  }
  {getter public open {rowspan}:int
    def cv = self.cell-value
    {if cv.rowspan > 1 then
        def r0 = {self.worksheet.model.row-tree.map-index-to-position self.row}
||--        defaultaa r1 = {self.worksheet.model.row-tree.map-index-to-position
||--                     self.row + cv.rowspan - 1
||--                 }
        def r1 = {self.worksheet.model.row-tree.visible-position
                     self.row + cv.rowspan - 1, below? = true
                 }
        {if r0 < 0 or r1 < 0 then
            {return 1}
        }
        {return r1 - r0 + 1}
     else
        {return cv.rowspan}
    }
  }


  {doc-next
    {purpose
        The colspan of this {ctext GridCell}, reduced to 1 if it is the
        home row of a collapsed group.
    }
  }
  {getter public open {colspan}:int
    def cv = self.cell-value
    {if cv.colspan > 1 then
        def c0 = {self.worksheet.model.col-tree.map-index-to-position self.col}
        def c1 = {self.worksheet.model.col-tree.visible-position
                     self.col + cv.colspan - 1, below? = true
                 }
        {if c0 < 0 or c1 < 0 then
            {return 1}
        }
        {return c1 - c0 + 1}
     else
        {return cv.colspan}
    }
  }


  {doc-next
    {purpose Indicates if the cell currently has focus for editing.}
  }
  {getter public open {active?}:bool
    {return
        self.worksheet.active-col == self.col and
        self.worksheet.active-row == self.row
    }
  }


  {doc-next
    {purpose Indicates if the cell can be edited.}
  }
  {getter public open {editable?}:bool
    {return self.worksheet.model.vals[self.row, self.col].editable?}
  }

  {doc-next
    {purpose If {ctext self.ui} is a {docref ValueControl} then return it.
        Otherwise, return null.
    }
  }
  {getter public open {editor}:#ValueControl
    {type-switch self.ui
     case ctl:ValueControl do
        {return ctl}
    }
    {return null}
  }

  {doc-next
    {purpose Initialize a {docref GridCell} for the value at {param row}
        and {param col} of {param worksheet}.
    }
    {parameter worksheet, The {docref Worksheet} that contains this cell.}
    {parameter row, The row that contains this cell.}
    {parameter col, The column that contains this cell.}
    {parameter ..., Option settings}
  }
  {constructor public {default
                          worksheet:Worksheet,
                          row:int,
                          col:int,
                          ...
                      }
    set self.worksheet = worksheet
    set self.row = row
    set self.col = col
    set self.last-rowspan = 1
    set self.last-colspan = 1
    set self.stale? = true
    {construct-super
        discrete-select-in-range? = true,
        {splice ...},
        opaque-to-events? = true,
        {on e:PointerPress at gc:GridCell do
||--            {dump e, e.consumed?}
            {self.activate-cell true}
            {e.consume}
        }
        ||FIXME: probably not needed now
||--        ,{click-recognizer consume? = false}
||--        ,
||--        {on e:Click at gc:GridCell do
||--            {dump e, e.consumed?}
||--            {self.activate-cell true}
||--        }
    }
  }

  {doc-next
    {purpose Add {param v} as the visible content of this cell.}
  }
  {method protected open {add-content v:any}:void
    {if self.discloser? then
        {if-non-null v then
            {self.discloser-frame.add replace? = true, v}
         else
            {self.discloser-frame.clear}
        }
     else
        {if-non-null v then
            {self.add replace? = true, v}
         else
            {super.clear}
        }
    }
  }

  {doc-next
    {purpose
        Return the object that is the visible content of this cell.
    }
  }
  {method public open {get-content}:#Visual
    def f = 
        {if self.discloser? then
            self.discloser-frame
         else
            self
        }
        
    {return
        {if-non-null child = f.child then
            child.graphic
         else
            null
        }
    }
  }

  {doc-next
    {purpose Remove the content from the cell.}
  }
  {method public open {clear}:void
    {unset self.data-binding-context}
    set self.ui = null
    set self.value = null
    {super.clear}
  }

  {doc-next
    {purpose
        If the current cell represents a field in an
        {docref EmbeddedRecordForm} then refresh the cell value from
        the data source.
    }
  }
  {method public open {refresh-value fs:FieldSpec}:void
    def cv = self.cell-value
    {if-non-null rf = self.data-binding-context asa #RecordForm
     then
        {if-non-null cr = rf.current-record then
            def nv = cr[fs.field-name]
            {if nv != cv.value then
                set cv.value = nv
                set self.value = null
            }
||--            {dump "update from rf", fs.field-name, cv.value}
        }
    }
  }

  {method private {init-erg erg:EmbeddedRecordGrid}:void
    set erg.worksheet = self.worksheet
    set erg.grid-line-color = self.grid-line-color
    set erg.grid-cell = self
    set self.stale? = true
  }

  {doc-next
    {purpose Remove the editor and replace it with the formatted value.}
  }
  {method protected open {show-cell-value commit?:bool = true}:void
    {if commit? then
||--        {dump "show-cell-value, commit"}
        {self.commit}
    }

    {if-non-null fs = self.cell-value.field-spec then
        {self.refresh-value fs}
    }
    def cv = self.cell-value
    let content:any = cv.value

    || If there is an editor, and it isn't locked, remove it.
    {if-non-null editor = self.editor then
        {if not cv.locked? then
            set self.value = null  || Force refresh from cell value
            {(editor asa Graphic).detach}
            set self.ui = null
        }
    }

    || Should not rebuild the self.ui if there is one already, but if
    || the ui-spec is a VisualProc, it might produce a new Visual if
    || the cell value changed.
    {if-non-null spec = cv.spec then
        {if self.ui == null or spec.ui-spec isa VisualProc then
            {type-switch spec.ui-spec
             case gcp:GridCellProc do
                set self.stale? = true
                set content = {gcp self}
                set self.ui = content

             case fp:FieldProc do
                def erf = {non-null cv.embedded-form}
                {if self.data-binding-context == null then
                    set self.data-binding-context =
                        {erf.get-RecordForm self.row, self.col}
                 else
                    {assert
                        {erf.get-RecordForm
                            self.row, self.col} == self.data-binding-context
                    }
                }
                {if-non-null context = self.data-binding-context then
                    set self.stale? = true
                    set content = {fp (context asa RecordForm).current-record, cv}
||--                {if content isa EmbeddedRecordGrid then
||--                    {dump self.rowspan, self.colspan}
||--                    {if self.rowspan == 1 then
||--                        {dump "???"}
||--                    }
||--                }
                    set self.ui = content
                }

             case vp:VisualProc do
                set self.stale? = true
                set content = {vp cv}
                set self.ui = content

             case n:Null do
                || Don't change content

             else
                || The cell value can be hidden by the ui-spec
                set content = spec.ui-spec
            }
        }

        {if cv.value != self.value or self.stale? then
            ||FIXME: reset the margin because sometimes cells don't display
            set self.margin = 0pt
            def margin =
                {if self.editor != null then
                    0m
                 elseif self.discloser? then
                    0m
                 elseif cv.ui-spec isa EmbeddedRecordGrid then
                    0m
                 elseif self.ui isa Graphic then
                    0m
                 elseif cv.ui-spec isa Graphic then
                    0m
                 elseif content isa Visual then
                    0m
                 else
                    self.cell-margin
                }
            set self.margin = margin
||--            {cv.apply-options self}
            {type-switch content
             case erg:EmbeddedRecordGrid do
                {self.init-erg erg}
                {self.add-content erg}
             case v:#Visual do
                {self.add-content content}
             else
                {self.add-content cv.formatted-value}
            }
            set self.value = cv.value
        }
    }
  }

  {doc-next
    {purpose
        Create the editor for a GridCell that is about to become
        active.
    }
  }
  || (called from gc.refresh when there is no editor but there should be)
  {method protected open {get-editor cv:CellValue}:#ValueControl
    {assert self.ui == null}  || should not be any Graphic in the cell yet
    {assert cv.editable?}     || Must be editable to ask for editor
    {assert not cv.covered?}  || Should not ask for editor if covered

    || If there is a suitable ui-spec, use it to create the editor
    let editor:#ValueControl =
        {type-switch cv.ui-spec
         case nt:Null do
            null

         case p:GridCellEditorProc do
            {p self}

         case p:FieldEditorProc do
            {if-non-null context = self.data-binding-context then
                {p (context asa RecordForm).current-record, cv}
             else
                null
            }

         case p:ValueControlProc do
            {p}

         case gcp:GridCellProc do
            {gcp self} asa ValueControl

         case fp:FieldProc do
            {if-non-null context = self.data-binding-context then
                {fp (context asa RecordForm).current-record, cv} asa ValueControl
             else
                null
            }

         case vp:VisualProc do
            {vp cv} asa ValueControl

         case t:ClassType do
            {if-non-null maker = {t.get-instance-maker "default"} then ||""
                {maker.new} asa ValueControl
             else
                {error {hlformat "No default constructor for %1!s!", t}}
            }

         case vc:ValueControl do
            vc

         case v:Visual do
            || Any other type of visual will get inserted as a ui
            {return null}

         else
            null
        }

    let vc:ValueControl =
        {if-non-null editor then
            editor
         else
            {switch cv.domain.type
             case #DateTime, DateTime do
                def df = {DateField}
                set df.value-as-any = cv.value
                df
             else
                {TextField
                    {validate-with {WorksheetDomainValidator cv.domain}}
                }
||--                {TextField value = {domain.format cv.value}}
            }
        }

||--    set vc.control-appearance-changeable? = true
    set vc.color = vc.look-and-feel.color
    def gctl = vc asa Graphic
    set gctl.width = {add-stretch}
    def ctl-height = {self.worksheet.model.v-ruler-spec.get-spec-size
                         self.row, self.worksheet.default-row-height
                     }
    set gctl.height = ctl-height
||--    {cv.apply-options vc}
    {return vc}
  }

  {doc-next
    {purpose
        Create an editor for a field, unless there is one already.
    }
  }
  {method public open {get-field-editor
                          cv:CellValue,
                          gc:GridCell
                      }:#ValueControl
    def spec = {non-null cv.field-spec}
    def field-name = spec.field-name
    {if-non-null form = gc.data-binding-context then
        {if spec.editable? then
            def vc = {non-null {gc.get-editor cv}}
||--        set vc.value-as-any = cv.value
||--        set cv.editing? = gc.active?
||--        set cv.locked? = false
            ||FIXME: should allow subclasses of String too?
            {if vc.value-type == String then
                {vc.add-data-binding
                    {bind value to field-name,
                        {format v:any as {cv.domain.format v}},
                        {parse v:String as
                            {try
                                {cv.domain.parse v}
                             catch e:Exception do
                                cv.value
                            }
                        }
                    }
                }
             else
                {vc.add-data-binding
                    {bind value to field-name}
                }
            }
            || Make sure the control matches the data it is bound to
            {form.refresh vc}
            {return vc}
         else
            {assert cv.editing? == false}
            {assert cv.locked? == true}
        }
     else
        {output "DEBUG"} ||FIXME: why does this happen?
    }
    {return null}
  }


  {doc-next
    {purpose Display an object that is not a control.}
  }
  {method public open {insert-ui ui:Visual}:void
    set self.margin = 0pt
    set self.ui = ui
    {self.add-content self.ui}
  }

  {doc-next
    {purpose Add the control {param ctl} to this cell as the editor.}
  }
  {method protected open {insert-editor ctl:ValueControl}:void
    def cv = self.cell-value
||--    {dump "insert-editor", ctl, ctl.value-as-any, cv.value}
    {self.insert-ui ctl}
    {self.refresh-editor}
    {ctl.add-event-handler self.event-hook}
  }

  {doc-next
    {purpose
        Make the state and presence of a group discloser on this cell match
        the state of the model.
    }
  }
  {method protected open {refresh-discloser}:void
    let gs:#GroupSpec = null
    let discloser?:bool = false
    {if-non-null
        rgs = {self.worksheet.model.row-tree.get-group
                  self.col, self.row, self.row
              }
     then
        set gs = rgs
        set discloser? = self.col == gs.level and gs.first == self.row
    }
    {if not discloser? then
        def group-tree = self.worksheet.model.col-tree
        {if-non-null cgs = {group-tree.get-group self.row, self.col, self.col}
         then
            set gs = cgs
            set discloser? = self.row == gs.level and gs.first == self.col
        }
    }

    || If a Discloser is needed in this cell, create it now
    {if discloser? then
        set self.margin = 0mm
    }
    {if discloser? and not self.discloser? then
        def dgs = {non-null gs}
        def discloser =
            {DefaultDiscloser
                margin = 2pt,
                animation-rate = 0Hz,
                orientation =
                    {if dgs.row? then "vertical" else "horizontal"},
                state = {if dgs.expanded? then
                            DisclosureState.expanded
                         else
                            DisclosureState.collapsed
                        },
                {on e:Adjustment at t:Discloser do
                    {if t.state != DisclosureState.changing then
                        {self.worksheet.set-group-expanded
                            self.row, self.col,
                            dgs, t.state == DisclosureState.expanded
                        }
                        {self.worksheet.update}
                    }
                }
            }
        ||FIXME: This won't work if discloser cell is editable
        set self.discloser? = true
        set self.discloser-frame = {Frame}
        {if-non-null child = self.child then
            {self.discloser-frame.add child.graphic}
        }
        {self.add replace? = true,
            {HBox 
                discloser,
                {Fill width = self.cell-margin}, self.discloser-frame
            }
        }
        set self.margin = 0pt
     elseif not discloser? and self.discloser? then
||--        {dump "?? Removed discloser from this cell:", self.row, self.col}
        {self.clear}
        set self.discloser-frame = null
        set self.value = null
        set self.discloser? = false
    }
  }

  {doc-next
    {purpose
        Update the editor content to reflect the current state of the model.
    }
  }
  {method public open {refresh-editor}:void
    {if-non-null editor = self.editor then
        def cv = self.cell-value
||--        {dump "refresh-editor", editor, self.row, self.col, cv.value}
        {if cv.field-spec != null then
            def form = {non-null self.data-binding-context} asa RecordForm
            {form.refresh editor}
         else
            || If a recalc changed the cell value, update the editor
            let ev:any = editor.value-as-any
            {if not ev isa editor.value-type then
                set ev = {cv.domain-value ev}
            }
||--            {dump ev, cv.value, editor.value-type}
            {if ev != cv.value then
                {if cv.value isa editor.value-type then
                    set editor.value-as-any = cv.value
                 elseif String == editor.value-type then
                    set self.editor.value-as-any = cv.formatted-value
                 else
                    set cv.error? = true
                }
            }
        }
        set self.value = cv.value
        {if self.active? then
            {type-switch self.ui
             case lb:ListBox do
                ||FIXME: ListBox throws ArrayBoundsException if called directly
                {after 0s do
                    || Delay until this event handled (problem with ListBox)
                    {lb.become-active-from-traversal}
                }
             case t:ActiveTraversor do
||--                {dump "become-active", t}
                {after 0s do
                    {t.become-active-from-traversal}
                }
            }
        }
    }
  }

  {doc-next
    {purpose
        Update the model with the current cell value, if it has been changed.
    }
  }
  {method public open {commit}:void
    def editable? = self.cell-value.editable?
    {if-non-null editor = self.editor then
||--        {dump "commit", self.row, self.col, editor.value-as-any}
        {self.worksheet.set-value self.row, self.col, editor.value-as-any}
    }
    {if-non-null spec = self.cell-value.field-spec then
        || Use the data binding to update the underlying record
        {if-non-null dbc = self.data-binding-context then
            def rf = dbc asa RecordForm
            {if rf.current-record != null then
                {rf.update}
||--             else
||--                {dump "DEBUG:", rf}
            }
        }
    }
  }

  {doc-next
    {purpose Set the cell background to show if the cell is editable or not, etc.}
  }
  {method protected open {refresh-options}:void
    def cv = self.cell-value
    {if (self.worksheet.selection-context-active? and
         {self.worksheet.selection.contains-cell? self.row, self.col}
        )
        and not (self.active? and self.cell-value.editable?)
     then
        {cv.apply-options self}
        set self.background = self.selected-background
        set self.color = self.selected-color
     else
        {unset self.color}
        {if self.cell-value.editable? then
            set self.background = Worksheet.editable-bg
         else
            {if self.row mod 2 == 1 then
                set self.background = self.alternate-row-background
             else
                {unset self.background}
            }
        }
        {cv.apply-options self}
    }
  }

  {doc-next
    {purpose
        Update the cell to reflect the current value and attributes.
    }
  }
  {method protected open {refresh}:void

    def cv = self.cell-value

    ||FIXME:: this lockout is probably not needed.
    {assert not self.refreshing?}
    set self.refreshing? = true
    def ar = self.worksheet.active-row
    def ac = self.worksheet.active-col
    def active? = self.row == ar and self.col == ac
||--    {if active? then
||--       {dump active?, self.row, self.col}
||--    }

    {self.refresh-discloser}
    {self.refresh-options}

    || Adjust to change in rowspan or colspan
    {if self.rowspan != self.last-rowspan or self.colspan != self.last-colspan
        or self.stale?
||--        or cv.rowspan > 1 or cv.colspan > 1
||--        or self.visual-parent == null
     then
        {self.worksheet.attach-cell self}
        set self.last-rowspan = self.rowspan
        set self.last-colspan = self.colspan
    }

    {if cv.editable? and (active? or cv.editing? or cv.locked?) then
        || Model says this cell should be editing, so create a control, etc.
||--        {dump "refresh, editing?=true", self.row, self.col, self.editor}
        {if self.editor != null then
            || There is an editor already, just refresh it
            {self.refresh-editor}
         elseif self.ui != null then
            || This is a Visual or Graphic that isn't a ValueControl
            || nothing to do - self.ui was inserted when first seen
            {assert cv.locked?}
         elseif cv.field-spec != null then
            {if-non-null vc = {self.get-field-editor cv, self} then
                {self.insert-ui vc}
                {self.refresh-editor}
||--                        {self.insert-editor vc}
            }
         else
            || not editing yet... Create and add the editor
            {self.worksheet.select-nothing}
            {if-non-null editor = {self.get-editor cv} then
                {self.insert-editor editor}
             else
                {self.insert-ui cv.ui-spec}
            }
        }
     else
        || According to the model, this cell should not be editing
        {self.show-cell-value}
    }
    {if cv.covered? then
        {self.detach}
    }
    set self.visible? = not cv.covered?
    set self.refreshing? = false
    set self.stale? = false
  }

  {doc-next
    {purpose
        If {param active?} is true, open an editor for this cell. Otherwise,
        commit any pending changes and display the current value.
    }
  }
  {method public open {activate-cell
                          active?:bool
                      }:void
    def ar = self.worksheet.active-row
    def ac = self.worksheet.active-col
    def cv = self.cell-value
||--    {dump "activate-cell", self.row, self.col, ar, ac, cv.editing?, active?}

    {if active? then
        {if self.row != ar or self.col != ac then
            || De-activate prior cell
            {if-non-null gc = {self.worksheet.get-grid-cell ar, ac} then
                {gc.activate-cell false}
            }
         else
            ||FIXME: make this an error or assert
            || This can happen with the window regains focus after losing it
||--            {dump "?? activate-cell called to activate current cell!"}
        }
    }

    {if not active? then
        {if not (self.row == ar and self.col == ac) then
            {return}
        }
        {if cv.editing? then
            {self.commit}
            {if not cv.locked? then
                set cv.editing? = false
            }
        }
        {self.worksheet.update}
        {return}
    }

    || Now activate self
    {self.worksheet.set-active self.row, self.col}
    {if cv.editable? then
        set cv.editing? = true
    }
    {self.worksheet.update}
  }

  {method public open {get-range-as-selected-text
                          into:StringBuf,
                          start-bound:#GuiMark=null,
                          end-bound:#GuiMark=null
                      }:void
    {type-switch self.ui
     case vc:ValueControl do
        {type-switch  vc.form-value
         case str:String do
            {into.concat str}
         case a:StringArray do
            {for s key si in a do
                {if si > 0 then
                    {into.append ' '}
                }
                {into.concat s}
            }
         else
            || null means nothing. But some controls seem to be
            || buggy. For example DateField doesn't return any text.
            || Use the formatted value.
            def cv = self.cell-value
            {if-non-null cv.value then
                {into.concat cv.formatted-value}
            }
        }
     else
        {super.get-range-as-selected-text into, start-bound = start-bound,
            end-bound = end-bound
        }
    }
  }

} ||GridCell

|# 
  How resizing works
  - There is a RulerResizer for every Grid that tracks a given ruler
    - The resizer points to the ruler and a grid that is tracking that ruler
    - The RulerResizer adds a Fill at the right (or bottom) edge of every
      column (or row) in the Grid that it knows about.
    - Each fill has a cursor that shows you can drag to resize
    - Each fill has event handlers to track a press/move/release sequence
    - Mouse handler calls {self.ruler.note-resize self} after setting a
      state field to indicate what the mouse event was
    - ruler.note-resize notifies observers, the WorksheetGrids
    - The PointerRelease handler also updates the ruler size (doing this
      in the Grid that is observing caused problems because there are
      multiple grids observing and sometimes the resize would be done more
      than once)
  - WorksheetGrid does the following
    - Mouse press: show a line that will track the mouse
    - Mouse move: move the line to follow the mouse pointer
    - Mouse release: remove the tracking line, set column width
  - WorksheetRuler.set-column width
    - Update the width spec for the column that was resized
    - Call ruler.refresh
      - Make sure the correct number of spacers are in place
      - Adjust the size of the spacers to match the specified size
    - When ruler.set-size is called, it means the layout is done, so it
      calls ruler.note-resize with null resizer, which notifies observers
    - When WorksheetGrid handles the message, it sets each h-spacer
      width to match the width of the corresponding segment of the ruler

#|

{doc-next
    {purpose
        A {docref Fill} with a style-element of "Spacer" used for
        constraining row widths and column heights.
    }
}
{define-class public open Spacer {inherits Fill}
  {getter public open {style-element}:String
    {if self._style-element == "" then
        {return "Spacer"} ||""
     else
        {return self._style-element}
    }
  }

  {doc-next
    {purpose Initialize this object.}
  }
  {constructor public {default ...}
||--    {construct-super opaque-to-events? = true, {splice ...}}
    {construct-super ...}
  }
}

{doc-next
    {purpose
        A {docref Fill} with a style-element of "Resizer" used for
        the resizing affordance at the top of a rolumn or at the left
        of a row.
    }
}
{define-class public open Resizer {inherits Fill}

  {getter public open {style-element}:String
    {if self._style-element == "" then
        {return "Resizer"} ||""
     else
        {return self._style-element}
    }
  }

  {doc-next
    {purpose Initialize this object.}
  }
  {constructor public {default ...}
    {construct-super ...}
  }
}

{doc-next
    {purpose
        Add a UI to a {docref WorksheetGrid} for resizing rows or
        columns.
    }
    {details
        This object maintains a collection of "resizers". These are
        simply {docref Fill}s attached to the tops of the columns or
        the left of the rows in the {docref WorksheetGrid}. The
        resizers will track mouse events and update the ruler if the
        user changes the size of a row or column. The grid must call
        {docref RulerResizer.refresh} if rows or columns are added
        or removed.
    }
}
{define-class public open RulerResizer

  {doc-next
    {purpose The {docref BaseRuler} to be tracked and adjusted.}
  }
  field public-get protected-set ruler:BaseRuler

  {doc-next
    {purpose the {docref WorksheetGrid} that is to track the ruler.}
  }
  field public-get protected-set grid:WorksheetGrid

  {doc-next
    {purpose
        These are the {docref Resizer}s associated with {docref-abbr
        RulerResizer.grid}.
    }
  }
  field public-get protected-set resizers:{Array-of Fill}

  {doc-next
    {purpose
        The orientation of the ruler. If horizontal, it controls the
        column widhts. If vertical, the row heights.
    }
  }
  {getter public open {horizontal?}:bool
    {return self.ruler.orientation == Orientation.horizontal}
  }

  {doc-next
    {purpose
        If true it means that the user is resizing a row or column by
        dragging the mouse pointer.
    }
  }
  field protected dragging?:bool = false

  {doc-next
    {purpose Single event handler shared by all resizers.}
  }
  field protected _handler:EventHandler

  ||FIXME: missing doc
  field public-get protected-set ruler-x:Distance
  field public-get protected-set ruler-y:Distance
  field public-get protected-set x0:Distance
  field public-get protected-set y0:Distance
  field public-get protected-set new-x:Distance
  field public-get protected-set new-y:Distance

  || This is a column number in the ruler. When other grids are notified,
  || they can translate to their own column numbers.
  field public-get protected-set resizer-pos:int
  field public-get protected-set state:String

  field protected last-count:int = -1

  {doc-next
    {purpose Initialize this object.}
    {parameter ruler, The {docref BaseRuler} for one axis of a
        {docref WorksheetGrid}
    }
    {parameter grid, The {docref WorksheetGrid} that this objected is
        associated with.
    }
  }
  {constructor public {default
                          ruler:BaseRuler,
                          grid:WorksheetGrid
                      }
    set self.state = ""
    set self.ruler = ruler
    set self.grid = grid
    set self.resizers = {new {Array-of Fill}}
    set self._handler =
        {on ge:GuiEvent at g:Graphic do
            {type-switch ge
             case e:PointerPress do
                {for s key si in self.resizers do
                    {if s == g then
                        set self.state = "press" ||""
                        set self.dragging? = true
                        set self.resizer-pos = si
                        {e.continue-implicit-pointer-grab g}
                        set (self.x0, self.y0) =
                            {transform-coordinates e.x, e.y, g, self.ruler}
                        set self.new-x = 0m
                        set self.new-y = 0m
||--                        {dump "press", si, self.x0, self.y0, self.grid.name}
                        {self.ruler.note-resize self}
                        {e.consume}
                        {break}
                    }
                }
             case e:PointerMotion do
                {if self.dragging? then
                    set self.state = "move" ||""
                    def (x, y) =
                        {transform-coordinates e.x, e.y, g, self.ruler}
                    set self.new-x = x - self.x0
                    set self.new-y = y - self.y0
                    {self.ruler.note-resize self}
                    {e.consume}
||--                    {dump "motion", self.new-x/1pt, self.new-y/1pt}
                }
             case e:PointerRelease do
                {if self.dragging? then
                    set self.state = "release" ||""
||--                    {dump "release", self.new-x/1pt, self.new-y/1pt}
                    let selection:#WorksheetSelection =
                        self.ruler.worksheet.selection
                    def ruler-index = {self.ruler.get-index self.resizer-pos}
                    {if self.horizontal? then
                        def old-width =
                            {self.ruler.get-spacer-size self.resizer-pos}
                        def new-width =
                            {max
                                1mm,
                                self.new-x + old-width - self.ruler.line-width
                            }
                        {if-non-null s = selection then
                            {if selection.all-rows?
                                and ruler-index >= s.begin-column
                                and ruler-index <= s.end-column
                             then
                                {for ci = s.begin-column to s.end-column do
                                    {if {self.ruler.includes? ci} then
                                        {self.ruler.spec.set-spec-size ci, new-width}
                                    }
                                }
                             else
                                set selection = null
                            }
                        }
                        {if selection == null then
                            {self.ruler.spec.set-spec-size ruler-index, new-width}
                        }
                        {self.ruler.note-resize self}
                     else
                        def old-height =
                            {self.ruler.get-spacer-size self.resizer-pos}
                        def new-height =
                            {max
                                1mm,
                                self.new-y + old-height - self.ruler.line-width
                            }
                        {if-non-null s = selection then
                            {if selection.all-cols?
                                and ruler-index >= s.begin-row
                                and ruler-index <= s.end-row
                             then
                                {for ri = s.begin-row to s.end-row do
                                    {if {self.ruler.includes? ri} then
                                        {self.ruler.spec.set-spec-size ri, new-height}
                                    }
                                }
                             else
                                set selection = null
                            }
                        }
                        {if selection == null then
                            {self.ruler.spec.set-spec-size ruler-index, new-height}
                        }
                        {self.ruler.note-resize self}
                    }
                    set self.dragging? = false
                    {e.consume}
                }
            }
        }
  }

  || Override
  {method public open {clear}:void
    {for f in self.resizers do
        {f.remove-event-handler self.handler}
        {f.detach}
    }
    {self.resizers.clear}
  }

  {doc-next
    {purpose
        Adjust the number and size of the resizers to match the current
        state of the model.
    }
  }
  {method public open {refresh}:void
    def count =
        {if self.horizontal? then self.grid.cols else self.grid.rows}
    {if count != self.last-count then
||--        {dump "RulerResizer.refresh", self.grid.name, self.last-count, count}
        || Rebuild all of the resizers
        {self.clear}
        set self.last-count = count
        {for i = 0 below count do
            def resizer = {self.make-resizer}
            {self.resizers.append resizer}
            {self.grid.add-resizer self.horizontal?, i, resizer}
        }
    }
  }

  {doc-next
    {purpose
        Create one {docref Resizer} and set the style-class to "horizontal"
        or "vertical" as appropriate.
    }
  }
  {method public open {make-resizer}:Resizer
    def r =
        {Resizer
            opaque-to-events? = true,
            self.handler
        }
    {if self.horizontal? then
||--        set r.height = self.ruler.worksheet.column-selector-height
        set r.style-class = "horizontal" ||""
     else
||--        set r.width = self.ruler.worksheet.row-selector-width
        set r.style-class = "vertical" ||""
    }
    {return r}
  }

  {getter {handler}:EventHandler
    {return self._handler}
  }

} ||RulerResizer



{doc-next
    {purpose
        When set-size is called, notify observers of the new bounds.
    }
}
{define-class public open SizeNotifier {inherits Observable, Frame}

  {doc-next
    {purpose Indicates if the {docref SizeNotifier} is for a row.}
  }
  field public-get protected-set row?:bool

  {doc-next
    {purpose The previous width of this notifier. If the current width is
        different, the observers are notified.
    }
  }
  field public-get protected-set prev-width:Distance = 0m

  {getter public open {style-element}:String
    {if self._style-element == "" then
        {return "SizeNotifier"} ||""
     else
        {return self._style-element}
    }
  }

  {doc-next
    {purpose
        The width of this notifier, including the border and margin
        (corresponds to {docref BasicLayout.cell-bounds}).
    }
  }
  {getter public open {cell-width}:Distance
    {return (self.layout asa BasicLayout).cell-bounds.width}
  }

  {doc-next
    {purpose
        The height of this notifier, including the border and margin
        (corresponds to {docref BasicLayout.cell-bounds}).
    }
  }
  {getter public open {cell-height}:Distance
    {return (self.layout asa BasicLayout).cell-bounds.height}
  }

  {doc-next
    {purpose Initialize this object.}
    {parameter row?, If true it means this notifier belongs to a row.
        Otherwise it belongs to a column.
    }
    {parameter ..., Graphic options.}
  }
  {constructor public {default
                          row?:bool,
                          ...
                      }
    {construct-super.Observable}
    {construct-super.Frame
        opaque-to-events? = true,
        {splice ...}
    }
    set self.row? = row?
    set self.style-class =
        {if row? then "vertical" else "horizontal"} ||""
  }

  {method public open {set-size lc:LayoutContext, bounds:GRect}:void
    {super.set-size lc, bounds}
    def w = bounds.width
    {self.notify-observers}
    {if w != self.prev-width then
        {self.notify-observers}
        set self.prev-width = w
    }
  }

}



|| FIXME: probably shouldn't change attributes here... this should
|| simply notice changes and broadcast them to the UI
{doc-next
    {purpose
        An object that maintains row heights or column widths in a
        {docref WorksheetGrid}.
    }
    {details
        This object mediates between the model and the UI. If you
        change an attribute of the ruler, it notifies observers (which
        are UI objects) so that they will update themselves to match
        the new state.

        A given {docref WorksheetGrid} may cover only some of the
        cells in the model. For example, it may be displaying only the
        frozen rows, and some of the columns may be invisible because
        they contain groups that eare collapsed. The ruler
        (represented by this object) can map in index in the model to
        a visible row or column position in a {ctext WorksheetGrid}
        or vice versa.
    }
}
{define-class abstract public open BaseRuler {inherits Visual, Observable}

  {doc-next
    {purpose The {docref Worksheet} that this ruler belongs to.}
  }
  field public-get protected-set worksheet:Worksheet

  {doc-next
    {purpose
        The default size for a segment in this ruler.
    }
  }
  {getter abstract public open {default-size}:Distance
  }

  ||FIXME: define an enum for this, or use a bool
  {doc-next
    {purpose
        0 means the ruler is in the frozen area, 1 is in the scrolling area.
    }
  }
  field public-get protected-set region:int

  {doc-next
    {purpose Return the {docref GroupTree} associated with this ruler.}
  }
  {getter public open {group-tree}:GroupTree
    {return
        {if self.orientation == Orientation.vertical then
            self.worksheet.model.row-tree
         else
            self.worksheet.model.col-tree
        }
    }
  }

  field protected _offset:int
  field protected _prev-offset:int = 0

  {doc-next
    {purpose
        The number of segments at the bottom of the {docref BaseRuler.spec}
        that are not included within this ruler.
    }
    {details
        The {docref RulerSpec} covers all rows or columns in a worksheet,
        but if there are frozen rows or columns, they will be displayed
        separately.
    }
  }
  {getter public open {offset}:int
    def offset = {if self.region == 0 then
                     0
                  else
                     self.spec.split-count
                 }
    {if offset != self._offset then
        set self._prev-offset = self._offset
    }
    set self._offset = offset
    {return self._offset}
  }

  field protected _prev-count:int = 0

  {doc-next
    {purpose
        The highest row or column covered by this ruler.
    }
  }
  {getter public open {last-index}:int
    {return
        {if self.region == 0 then
            self.spec.split-count - 1
         else
            {if self.orientation == Orientation.vertical then
                self.worksheet.model.rows - 1
             else
                self.worksheet.model.cols - 1
            }
        }
    }
  }

  {doc-next
    {purpose Return the number of visible segments in the ruler.}
  }
  {getter public open {visible-count}:int
    def index = self.last-index
    {return
        {if index >= 0 then
            {self.get-position index} + 1
         else
            0
        }
    }
  }

  {doc-next
    {purpose
        The widht of the lines between ruler segments.
    }
  }
  {getter public open {line-width}:Distance
    {return
        {if self.orientation == Orientation.horizontal then
            {self.any-to-Distance self.vertical-grid-line-width}
         else
            {self.any-to-Distance self.horizontal-grid-line-width}
        }
    }
  }

  {doc-next
    {purpose The specification of the sizes of the segments in the ruler.}
  }
  field protected spec:RulerSpec

  ||FIXME: remove this?
  field protected message:any || Message for notify-observers call

  || Objects to fill up the ruler
  field protected segments:{Array-of SizeNotifier}

  {doc-next
    {purpose The orientation of this ruler (horizontal or vertical).}
  }
  {getter public open {orientation}:Orientation
    {return self.spec.orientation}
  }

  {doc-next
    {purpose Initialize a ruler object.}
    {parameter worksheet, The {docref Worksheet} associated with this ruler.}
    {parameter spec, The specification for the sizes of ruler segments.}
    {parameter region, Indicates if the ruler covers a frozen or scrolling
        part of the worksheet.
    }
  }
  {constructor public {default
                          worksheet:Worksheet,
                          spec:RulerSpec,
                          region:int,
                          ...
                      }
    set self.worksheet = worksheet
    set self.region = region
    {construct-super.Observable}
    {construct-super.Visual ...}
    set self.segments = {new {Array-of SizeNotifier}}
    set self.spec = spec
    {self.refresh}
  }

  {doc-next
    {purpose
        Return true if the ruler covers the specified row or column
        in the model.
    }
  }
  {method public open {includes? i:int}:bool
    {return i >= self.offset and i <= self.last-index}
  }

  || Return the first and last position for first and count in the model
  {doc-next
    {purpose
        Provide the bounds for segments within this ruler.
    }
    {parameter first, The lowest index in the model of interest.}
    {parameter count, The number of rows or columns (starting at {param first})
        of interest.
    }
    {return-vals
        The first and last position covered by this ruler. These are
        in grid coordinates (which can be smaller than model coordinates
        when there are collapsed groups).
    }
  }
  {method public open {clip first:int, count:int}:(first:int, last:int)
    def delete? = count < 0
    def n = {if delete? then -count else count}
    let last:int = first + n - 1
    def last-visible = self.offset + self.visible-count - 1
    {if first > self.last-index or last < self.offset then
        {return (-1, -1)}
    }
    {if not {self.includes? first} then
        set first = self.offset
    }
    {if not {self.includes? last} then
        set last = last-visible
    }
    def p0 = {self.get-position first}
    def p1 = {self.get-position last}
||--    {dump "clip", first, last, self.offset, p0, p1} ||DEBUG
    {return (p0, p1)}
  }

  {doc-next
    {purpose
        Return the model index associated with position {param pos}
        in this ruler.
    }
  }
  {method public open {get-index pos:int}:int
    {return {self.group-tree.map-position-to-index pos} + self.offset}
  }

  {doc-next
    {purpose
        Return the grid position for the model index {param i}.
    }
  }
  {method public open {get-position i:int}:int
    def pos = {self.group-tree.map-index-to-position i}
    {return
        {if pos >= 0 then
            {self.group-tree.map-index-to-position i} - self.offset
         else
            -1
        }
    }
  }

  {doc-next
    {purpose
        Return the size of a segment, including any applicable
        separator line, for the given position {param pos}.
    }
  }
  {method public open {get-total-size pos:int}:Distance
    def i = {self.get-index pos}
||--    {assert {self.includes? i}}
    def size = {self.spec.get-spec-size i, self.default-size}
    {return {self.any-to-Distance size} + self.line-width}
  }

||FIXME: maybe this one should update the model and notify observers, and
||       code should always use this one
||--  {method public open {set-spec-size pos:int, size:any}:void
||--    def i = {self.get-index pos}
||--    {assert {self.includes? i}}
||--    {self.spec.set-spec-size i, size}
||--    {self.refresh}
||--  }

  {doc-next
    {purpose
        Create a {docref SizeNotifier} to represent the segment of the
        ruler at the position given by {param pos}.
    }
  }
  {method protected open {init-segment pos:int}:void
    let sn:SizeNotifier = self.segments[pos]
    let size:Distance = {self.get-total-size pos}
||--    set sn.background = "yellow" ||DEBUG
    {if self.orientation == Orientation.vertical then
        set sn.width = self.worksheet.row-selector-width
        set sn.height = size
     else
        set sn.width = size
        set sn.height = self.worksheet.column-selector-height
    }
  }

  {doc-next
    {purpose
        Insert the graphic that represents segment {param i} of the ruler.
    }
  }
  {method abstract protected open {insert-segment i:int}:void
  }

  || Called by refresh to add/remove segments - adjust width/height later
  {method protected open {insert-segments first:int, count:int, size:any}:void
    {if count < 0 then
        {for i = 0 below -count do
            def ri = first + i
            {self.segments[ri].detach}
        }
        {self.segments.remove first, length = -count}
     elseif count > 0 then
        {for i = 0 below count do
            def ri = first + i
            def spacer = {SizeNotifier self.orientation == Orientation.vertical}
            {self.segments.insert spacer, ri}
            {self.insert-segment ri}
        }
    }
  }

  || Called when user adjusts size
  {doc-next
    {purpose
        A method to be called when the user resizes a segment.
    }
  }
  {method public open {note-resize resizer:#RulerResizer}:void
    {self.refresh}
    {self.notify-observers message = resizer}
    ||FIXME: probably don't need self.message field any more
||--    set self.message = resizer
||--    def m = self.message
||--    {after 0s do
||--        {self.notify-observers message = m}
||--    }
    set self.message = null
  }

  || Make sure there are the correct number of segments and that the
  || sizes are correct.
  {doc-next
    {purpose Make the rulser consistent with the current state of the model.}
  }
  {method public open {refresh}:void
    {assert self._prev-count == self.segments.size}
    def old-count = self.segments.size
    def count = self.visible-count
    {self.insert-segments
        {min self.visible-count, old-count}, count - old-count, self.default-size
    }
    {for s key si in self.segments do
        {self.init-segment si}
    }
    {assert self.segments.size == count}
    set self._prev-count = self.visible-count
    set self._prev-offset = self.offset
  }

||FIXME: not used
||--  {method public open {get-notifier pos:int}:SizeNotifier
||--    {return self.segments[pos]}
||--  }

  {doc-next
    {purpose
        Return the size of the Graphic that represents the segment
        of the ruler at position {param pos}.
    }
  }
  {method public open {get-spacer-size pos:int}:Distance
    {if pos < self.segments.size then
        {if-non-null layout = self.segments[pos].layout then
            def sw =
                {if self.orientation == Orientation.vertical then
                    (layout asa BasicLayout).cell-bounds.height
                 else
                    (layout asa BasicLayout).cell-bounds.width
                }
            {if sw != 0m then
||--                {dump "get-spacer-size", self.orientation, sw/1pt}
                {return sw}
            }
        }
    }
    {return {self.any-to-Distance {self.get-total-size pos}}}
  }

  {doc-next
    {purpose
        Return the {docref SizeNotifier} for coordinate {param i} in the model.
    }
  }
  {method public open {get-notifier i:int}:#SizeNotifier
    {if {self.includes? i} then
        def pos = {self.group-tree.map-index-to-position i} - self.offset
        {if pos >= 0 and pos < self.segments.size then
            {return self.segments[pos]}
        }
    }
    {return null}
  }

  {doc-next
    {purpose
        Given (x,y) coordinates relative to the ruler, return the
        corresponding index (a row or column in the model).
    }
    {details
        A return value of -1 means the point was in a row or column
        header (for a {docref VerticalRuler} or {docref HorizontalRuler}
        respectively).
    }
  }
  {method public open {index-for-point x:Distance, y:Distance}:int
    def sn =
        {(self asa Graphic).find-graphic-at x, y,
            {proc {g:Graphic}:bool
||--                {dump self, g, g.style-class}
                {return g isa SizeNotifier}
            }
        }
    {if-non-null sn then
        {for segment key si in self.segments do
            {if segment == sn then
                {return {self.get-index si}}
            }
        }
    }
    {return -1}
  }


}

{doc-next
    {purpose
        An object used in a {docref Worksheet} to determine the widths
        of the columns.
    }
    {details
        This type of object is used by a {docref Worksheet} to
        maintain column widths or row heights. The ruler is a graphic
        that is stretched all the way across the worksheet (vertically
        or horizontally). When a layout cycle has been completed, it
        notifies the {ctext Worksheet}, which is an {docref
        Observer}. The {ctext Worksheet} will then query the ruler for
        the size of each row or column. In addition, the Worksheet
        will notify the ruler when rows or columns are inserted or
        deleted.
    }
}
{define-class public open HorizontalRuler {inherits HBox, BaseRuler}

  || doc inherited
  {getter public open {default-size}:Distance
    {return
        {self.any-to-Distance self.worksheet.default-column-width}
    }
  }

  {doc-next
    {purpose Initializde this ruler.}
    {parameter worksheet, The {docref Worksheet} that this ruler belongs to.
    }
    {parameter region, provides the initial value for {docref BaseRuler.region}}
    {parameter ..., Graphic options for this object.}
  }
  {constructor public {default
                          worksheet:Worksheet,
                          region:int,
                          ...
                      }
    def spec = {non-null worksheet.model.h-ruler-spec}
    {construct-super.HBox _style-element = "HorizontalRuler", {splice ...}}
||--    set self.background = "yellow" ||DEBUG
    {construct-super.BaseRuler worksheet, spec, region}
  }

  {method protected open {insert-segment i:int}:void
||--    {self.add-at-index self.segments[i], i}
    {self.add self.segments[i]}
  }

  || Override
  {method public open {clear}:void
    {self.segments.clear}
    {self.spec.specs.clear}
    {super.clear}
  }


  || Override
  {method public open {set-size lc:LayoutContext, bounds:GRect}:void
    {super.set-size lc, bounds}
    {self.note-resize null}
  }

}

{doc-next
    {purpose
        An object used in a {docref Worksheet} to determine the heights
        of the rows.
    }
    {details
        This type of object is used by a {docref Worksheet} to
        maintain row heights.

        The ruler is attached from the top to the bottom of
        the {docref Worksheet}.  When a layout cycle has been
        completed, the ruler notifies the {docref RulerResizer}s that
        are observing it.  (There is one for each {docref
        WorksheetGrid} that is used internally to implement the
        worksheet display.)

        In addition, the Worksheet will notify the ruler when rows or
        columns are inserted or deleted.
    }
}
{define-class public open VerticalRuler {inherits VBox, BaseRuler}

  || doc inherited
  {getter public open {default-size}:Distance
    {return
        {self.any-to-Distance self.worksheet.default-row-height}
    }
  }

  {doc-next
    {purpose Initialize this ruler.}
    {parameter worksheet, The {docref Worksheet} that this ruler belongs to.
    }
    {parameter region, Indicates what part of the grid this ruler controls. 0 means
        the frozen part, 1 is the scrolling part.
    }
    {parameter ..., Graphic options for this object.}
  }
  {constructor public {default
                          worksheet:Worksheet,
                          region:int,
                          ...
                      }
    def spec = {non-null worksheet.model.v-ruler-spec}
    {construct-super.VBox _style-element = "VerticalRuler", {splice ...}}
||--    set self.background = "orange" ||DEBUG
    {construct-super.BaseRuler worksheet, spec, region}
  }

  {method protected open {insert-segment i:int}:void
||--    {self.add-at-index self.segments[i], i}
    {self.add self.segments[i]}
  }

  || Override
  {method public open {clear}:void
    {self.segments.clear}
    {self.spec.specs.clear}
    {super.VBox.clear}
  }


  || Override
  {method public open {set-size lc:LayoutContext, bounds:GRect}:void
    {super.set-size lc, bounds}
    {self.note-resize null}
  }
}

|| -------------------------------------------------------------------------

{doc-next
    {purpose
        A subclass of {docref RowColGrid} that allows row heights 
        and column widths to be adjusted with the mouse.
    }
}
{define-class public open WorksheetGrid {inherits RowColGrid, Observer}

  {doc-next
    {purpose The {docref Worksheet} that this {ctext WorksheetGrid} belongs to.}
  }
  field public-get protected-set worksheet:Worksheet

||FIXME: optional-resizers (autosize difficult with 4 grids)
||--  {local-option public resizable-rows?:bool = false
||--    {self.refresh-resizers}
||--  }
||--
||--  {local-option public resizable-cols?:bool = false
||--    {self.refresh-resizers}
||--  }

  {doc-next
    {purpose
        Fill the space at the top left of the grid to maintain space
        for the resizers.
    }
  }
  field protected top-left:Fill

  {doc-next
    {purpose
        The ruler that controls column widths. Two or more grids can share
        the same ruler.
    }
  }
  field protected _h-ruler:#HorizontalRuler

  {doc-next
    {purpose
        A {docref Fill} used to anchor the top-edge fiducial to the
        top edge of the grid when there are no horizontal resizers.
    }
  }
  field protected h-ruler-shim:Fill

  {doc-next
    {purpose The ruler that controls column widths.}
  }
  {getter public open {h-ruler}:#HorizontalRuler
    {return self._h-ruler}
  }

  {setter {h-ruler ruler:#HorizontalRuler}:void
    {if-non-null old-ruler = self._h-ruler then
        {self.stop-observing old-ruler}
        {old-ruler.detach}
    }

    {if-non-null ruler then
        {self.observe ruler}
        set self._h-ruler = ruler
        {self.clear-h-spacers}

        {if self.h-resize? then
            {self.h-ruler-shim.detach}
            set self.top-left.height = self.worksheet.column-selector-height
            {if self.h-resizer == null then
                || This instance will have resizers on the columns
                set self.h-resizer = {RulerResizer {non-null self.h-ruler}, self}
             else
                || No change needed
                {return}
            }
            {self.add ruler,
                top = {self.top}, bottom = self.h-ruler-fiducial,
                left = self.left-edge, right = self.right-edge
            }
         else
            || Need to anchor self.top-edge to the top of the grid
            {unset self.top-left.height}
            {self.add self.h-ruler-shim,
                top = {self.top}, bottom = self.top-edge,
                left = {self.left}, right = self.left-edge
            }
            {if self.h-resizer == null then
                || No change needed
                {return}
             else
                {self.h-ruler.detach}
                set self.h-ruler = null
                {self.h-resizer.clear} || Probably not strictly necessary
                set self.h-resizer = null
            }
        }
    }
  }

  {doc-next
    {purpose
        The resizers for the columns of this {docref WorksheetGrid},
        if it has column resizing handles.
    }
  }
  field public h-resizer:#RulerResizer

  {doc-next
    {purpose A fiducial for the bottom of the horizontal ruler.}
  }
  field public-get protected-set h-ruler-fiducial:GridFiducial

  {doc-next
    {purpose Holds the {docref WorksheetGrid.h-resize?} property.}
  }
  field protected _h-resize?:bool

  {doc-next
    {purpose
        If true, this {docref WorksheetGrid} will have resize handles
        on the columns.
    }
  }
  {getter public open {h-resize?}:bool
    {return self._h-resize?}
  }

  {setter protected {h-resize? resize?:bool}:void
    set self._h-resize? = resize?
  }

  || Graphical elements to provide feedback as a resizer is dragged
  {doc-next
    {purpose
        A graphical spacer to control the position of the
        h-resize-fiducial as the user is adjusting a column width.
    }
  }
  field protected h-resize-spacer:Fill

  {doc-next
    {purpose
        A graphical object used to draw the vertical line that shows
        the position of the new column width as the user drags the
        resize handle.
    }
  }
  field protected h-resize-rule:Fill

  {doc-next
    {purpose A fiducial to represent the edge where the h-resize-spacer
        meets the h-resize-rule.
    }
  }
  field protected h-resize-fiducial:GridFiducial

  {doc-next
    {purpose Fills inserted into the grid to maintain column spacing.}
  }
  field protected h-spacers:{Array-of Fill}
  
  || Fiducial for the bottom of the h-spacers
||--  field protected h-fiducial:GridFiducial

  || Vertical ruler support

  {doc-next
    {purpose
        The ruler that controls row heights. Two or more grids can share
        the same ruler.
    }
  }
  field protected _v-ruler:#VerticalRuler

  {doc-next
    {purpose
        A {docref Fill} used to anchor the left-edge fiducial to the
        left edge of the grid when there are no vertical resizers.
    }
  }
  field protected v-ruler-shim:Fill

  {doc-next
    {purpose The ruler that controls row heights.}
  }
  {getter {v-ruler}:#VerticalRuler
    {return self._v-ruler}
  }

  {setter {v-ruler ruler:#VerticalRuler}:void
    {if-non-null old-ruler = self._v-ruler then
        {self.stop-observing old-ruler}
        {old-ruler.detach}
    }

    {if-non-null ruler then
        {self.observe ruler}
        set self._v-ruler = ruler
        {self.clear-v-spacers}

        {if self.v-resize? then
            {self.v-ruler-shim.detach}
            set self.top-left.width = self.worksheet.row-selector-width
            {if self.v-resizer == null then
                || This instance will have resizers on the rows
                set self.v-resizer = {RulerResizer {non-null self.v-ruler}, self}
             else
                || No change needed
                {return}
            }
            {self.add ruler,
                top = self.top-edge, bottom = self.bottom-edge,
                left = {self.left}, right = self.v-ruler-fiducial
||--                left = {self.left}, right = {self.right}
            }
         else
            {unset self.top-left.width}
            || Need to anchor self.left-edge to the left of the grid
            {self.add self.v-ruler-shim,
                top = {self.top}, bottom = self.top-edge,
                left = {self.left}, right = self.left-edge
            }
            {if self.v-resizer == null then
                || No change needed
                {return}
             else
                {self.v-ruler.detach}
                set self.v-ruler = null
                {self.v-resizer.clear} || Probably not strictly necessary
                set self.v-resizer = null
            }
        }
    }
  }

  {doc-next
    {purpose
        The resizers for the rows of this {docref WorksheetGrid},
        if it has row resizing handles.
    }
  }
  field public v-resizer:#RulerResizer

  {doc-next
    {purpose A fiducial for the right of the vertical ruler.}
  }
  field public-get protected-set v-ruler-fiducial:GridFiducial

  {doc-next
    {purpose Holds the {docref WorksheetGrid.v-resize?} property.}
  }
  field protected _v-resize?:bool

  {doc-next
    {purpose
        If true, this {docref WorksheetGrid} will have resize handles
        on the rows.
    }
  }
  {getter public open {v-resize?}:bool
    {return self._v-resize?}
  }

  {setter private {v-resize? resize?:bool}:void
    set self._v-resize? = resize?
  }

  || Graphical elements to provide feedback as a resizer is dragged
  {doc-next
    {purpose
        A graphical spacer to control the position of the
        v-resize-fiducial as the user is adjusting a row height.
    }
  }
  field protected v-resize-spacer:Fill

  {doc-next
    {purpose
        A graphical object used to draw the horizontal line that shows
        the position of the new row height as the user drags the
        resize handle.
    }
  }
  field protected v-resize-rule:Fill

  {doc-next
    {purpose A fiducial to represent the edge where the v-resize-spacer
        meets the v-resize-rule.
    }
  }
  field protected v-resize-fiducial:GridFiducial

  {doc-next
    {purpose Fills inserted into the grid to maintain row spacing.}
  }
  field protected v-spacers:{Array-of Fill}
  
  || Fiducial for the bottom of the v-spacers
||--  field protected v-fiducial:GridFiducial


  {doc-next
    {purpose Initialize a new {docref WorksheetGrid}.}
    {parameter
        worksheet, The {docref Worksheet} that this grid belongs to.
    }
    {parameter rows, The number of rows in this grid.
    }
    {parameter cols, The number of columns in this grid.
    }
    {parameter h-ruler, The horizontal ruler that controls the widths of
        the columns in the {docref Worksheet}.
    }
    {parameter v-ruler, The vertical ruler that controls the heights of
        the rows in the {docref Worksheet}.
    }
    {parameter h-resize?,
        Provides the initial value for the {docref
        WorksheetGrid.h-resize?}  property.
    }
    {parameter v-resize?,
        Provides the initial value for the {docref
        WorksheetGrid.v-resize?}  property.
    }
    {parameter ...,
        Option settings.
    }
  }
  {constructor public {default
                          worksheet:Worksheet,
                          rows:int,
                          cols:int,
                          h-ruler:HorizontalRuler,
                          v-ruler:VerticalRuler,
                          h-resize?:bool = true,
                          v-resize?:bool = true,
                          ...
                      }
    set self.worksheet = worksheet
    {construct-super.Observer}
    {construct-super.RowColGrid
        rows, cols,
        vorigin = "top", horigin = "left",
        {splice ...}
    }

    set self.top-left =
        {Fill style-class = "top-left", opaque-to-events? = true}

    set self.h-spacers = {new {Array-of Fill}, efficient-size = cols}
||--    set self.h-ruler-fiducial =
||--        {self.make-fiducial orientation = Orientation.horizontal}
    set self.h-ruler-fiducial = self.top-edge
||--    set self.h-fiducial =
||--        {self.make-fiducial orientation = Orientation.horizontal}
    set self.h-ruler-shim =
        {Fill width = 0mm, height = 0mm, name = "h-ruler-shim"}

    set self.v-spacers = {new {Array-of Fill}, efficient-size = rows}
||--    set self.v-ruler-fiducial =
||--        {self.make-fiducial orientation = Orientation.vertical}
    set self.v-ruler-fiducial = self.left-edge
||--    set self.v-fiducial =
||--        {self.make-fiducial orientation = Orientation.vertical}
    set self.v-ruler-shim =
        {Fill width = 0mm, height = 0mm, name = "v-ruler-shim"}

    set self.h-resize? = h-resize?
    set self.v-resize? = v-resize?

    set self.h-ruler = h-ruler
    set self.v-ruler = v-ruler

    || The following elements are used to draw a line in this grid that
    || tracks the resizer in the header as it is dragged with the mouse
    set self.h-resize-fiducial =
        {self.make-fiducial orientation = Orientation.vertical}
    set self.h-resize-rule =
        {Fill _style-element = "WorksheetGrid/h-resize-rule"}
    set self.h-resize-spacer =
        {Fill _style-element = "WorksheetGrid/h-resize-spacer"}

    set self.v-resize-fiducial =
        {self.make-fiducial orientation = Orientation.horizontal}
    set self.v-resize-rule =
        {Fill _style-element = "WorksheetGrid/v-resize-rule"}
    set self.v-resize-spacer =
        {Fill _style-element = "WorksheetGrid/v-resize-spacer"}

    {self.add self.top-left,
        top = {self.top}, bottom = self.top-edge,
        left = {self.left}, right = self.left-edge
    }
||--    {self.refresh}
  }

||FIXME: optional-resizers (autosize difficult with 4 grids)
||--  {method public open {refresh-resizers}:void
||--    {if self.resizable-rows? and self.v-resizer == null then
||--        {dump "FIXME: resizable-rows?"}
||--     else
||--    }
||--    {if self.resizable-cols? and self.h-resizer == null then
||--        {dump "FIXME: resizable-cols?"}
||--     else
||--    }
||--  }

  {doc-next
    {purpose
        If the point at (x, y) overlaps a cell in this grid, return the
        {docref GridCell}. Otherwise return null.
    }
  }
  {method public open {cell-at-point x:Distance, y:Distance}:#GridCell
    def g =
        {self.find-graphic-at x, y,
            {proc {g:Graphic}:bool
                {return g isa GridCell}
            }
        }
    {if-non-null g then
        {type-switch g
         case gc:GridCell do
            {return gc}
        }
    }
    {return null}
  }


||--  {method protected open {make-cells}:void
||--    {for ri = 0 below self.worksheet.model.rows do
||--        {for ci = 0 below self.worksheet.model.cols do
||--            def cpos = {self.h-ruler.get-position ci}
||--            def rpos = {self.v-ruler.get-position ri}
||--            {if cpos >= 0 and rpos >= 0 then
||--                set self.cells[rpos, cpos] = {self.make-cell ri, ci}
||--            }
||--        }
||--    }
||--  }

||--  ||FIXME: this is just for debugging
||--  {method public open {add-cell
||--                          row:int, col:int,
||--                          g:Graphic,
||--                          rowspan:int = 1,
||--                          colspan:int = 1
||--                      }:Graphic
||--||--    def cv = self.worksheet.model.vals[row, col]
||--||--    {if cv.rowspan > 1 then
||--||--        {dump "add-cell", row, col, self.name, rowspan, colspan}
||--||--    }
||--    {return
||--        {super.add-cell row, col, g, rowspan = rowspan, colspan = colspan}
||--    }
||--  }

  || doc inherited
  {method public open {refresh}:void
    || Things that might change
    || - rows or cols => handled by insert-rows/cols
    || - One of the rulers => update the corresponding RulerResizera
    || - h-offset or v-offset => adjust row heights or column widths
    || - h-resize? or v-resize? => add or remove a resizer (done in setter)

    {if-non-null h-resizer = self.h-resizer then
        set h-resizer.ruler = {non-null self.h-ruler} || In case ruler was changed
    }
    {self.refresh-h-spacers}

    {if-non-null v-resizer = self.v-resizer then
        set v-resizer.ruler = {non-null self.v-ruler} || In case ruler was changed
    }
    {self.refresh-v-spacers}

    ||DEBUG
||--    {if self.name == "main-grid" then
||--        {dump "WSG.refresh", self.name, self.rows, self.cols}
||--    }
    {for rpos = 0 below self.rows do
        {for cpos = 0 below self.cols do
            def ri = {self.v-ruler.get-index rpos}
            def ci = {self.h-ruler.get-index cpos}
            {if ri >= 0 and ri < self.rows and ci >= 0 and ci < self.cols then
                {type-switch self.cells[rpos, cpos]
                 case gc:GridCell do
                    {gc.refresh}

                 case n:Null do
                    def gc = {GridCell self.worksheet, ri, ci}
                    {self.add-cell
                        rpos, cpos, gc, 
                        rowspan = gc.rowspan, colspan = gc.colspan
                    }
||--                    {dump "new cell:", ri, ci, rpos, cpos, {gc.get-text}}
                    {gc.refresh}
                }
            }
        }
    }
  }

  {doc-next
    {purpose
        Return the width of the column at the indicated position in this grid.
    }
  }
  {method public open {get-column-width pos:int}:Distance
    {return
        {self.h-ruler.get-spacer-size pos}
    }
  }

  {doc-next
    {purpose
        Return the height of the row at the indicated position in this grid.
    }
  }
  {method public open {get-row-height pos:int}:Distance
    {return
        {self.v-ruler.get-spacer-size pos}
    }
  }

  {doc-next
    {purpose Remove all of the horizontal spacers so that they can be rebuilt.}
  }
  {method protected open {clear-h-spacers}:void
    {for spacer in self.h-spacers do
        {spacer.detach}
    }
    {self.h-spacers.clear}
  }

  {doc-next
    {purpose
        Add a graphic that represents the resizer for a row or a column.
    }
    {parameter horizontal?,
        If {param horizontal?} is true, the resizer is added above a
        grid line between columns. Otherwise it is added above a grid
        line between rows.
    }
    {parameter i, The 0-origin index of the row or column that this resizer
        belongs to. The resizer is placed at the right edge of a column
        or the bottom edge of a row.
    }
    {parameter resizer, The graphical object that the user will drag in order
        to resize a row or column.
    }
  }
  {method public open {add-resizer
                          horizontal?:bool, i:int, resizer:Graphic
                      }:void
    {if horizontal? then
        def fi = {min self.col-edges.size - 1, i * 2 + 3}
        def right = self.col-edges[fi]
        {self.add
            resizer,
            top = {self.top}, bottom = {self.bottom},
            right = right
        }
     else
        def fi = {min self.row-edges.size - 1, i * 2 + 3}
        def bottom = self.row-edges[fi]
        {self.add
            resizer,
            left = {self.left}, right = {self.right},
            bottom = bottom
        }
    }
  }

  {doc-next
    {purpose Rebuild the horizontal spacers.}
  }
  {method protected open {refresh-h-spacers}:void
    {if self.h-spacers.size != self.cols then
        {self.clear-h-spacers}
        {for i = 0 below self.cols do
            def spacer =
                {Spacer
                    width = {self.h-ruler.get-total-size i},
                    height = 0mm,
                    style-class = "horizontal"
||--                    ,background = ||DEBUG
||--                        {if i mod 2 == 0 then "lime" else "orange"},
||--                    border-width = 1in/300
                }
            {self.h-spacers.append spacer}
            def left = self.col-edges[i*2]
            def right = self.col-edges[(i + 1)*2]
            {super.add spacer,
                left = left, right = right,
                top = {self.top}, bottom = self.top-edge
            }
        }
     else
        {for spacer key si in self.h-spacers do
            set spacer.width = {self.h-ruler.get-total-size si}
        }
    }
  }

  {doc-next
    {purpose Remove all of the vertical spacers so that they can be rebuilt.}
  }
  {method protected open {clear-v-spacers}:void
    {for spacer in self.v-spacers do
        {spacer.detach}
    }
    {self.v-spacers.clear}
  }

  {doc-next
    {purpose Rebuild the vertical spacers.}
  }
  {method protected open {refresh-v-spacers}:void
    {if self.v-spacers.size != self.rows then
        {self.clear-v-spacers} || Rebuild completely
        {for i = 0 below self.rows do
            def spacer =
                {Spacer
                    width = 0mm,
                    height = {self.v-ruler.get-total-size i},
                    style-class = "vertical"
||--                    ,background =||DEBUG
||--                    border-width = 1in/300,
||--                      {if i mod 2 == 0 then "lime" else "orange"}
                }
            {self.v-spacers.append spacer}
            {super.add spacer,
                top = self.row-edges[i*2], bottom = self.row-edges[(i + 1)*2],
                left = {self.left}, right = self.left-edge
            }
        }
     else
        {for spacer key si in self.v-spacers do
            set spacer.height =
                {self.v-ruler.get-total-size si}
        }
    }
  }

  {doc-next
    {purpose Refresh the horizontal and vertical resizers.}
  }
  {method public open {refresh-resizers}:void
    {if-non-null resizer = self.h-resizer then
        {resizer.refresh}
    }
    {if-non-null resizer = self.v-resizer then
        {resizer.refresh}
    }
  }

  || Override
  {method public open {clear}:void
    {self.clear-h-spacers}
    {self.clear-v-spacers}
    {super.clear}
    {if-non-null resizer = self.h-resizer then
        {resizer.clear}
    }
    {if-non-null resizer = self.v-resizer then
        {resizer.clear}
    }
  }

  {doc-next
    {purpose
        Mark all {docref GridCell}s starting at ({param row}, {param col})
        as stale to force them to be refreshed later.
    }
  }
  {method public open {mark-cells-stale row:int, col:int}:void
    set row = {max 0, row - 1} ||x
    {for ri = row below self.rows do
        {for ci = col below self.cols do
            {type-switch self.cells[ri, ci]
             case gc:GridCell do
                set gc.stale? = true
            }
        }
    }
  }

  || Override
  || Insert or delete rows, but only insofar as they are visible in self.
  || first and count are model coordinates. The model is updated separately,
  || before calling this method.
  {method public open {insert-rows 
                          first:int, count:int,
                          init-proc:#{proc-type {r:int, c:int}:Graphic} = null
                      }:void
    || Compute the first and last included in this grid, in positional coords
    def delete? = count < 0
    def (r0, r1) = {self.v-ruler.clip first, count}
    {if r0 >= 0 then
        let gcount:int = r1 - r0 + 1
        {for ri = first below self.rows do
            {for ci = 0 below self.cols do
                {type-switch self.cells[ri, ci]
                 case gc:GridCell do
                    {inc gc.row, count}
                    set gc.stale? = true
                }
            }
        }

        {if delete? then
            set gcount = -gcount
        }
||--        {dump "insert-rows", self.name, first, count, r0, r1, gcount}
        {super.insert-rows r0, gcount, init-proc = init-proc}
        {self.mark-cells-stale r0, 0}

        || Re-insert all of the spacers
        {self.refresh-v-spacers}
    }

    || Refresh synchronously to create the GridCells needed
    {self.refresh}
  }


  {doc-next
    {purpose
        Add rows to self so that additional rows that already exist in
        the model will become visible.
    }
  }
  {method public open {reveal-rows
                          first:int, count:int,
                          init-proc:#{proc-type {r:int, c:int}:Graphic} = null
                      }:void
    def delete? = count < 0

||--    || Compute the first and last included in this grid, in positional coords
||--    let last:int = first + {abs count} - 1
||--    {if first > self.last-index or last < self.offset then
||--        || No overlap
||--        {return}
||--    }
||--
||--    {if first < self.offset then
||--        set first = self.offset
||--    }
||--    {if last > self.last-index then
||--        set last = self.last-index
||--    }
||--    set count = last - first + 1
||--    {if delete? then
||--        set count = -count
||--    }

    def (r0, r1) = {self.v-ruler.clip first, count}
    {if r0 >= 0 then
        let gcount:int = r1 - r0 + 1
        {if delete? then
            set gcount = -gcount
        }
||--        {dump "reveal-rows", self.name, first, count, r0, r1, gcount}
        {super.insert-rows r0, gcount, init-proc = init-proc}
        {self.mark-cells-stale r0, 0}

        || Re-insert all of the spacers
||--        {self.clear-v-spacers} || Force full re-build
        {self.refresh-v-spacers}
    }
    || Refresh synchronously to create the GridCells needed
||x    {self.refresh}
  }

  || Override
  {method public open {insert-cols 
                          first:int, count:int,
                          init-proc:#{proc-type {r:int, c:int}:Graphic} = null
                      }:void

    def delete? = count < 0
    def (c0, c1) = {self.h-ruler.clip first, count}
    {if c0 >= 0 then
        let gcount:int = c1 - c0 + 1
        {for ri = 0 below self.rows do
            {for ci = first below self.cols do
                {type-switch self.cells[ri, ci]
                 case gc:GridCell do
                    {inc gc.col, count}
                }
            }
        }

        {if delete? then
            set gcount = -gcount
        }
||--        {dump "insert-cols", self.name, first, count, c0, c1, gcount}
        {super.insert-cols c0, gcount, init-proc = init-proc}
        {self.mark-cells-stale 0, c0}

        || Re-insert all of the spacers
||--        {self.clear-h-spacers} || Force full re-build
        {self.refresh-h-spacers}
    }

    || Refresh synchronously to create the GridCells needed
    {self.refresh}
  }


  {doc-next
    {purpose
        Add columns to self so that additional columns that already exist in
        the model will become visible.
    }
  }
  {method public open {reveal-cols 
                          first:int, count:int,
                          init-proc:#{proc-type {r:int, c:int}:Graphic} = null
                      }:void

    def delete? = count < 0
    def (c0, c1) = {self.h-ruler.clip first, count}
    {if c0 >= 0 then
        let gcount:int = c1 - c0 + 1

        {if delete? then
            set gcount = -gcount
        }
||--        {dump "reveal-cols", self.name, first, count, c0, c1, gcount}
        {super.insert-cols c0, gcount, init-proc = init-proc}
        {self.mark-cells-stale 0, c0}

        || Re-insert all of the spacers
||--        {self.clear-h-spacers} || Force full re-build
        {self.refresh-h-spacers}
    }
    || Refresh synchronously to create the GridCells needed
||--    {self.refresh}
  }

  || Override
  {method protected open {handle-observer-message
                             sender:Observable,
                             message:any
                         }:void
      {type-switch sender
       case r:HorizontalRuler do
          {if r == self.h-ruler then
              {type-switch message
               case resizer:RulerResizer do
                  || If this grid has no resizer, it needs to track the resizer
                  || the user is dragging.
                  def cpos = resizer.resizer-pos
||--                  {dump self.name, cpos, resizer.state}
                  {if cpos < 0 or cpos >= self.cols then
                      || Adjusting a column not shown in this grid
                      {return}
                  }
                  def old-width = {self.get-column-width cpos}
                  {if old-width == 0m then
                      {return}
                  }
                  def new-width = {max 1mm, resizer.new-x + old-width}
                  let x:Distance = 0m
                  {for i = 0 below cpos do
                      {inc x, {self.get-column-width i}}
                  }
||--                  {dump resizer.state, cpos, old-width/1pt, new-width/1pt, x/1pt}
                  
                  {switch resizer.state
                   case "press" do ||""
                      || Insert a graphic to track the cursor
                      set self.h-resize-spacer.width = x + new-width
                      {self.add
                          self.h-resize-spacer,
                          left = self.col-edges[0],
                          right = self.h-resize-fiducial,
                          top = {self.top}
                      }
                      {self.add
                          self.h-resize-rule,
                          left = self.h-resize-fiducial,
                          top = {self.top},
                          bottom = {self.bottom}
                      }
                   case "move" do ||""
                      || Adjust the line to track the new cursor position
                      set self.h-resize-spacer.width = x + new-width
                   case "release" do ||""
                      || Remove the graphic that tracks the cursor
                      {self.h-resize-rule.detach}
                      {self.h-resize-spacer.detach}
                   else
                      {error "Internal error: unrecognized message '%s'", message}
                  }
               else
                  || Sender is our h-ruler, but not a resize
                  {for cpos = 0 below self.cols do
                      set self.h-spacers[cpos].width = {r.get-spacer-size cpos}
                  }
              }
          }

       case r:VerticalRuler do
          {if r == self.v-ruler then
              {type-switch message
               case resizer:RulerResizer do
                  || If this grid has no resizer, it needs to track the resizer
                  || the user is dragging.
                  def rpos = resizer.resizer-pos
||--                  {dump self.name, gri, resizer.state}
                  {if rpos < 0 or rpos >= self.rows then
                      || Adjusting a column not shown in this grid
                      {return}
                  }
                  def old-height = {self.get-row-height rpos}
                  {if old-height == 0m then
                      {return}
                  }
                  def new-height = {max 1mm, resizer.new-y + old-height}
                  let x:Distance = 0m
                  {for i = 0 below rpos do
                      {inc x, {self.get-row-height i}}
                  }
||--                  {dump resizer.state, rpos, old-height/1pt, new-height/1pt, x/1pt}
                  
                  {switch resizer.state
                   case "press" do ||""
                      || Insert a graphic to track the cursor
                      set self.v-resize-spacer.height = x + new-height
                      {self.add
                          self.v-resize-spacer,
                          top = self.row-edges[0],
                          bottom = self.v-resize-fiducial,
                          left = {self.left}
                      }
                      {self.add
                          self.v-resize-rule,
                          top = self.v-resize-fiducial,
                          left = {self.left},
                          right = {self.right}
                      }
                   case "move" do ||""
                      || Adjust the line to track the new cursor position
                      set self.v-resize-spacer.height = x + new-height
                   case "release" do ||""
                      || Remove the graphic that tracks the cursor
                      {self.v-resize-rule.detach}
                      {self.v-resize-spacer.detach}
                   else
                      {error "Internal error: unrecognized message '%s'", message}
                  }
               else
                  || Sender is our v-ruler, but not a resize
                  {for rpos = 0 below self.rows do
||--                      {dump self.name, rpos, self.v-offset}
                      set self.v-spacers[rpos].height = {r.get-spacer-size rpos}
                  }
              }
          }
      }
  }
}


{doc-next
    {purpose
        A rectangular grid of cells with automatic calculations invoked
        when cell values are changed.
    }
    {notes
        {bold This is a preview release. The API is subject to change}
    }
}
{define-class public open Worksheet
  {inherits
    SelectionContext, ContainerDragScroller, CommandContext,
    StandardActiveTraversalContainer, Observer,
    RefreshMixin
  }

||--  ||FIXME: temporary override
||--  {method public open {update}:void
||--    {super.update}
||--  }

  {doc-next
    {purpose
        Default height for a newly created row, if not specified
        by {docref Worksheet.v-ruler-spec}.
    }
  }
  {local-option public default-row-height:any = 18pt
  }

  {doc-next
    {purpose
        Default width for a newly created column, if not specified
        by {docref WorksheetModel.h-ruler-spec}.
    }
  }
  {local-option public default-column-width:any = 60pt
  }


  {doc-next
    {purpose The number of rows at the left of the {ctext Worksheet}
        that do not scroll horizontally if the {ctext Worksheet} has
        scrollbars.
    }
  }
  {local-option public frozen-rows:int = 0
    {if frozen-rows < 0 then
        {error {hlformat "frozen-rows=%s: must not be negative", frozen-rows}}
    }
    {self.update}
  }

  {doc-next
    {purpose The number of columns at the top of the {ctext Worksheet}
        that do not scroll vertically if the {ctext Worksheet} has
        scrollbars.
    }
  }
  {local-option public frozen-cols:int = 0
    {if frozen-cols < 0 then
        {error {hlformat "frozen-rows=%s: must not be negative", frozen-cols}}
    }
    {self.update}
  }

  {doc-next
    {purpose Returns the number of visible frozen rows.}
  }
  {getter public open {visible-frozen-rows}:int
    {return self.v-ruler-top.visible-count}
  }

  {doc-next
    {purpose Returns the number of visible frozen columns.}
  }
  {getter public open {visible-frozen-cols}:int
    {return self.h-ruler-left.visible-count}
  }

  {doc-next
    {purpose Returns the number of visible scrolling rows.}
  }
  {getter public open {visible-scrolling-rows}:int
    {return self.v-ruler-main.visible-count}
  }

  {doc-next
    {purpose Returns the number of visible scrolling columns.}
  }
  {getter public open {visible-scrolling-cols}:int
    {return self.h-ruler-main.visible-count}
  }

  || Set to 0m to make the row selectors disappear
  {doc-next
    {purpose The width of the row selectors a the far left
        of the grid.
    }
  }
  {local-option public row-selector-width:Distance = 5pt
    {self.update}
  }

  || Set to 0m to make the column selectors disappear
  {doc-next
    {purpose The height of the column selectors a the top
        of the grid.
    }
  }
  {local-option public column-selector-height:Distance = 5pt
    {self.update}
  }

  {doc-next
    {purpose
        If true, the {docref Worksheet} will have scrollbars if the
        width or height is constrained so that not all cells can be
        visible at once.
    }
  }
  {local-option public scrollable?:bool = true
    {self.make-grid-frames}
  }
||--        The {param scrollable?} argument specifies whether or not
||--        the {ctext Worksheet} will have internal scrollbars. If it is
||--        true, and you constrain the width or height of the worksheet
||--        scrollbars will appear as necessary. If there are 
||--        {docref-abbr Worksheet.frozen-rows} or
||--        {docref-abbr Worksheet.frozen-cols}, they will be outside
||--        of the scrollable area.
||--  {getter private {scrollable?}:bool
||--    {return true}
||--  }

  ||FIXME: these should be local options, and/or set in the style sheet
  def public readonly-bg = "#f0f0f0" asa FillPattern
  def public editable-bg = "white" asa FillPattern
  def public header-bg = "#f0f0f070" asa FillPattern
  def public header-color = "#ccc" asa FillPattern

||--  ||FIXME: is this a good idea?
||--  {nonlocal-option public grid-line-color:FillPattern
||--||--    set self.border-color = grid-line-color
||--  }

  {doc-next
    {purpose The model associated with this {docref Worksheet}.}
  }
  field public-get protected-set model:WorksheetModel =
      {uninitialized-value-for-type WorksheetModel}

  {doc-next
    {purpose A {docref VerticalRuler} for the frozen rows.}
  }
  field public-get protected-set v-ruler-top:VerticalRuler =
      {uninitialized-value-for-type VerticalRuler}

  {doc-next
    {purpose A {docref VerticalRuler} for the scrollable rows.}
  }
  field public-get protected-set v-ruler-main:VerticalRuler =
      {uninitialized-value-for-type VerticalRuler}

  {doc-next
    {purpose A {docref HorizontalRuler} for the frozen columns.}
  }
  field public-get protected-set h-ruler-left:HorizontalRuler =
      {uninitialized-value-for-type HorizontalRuler}

  {doc-next
    {purpose A {docref HorizontalRuler} for the scrollable columns.}
  }
  field public-get protected-set h-ruler-main:HorizontalRuler =
      {uninitialized-value-for-type HorizontalRuler}

  {doc-next
    {purpose
        The row containing the current cell.
        (See {docref Worksheet.active?})
    }
  }
  field public-get protected-set active-row:int

  {doc-next
    {purpose
        The column containing the current cell.
        (See {docref Worksheet.active?})
    }
  }
  field public-get protected-set active-col:int

  || Selection support
  field protected _selection:WorksheetSelection
  field protected selecting?:bool = false
  field protected point-row:int
  field protected point-col:int
  field protected anchor-row:int
  field protected anchor-col:int
  field private shift?:bool = false

  || for context menu handling
  field private _context-row:int = -2
  field private _context-column:int = -2


  || The main container
  field protected grid:Grid

  || Containers for the four independently scrolling parts
  field protected top-left-frame:#Frame
  field protected top-frame:#Frame
  field protected left-frame:#Frame
  field protected main-frame:#Frame

  field protected top-left-grid:#WorksheetGrid
  field protected top-grid:#WorksheetGrid
  field protected left-grid:#WorksheetGrid
  field protected main-grid:#WorksheetGrid


  field protected last-frozen-cols:int = -1
  field protected last-frozen-rows:int = -1

  field private last-row-edit-count:int
  field private last-col-edit-count:int
  field private argn:int
  field private irows:int
  field private model?:bool
  field private row-heights:Array = {Array}
  field private col-widths:Array = {Array}

  field protected vmid:GridFiducial
  field protected hmid:GridFiducial

  {doc-next
    {purpose
        Create a new {docref Worksheet}.
    }
    {notes
        {bold This is a preview release. The API is subject to change}
    }
    {details
        This constructor is designed to allow the {ctext Worksheet} to
        be created in the declarative style so far as possible. A
        number of keyword arguments can be used in the constructor,
        some of which can be repeated (this is similar to {docref
        Canvas.add}). In addition, the handling of non-keyword
        arguments will depend on the data type.

        The first one or two parameters will define the data model and
        can be either a {docref WorksheetModel} or a pair of integers
        representing the number of rows and number of columns in the
        model.

        The next argument may be a call to the procedure {docref
        widths}, which returns a {docref RulerSpec}. This will
        determine the widths of the columns. If it is ommitted, or
        if it doesn't specify a width for every column, the value
        of {docref Worksheet.default-column-width} is used. In a
        similar way, row heights can be specified by calling
        {docref heights}, and the {docref Worksheet.default-row-height}
        is used for the height of a row that is not otherwise
        specified.

        Additional positional arguments define the cells in the
        worksheet.  Use {param row \= int} and {param col \= int} to
        specify the insertion position. The keyword arguments {param
        rowspan \= int} and {param colspan \= int} can also be used to
        set a rowspan or colspan for the next positional argument when
        it is inserted into the worksheet.

        After a value is inserted, the insertion column position is
        automatically advanced to the next available cell,
        taking {param colspan} into account.

        The keywords {param row-height} and {param column-width} are
        used to specify the height of the row or width of the column
        at the current insertion position. These values will replace
        values in the ruler, if one was specified earlier.

        The keyword {param cell} allows a {docref CellRef} determine
        the location where the next cell will be inserted.  The
        keyword argument {param cell \= String} is handled by
        calling {ctext self.model.get-ref} to obtain a {docref
        CellRef}. You can also use {param cell \= CellRef} to specify
        a {ctext CellRef} you have already constructed or obtained by
        calling {docref WorksheetModel.get-ref}. This is useful when
        you have set a variable to a {ctext CellRef} and want to
        define the cell at that location.

        Any other keyword argument will be interpreted as an option
        setting for the {ctext Worksheet}.

        The non-keyword arguments are handled according to their
        data type.

        The calls {docref row-group} and {docref col-group} return
        a {docref GroupProto}. These are used to define the hierarchy
        of row and column groups. They must be specified from the top
        down, with the highest level {ctext row-group}s in column 0
        and the highest level {ctext col-group}s in row 0. Any nested
        group must be completely within a group at the next higher
        level.

        The following calls are used to insert a cell of a particular
        type. They are all just different ways to create a
        {docref CellSpec}, and any of they keyword arguments
        accepted by the {ctext WksCellSpec} constructor can be passed
        to these procedures. Any options that are valid on a {docref
        Graphic} can also be passed to these procedures. They will be
        applied to the cell contents when the cell is created or
        updated.

        {docref currency-cell}: The cell will use the {docref
        CurrencyDomain} and be right justified.

        {docref formula-cell}: The cell contains a formula.
        The domain is {docref DataSource.double-domain} by default.

        {docref input-cell}: A cell that will be editable when
        the user clicks on it.

        {docref display-cell}: A cell that displays a {docref
        Graphic} of some kind but is not intended to have a value.

        {docref value-cell}: Used when none of the above procedures
        is applicable.

        If a non-keyword argument is an event handler, it is attached
        to the {ctext Worksheet}.

        Any other argument is used as the value of the next available
        cell. Such a cell will not be editable, and will have a domain
        chosen according to the data type.

        {bold Worksheet Example}

        The following example defines a simple worksheet. The numbers
        in the Hours column are editable. They are added up to get
        the value in the total cell.

        The first Date field is editable. The remaining dates, and
        the names of the days, are computed from the value you choose.

        The line items are grouped under the headings. Click the
        small triangle to expand and contract the group.

        The formulas use relative cell references so the same formulas
        can be used on each line. Note that the formula for column 2
        has to be entered before the formula for column 1, because
        formulas are computed in the order that they are added.

        At the bottom of the worksheet there is a button that will
        call {docref WorksheetModel.get-data} and display the result.
        Note that only editable cells are captured in the JSON
        representation. Other cells will be recomputed when the data
        is restored (using {docref WorksheetModel.put-data}).
    }
    {paragraph
    {example
        title = "Weekly Time Sheet Example",
        {import * from CURL.IO.JSON}
        {import * from COM.CURL.EXT.WORKSHEET}
        || A procedure to sum a range of cells
        {def sum =
            {proc {dest:DataRef, src:DataRef}:void
                let sum:double = 0.0
                {for v in src do
                    {inc sum, v.as-double}
                }
                set dest.value = sum
            }
        }

        || A procedure to compute the next day from a cell containing a date
        {def next-day =
            {proc {dest:DataRef, src:DataRef}:void
                set dest.value = src.value + 1d
            }
        }

        || A procedure to compute the day name from a cell containing a date
        {def day-name =
            {proc {dest:DataRef, src:DataRef}:void
                set dest.value =
                    (src.value asa DateTime).info.locale-weekday
            }
        }

        || A procedure that concatenates any number of cell values
        {def concat =
            {proc {dest:DataRef, ...:DataRef}:void
                def buf = {StringBuf}
                {for r in ... do
                    {buf.concat r.as-String}
                }
                set dest.value = {buf.to-String}
            }
        }

        || A cell with a formula to compute the next day from the cell above
        {def next-date-cell =
            {formula-cell
                domain = DataSource.date-domain, next-day, {RelativeCellRef -1, 0}
            }
        }

        || A cell with a formula to compute the day name from the cell to the right
        {def day-cell =
            {formula-cell domain = String, day-name, {RelativeCellRef 0, 1}}}

        {Worksheet
            10, 6,
            default-column-width = 0.75in,
            {widths 1.75in, 1.25in, 1.25in},
            colspan = 2, {bold Example Worksheet},

            row = 1, col = 0, {row-group 6},
            {formula-cell domain = String, 
                concat, {ValueRef "Week of "}, {RelativeCellRef 1, 2}
            },
            "Day", "Date", {value-cell halign = "right", "Hours"},

            row = 2, col = 1,
            {formula-cell domain = String, day-name, {RelativeCellRef 0, 1}},
            {input-cell {DateTime.date "2010-10-11"}},
            {input-cell halign = "right", 7},

            row = 3,
            col = 2, next-date-cell,
            col = 1, day-cell,
            col = 3, {input-cell halign = "right", 9},

            row = 4,
            col = 2, next-date-cell,
            col = 1, day-cell,
            col = 3, {input-cell halign = "right", 8},

            row = 5, 
            col = 2, next-date-cell,
            col = 1, day-cell,
            col = 3, {input-cell halign = "right", 9},

            row = 6,
            col = 2, next-date-cell,
            col = 1, day-cell,
            col = 3, {input-cell halign = "right", 4},

            row = 7, col = 2,
            "Total:", {formula-cell halign = "right", sum, {StringRef "D3:D7"}},

            row = 9, col = 0,
            {CommandButton
                label = "Show Json Data",
                {on e:Action at cb:CommandButton do
                    {type-switch cb.selection-context
                     case wks:Worksheet do
                        {popup-message
                            title = "Time Sheet Data",
                            {Frame margin = 6pt,
                                text-preserve-whitespace? = true,
                                {JsonValue-to-String 
                                    {wks.model.get-data}, prettify? = true
                                }
                            }
                        }
                    }                    
                }
            }
        }
    }
    }
    ||FIXME: Does it make sense to have these clauses?
||--    {parameter {italic model:WorksheetModel}, If a {ctext WorksheetModel}
||--        is passed as the first argument, it is used as the data
||--        model. Otherwise the first two parameters must be {param
||--        row:int} and {param col:int}.
||--    }
||--    {parameter cs:WksCellSpec, Specifies the contents of a cell}
  }
  {constructor public {default
                          ...
                      }
    || Initialize the base classes
    {construct-super.RefreshMixin}
    {construct-super.ContainerDragScroller}
    {construct-super.SelectionContext}
    {construct-super.Observer}


    || Initialize the data structures that hold items passed in as rest args
    set self.grid =
        {Grid
            horigin = 0.0, vorigin = 0.0
        }

    || Fiducials to split the outermost grid
    set self.vmid =
        {self.grid.make-fiducial orientation = Orientation.vertical}
    set self.hmid =
        {self.grid.make-fiducial orientation = Orientation.horizontal}

    {self.add self.grid}

    || This is where the rest args get processed, so the grid must be ready
    {construct-super.StandardActiveTraversalContainer
        vstretch? = true, hstretch? = true,
        _style-element = "Worksheet",
        {splice ...}
    }
    {if self.model.v-ruler-spec == null then
        set self.model.v-ruler-spec =
            {RulerSpec Orientation.vertical, self.frozen-rows}
     else
        set self.model.v-ruler-spec.split-count = self.frozen-rows
    }
    {for i = 0 below self.row-heights.size step 2 do
        def ri = self.row-heights[i] asa int
        def rsize =
            {any-to-Distance
                {self.model.v-ruler-spec.get-spec-size ri, self.default-row-height}
            }
        {self.model.v-ruler-spec.set-spec-size
            ri, {max rsize, {any-to-Distance self.row-heights[i + 1]}}
        }
    }

    {if self.model.h-ruler-spec == null then
        set self.model.h-ruler-spec =
            {RulerSpec Orientation.horizontal, self.frozen-cols}
     else
        set self.model.h-ruler-spec.split-count = self.frozen-cols
    }
    {for i = 0 below self.col-widths.size step 2 do
        def ci = self.col-widths[i] asa int
        def csize =
            {any-to-Distance
                {self.model.h-ruler-spec.get-spec-size ci, self.default-column-width}
            }
        {self.model.h-ruler-spec.set-spec-size
            ci, {max csize, {any-to-Distance self.col-widths[i + 1]}}
        }
    }

||--    set self.scrollable? = scrollable?
||--    {dump self.scrollable?}

    {self.refresh-rulers}
    {if self.top-left-grid == null then
        {self.make-grid-frames}
    }

    {if self.model == {uninitialized-value-for-type WorksheetModel} then
        {error 
            {hlmessage You must pass a WorksheetModel to the constructor,
                or the first two arguments must be integers specifying
                the number of rows and columns.
            }
        }
     else
        {self.observe self.model}
    }
    set self._selection = {WorksheetSelection.empty self}
    set self.selection-context = self

    set self.active-row = 0
    set self.active-col = 0

    ||FIXME: if you do this, the last worksheet in the applet will grab
    || focus. Perhaps
||--    || Start at the first traversable
||--    set self.active-row = self.model.rows - 1
||--    set self.active-col = self.model.cols - 1
||--    set (self.active-row, self.active-col) = {self.find-next-active}


||--    {after 0s do
||--        {self.model.refresh}
||--        {self.handle-event {SelectionChanged}}
||--    }        
    {self.model.refresh}
    {self.refresh}
  }

  {doc-next
    {purpose
        Return true if the cell at the specified row and column is the
        active cell.
    }
  }
  {method public open {active? row:int, col:int}:bool
    {return
        row == self.active-row and
        col == self.active-col
    }
  }

  {method protected open {refresh-rulers}:void
||--    def r1 = {self.model.row-tree.map-index-to-position self.frozen-rows}
||--    def r2 = {self.model.row-tree.map-index-to-position self.model.rows}
||--    def c1 = {self.model.col-tree.map-index-to-position self.frozen-cols}
||--    def c2 = {self.model.col-tree.map-index-to-position self.model.cols}

    {if self.v-ruler-main == {uninitialized-value-for-type VerticalRuler} then
        set self.v-ruler-top = {VerticalRuler self, 0}
        set self.v-ruler-main = {VerticalRuler self, 1}
        set self.h-ruler-left = {HorizontalRuler self, 0}
        set self.h-ruler-main = {HorizontalRuler self, 1}
    else
        {self.v-ruler-top.refresh}
        {self.v-ruler-main.refresh}
        {self.h-ruler-left.refresh}
        {self.h-ruler-main.refresh}
    }
  }

  {method protected open {make-grid-frames}:void
    || The top-left frame never scrolls
    set self.top-left-frame =
        {self.make-grid-frame false, self.top-left-frame}
    set self.top-left-frame.opaque-to-events? = true
    {self.grid.add self.top-left-frame,
        top = {self.grid.top}, bottom = self.hmid,
        left = {self.grid.left}, right = self.vmid
    }

    || The  top-frame cannot scroll vertically
    || It has a horizontal scrollbar only if needed
    set self.top-frame =
        {self.make-grid-frame
            self.scrollable?, self.top-frame,
            name = "top-frame",
            always-disable-hscroll? = true,
            shrink-hscroll? = true,
            expanded-hscroll-bounds? = true,
            vscroll? = false
        }
    {self.grid.add self.top-frame,
        top = {self.grid.top}, bottom = self.hmid,
        left = self.vmid, right = {self.grid.right}
    }

    || The  left-frame cannot scroll horizontally
    || It has a vertical scrollbar only if needed
    set self.left-frame =
        {self.make-grid-frame
            self.scrollable?, self.left-frame,
            name = "left-frame",
            hscroll? = false,
            always-disable-vscroll? = true,
            shrink-vscroll? = true,
            expanded-vscroll-bounds? = true
        }

    || Adjust scrollboxes if necessary
    {type-switch self.left-frame
     case left-frame:ScrollBox do
        || Allocate the space but don't draw anything
        set {left-frame.get-hscroll}.visible? = false
    }
    {self.grid.add
        self.left-frame,
        top = self.hmid, bottom = {self.grid.bottom}, 
        left = {self.grid.left}, right = self.vmid
    }

    set self.main-frame =
        {self.make-grid-frame
            self.scrollable?, self.main-frame,
            always-disable-hscroll? = false,
            shrink-hscroll? = false,
            always-disable-vscroll? = false,
            shrink-vscroll? = false,
            "main-graphic" ||DEBUG
        }
    {type-switch self.main-frame
     case main-frame:ScrollBox do
        def main-vscroll = {main-frame.get-vscroll}
        {main-vscroll.add-event-handler
            {on e:Adjustment at sb:Scrollbar do
                {(self.left-frame asa ScrollBox).scroll-to
                    x = 0m,
                    y = main-frame.vertical-position
                }
            }
        }

        def main-hscroll = {main-frame.get-hscroll}
        {main-hscroll.add-event-handler
            {on e:Adjustment at sb:Scrollbar do
                {(self.top-frame asa ScrollBox).scroll-to
                    x = main-frame.horizontal-position,
                    y = 0m
                }
            }
        }
    }
    {self.grid.add self.main-frame,
        top = self.hmid, bottom = {self.grid.bottom},
        left = self.vmid, right = {self.grid.right}
    }
  }

  {doc-next
    {purpose Create or replace one of the four inner frames.}
    {details
        The {docref Worksheet} is displayed in four separate frames
        to separate the scrolling rows and columns from the frozen
        rows and columns. If a quadrant is scrollable, the "frame"
        is a {docref ScrollBox} otherwise it is a {docref Frame}.
    }
  }   
  {method protected open {make-grid-frame scroll?:bool, f:#Frame, ...}:Frame
    let child:#Graphic = null
    {if-non-null f then
        {f.detach}
        {if-non-null fl = f.child then
            set child = fl.graphic
        }
    }
    def frame =
        {if scroll? then
            {ScrollBox
                valign = "top", halign = "left",
                {splice ...}
            }
         else
            {Frame valign = "top", halign = "left",
                style-class = "grid-frame"
            }
        }
    {if-non-null child then
        {frame.add child}
    }
    {return frame}
  }

  field protected insert-row:int = 0
  field protected insert-col:int = 0
  field protected insert-rowspan:int = 1
  field protected insert-colspan:int = 1

  {method private {increment-insertion-pos spec:CellSpec}:void
    {inc self.insert-col, spec.colspan}
    {if self.insert-col >= self.model.cols then
        set self.insert-col = 0
        {inc self.insert-row, spec.rowspan}
    }
    set self.insert-rowspan = 1
    set self.insert-colspan = 1
  }

  {method private {verify-cell-empty}:void
    {if self.insert-row < self.model.rows and
        self.insert-col < self.model.cols
     then
        def cv = self.model.vals[self.insert-row, self.insert-col]
        {if cv.value != null then
            {error
                {hlformat
                    "Cell at row=%1!s! col=%2!s! already contains value='%3!s!'",
                    self.insert-row, self.insert-col, cv.value
                }
            }
        }
    }
  }

  || Add something to the current cell location
  {method public open {non-keyword-init-arg a:any}:void

    || First handle args that are not cell specs or values
    {type-switch a
     case eh:EventHandler do
        {super.non-keyword-init-arg eh}
        {return}

     case i:int do
        {if not self.model? then
            {inc self.argn}
            {if self.argn == 1 then
                set self.irows = i
                {return}
             elseif self.argn == 2 then
                {self.init-model {WorksheetModel self.irows, i}}
                {return}
            }
        }
        || Fall through and insert as a cell value

     case model:WorksheetModel do
        {inc self.argn}
        {if self.model? then
            {error {hlmessage A model has already been specified.}}
        }
        {if self.irows > 0 then
            {error
                {hlmessage The model must be specified before any values.}
            }
        }
        {self.init-model model}
        {return}

     case ruler:RulerSpec do
        {if not self.model? then
            {error
                {hlmessage The model must be specified before the rulers.}
            }
        }
        {if ruler.orientation == Orientation.horizontal then
            set self.model.h-ruler-spec = ruler
         else
            set self.model.v-ruler-spec = ruler
        }
        {return}

     case gp:GroupProto do
        {self.insert-group self.insert-row, self.insert-col, gp}
        {return}

     case erf:EmbeddedRecordForm do
        {if erf.base-row < 0 then
            set erf.base-row = self.insert-row
        }
        {if erf.base-col < 0 then
            set erf.base-col = self.insert-col
        }
        set erf.worksheet = self
        def cv = self.model.vals[erf.base-row, erf.base-col]
        {if cv.embedded-form == null then
            set cv.embedded-form = erf
         else
            {error
                {hlformat
                    "There already is an EmbeddedRecordForm on row %s.", erf.base-row
                }
            }
        }
        {self.model.store-embedded-form erf}
        {return}
    }

    {self.verify-cell-empty}
    let spec:CellSpec = {self.make-cell-spec a}
    def cv = {self.init-cell spec}
    {self.increment-insertion-pos spec}
  }

  {method protected open {keyword-init-arg key:String, value:any}:void
    {if key == "row" then ||""
        set self.insert-row = value asa int
     elseif key == "col" or key == "column" then ||""
        set self.insert-col = value asa int
     elseif key == "rowspan" then ||""
        set self.insert-rowspan = value asa int
     elseif key == "row-height" then ||""
        {self.row-heights.append self.insert-row}
        {self.row-heights.append value}
     elseif key == "column-width" then ||""
        {self.col-widths.append self.insert-col}
        {self.col-widths.append value}
     elseif key == "colspan" then ||""
        set self.insert-colspan = value asa int
     elseif key == "cell" then ||""
        let ref:#CellRef = null
        {type-switch value
         case cr:CellRef do
            set ref = cr
         case s:String do
            def sr = {self.model.get-ref s}
            {if sr isa CellRef then
                set ref = sr asa CellRef
             else
                {error 
                    {hlformat "Expected a CelLRef: '%s'", value}
                }
            }
         else
            {error 
                {hlformat "Unexpected argument: '%s'", value}
            }
        }
        {if-non-null ref then
||--            {dump "FIXME: check this"}
            {if ref.absolute? then
                set self.insert-col = ref.col
                set self.insert-row = ref.row
             else
                {error 
                    {hlformat "Cell Reference must be absolute: '%s'", value}
                }
            }
         else
            {assert false} || internal error
        }
     else
        {super.keyword-init-arg key, value}
    }
  }

  {doc-next
    {purpose
        Insert a group specification at the indicated row and column.
    }
  }
  {method public open {insert-group row:int, col:int, gp:GroupProto}:void
    def cv = self.model.vals[row, col]
    {if gp.row? then
        set cv.rowspan = gp.span
        {self.model.row-tree.insert-group
            {GroupSpec
                true, col, row,
                row + gp.span - 1,
                expanded? = true
            }
        }
     else
        set cv.colspan = gp.span
        {self.model.col-tree.insert-group
            {GroupSpec
                false, row, col,
                col + gp.span - 1,
                expanded? = true
            }
        }
    }
  }

  {doc-next
    {purpose Insert or delete rows in the worksheet.}
    {details
        Insert {param count} empty rows at the row indicated by
        {param first}, pushing existing rows down to make room. If
        count is negative, rows are removed.
    }
    {parameter first, The position where rows will be added or
        deleted. The value must range between 0 and the number of
        rows currently in the grid, or {docref ArrayBoundsException}
        will be thrown.
    }
    {parameter count, If positive, the number of rows to be
        added. If negative, the number of rows to be removed.
    }
  }
  {method public open {insert-rows first:int, count:int}:void
||--    {dump "insert-rows", first, count, self.model.rows}
    {self.check-invariants} ||qfix
    {if count == 0 then
        {return}
    }
    def cols = self.model.cols
    def rows = self.model.rows

    || Do this first or GridCells will acquire attributes from the wrong cells
    {self.model.insert-rows first, count}
    {self.model.v-ruler-spec.insert first, count, self.default-row-height}

||--    || If adding, update the model and rulers first
||--    {if count > 0 then
||--        {self.model.insert-rows first, count}
||--        {self.model.v-ruler-spec.insert first, count, self.default-row-height}
||--    }

    || Now update the individual grids
    {if-non-null g = self.top-left-grid then
        {g.insert-rows first, count}
    }
    {if-non-null g = self.top-grid then
        {g.insert-rows first, count}
    }
    {if-non-null g = self.left-grid then
        {g.insert-rows first, count}
    }
    {if-non-null g = self.main-grid then
        {g.insert-rows first, count}
    }
    
||--    || If deleting, update the model and rulers last
||--    {if false and count < 0 then
||--        {self.model.insert-rows first, count}
||--        {self.model.v-ruler-spec.insert first, count, self.default-row-height}
||--    }

    {self.check-invariants}
    {self.update}
  }

  {doc-next
    {purpose Insert or delete columns in the worksheet.}
    {details
        Insert {param count} empty columns at the column indicated by
        {param first}, pushing existing columns right to make room. If
        count is negative, columns are removed.
    }
    {parameter first, The position where columns will be added or
        deleted. The value must range between 0 and the number of
        columns currently in the grid, or {docref ArrayBoundsException}
        will be thrown.
    }
    {parameter count, If positive, the number of columns to be
        added. If negative, the number of columns to be removed.
    }
  }
  {method public open {insert-cols first:int, count:int}:void
    {if count == 0 then
        {return}
    }
    def cols = self.model.cols
    def rows = self.model.rows

    || If adding, update the model and rulers first
    {if count > 0 then
        {self.model.insert-cols first, count}
        {self.model.h-ruler-spec.insert first, count, self.default-column-width}
    }

    {if-non-null g = self.top-left-grid then
        {g.insert-cols first, count}
    }
    {if-non-null g = self.top-grid then
        {g.insert-cols first, count}
    }
    {if-non-null g = self.left-grid then
        {g.insert-cols first, count}
    }
    {if-non-null g = self.main-grid then
        {g.insert-cols first, count}
    }

    || If deleting, update the model and rulers last
    {if count < 0 then
        {self.model.insert-cols first, count}
        {self.model.h-ruler-spec.insert first, count, self.default-column-width}
    }

    {self.update}
  }

  {doc-next
    {purpose
        Set the expanded state of the group at ({param row}, {param col})
        to {param expanded?}.
    }
    {parameter gs, The {docref GroupSpec} at the specified {param row} and
        {param col}.
    }
    {parameter expanded?, The desired new state of the group.}
  }
  {method public open {set-group-expanded
                          row:int, col:int,
                          gs:GroupSpec,
                          expanded?:bool
                      }:void
    let first:int = gs.first
    let last:int = gs.last
    let count:int = 0
    {if last - first < 1 or gs.expanded? == expanded? then
        || Singleton group doesn't toggle; or already in correct state
        {return}
    }

    || Capture the map before and after the change
    def prev-map =
        {if gs.row? then
            {{self.model.row-tree.get-position-map self.model.rows}.clone}
         else
            {{self.model.col-tree.get-position-map self.model.cols}.clone}
        }

    || Set the group to the new state and capture the new map
    set gs.expanded? = expanded?
    def map =
        {if gs.row? then
            {{self.model.row-tree.get-position-map self.model.rows}.clone}
         else
            {{self.model.col-tree.get-position-map self.model.cols}.clone}
        }

    || If collapsing, need to fix up the grid before toggling the state
    {if not expanded? then
        set gs.expanded? = not expanded?
        || if active cell is about to be hidden, commit it
        {if self.active-row > first and self.active-row <= last then
            {if-non-null gc = {self.get-grid-cell self.active-row, self.active-col}
             then
                {gc.activate-cell false}
            }
            {self.select-nothing}
        }
    }

||--    def cv = self.model.vals[row, col]
||--    {if gs.row? then
||--        set first = {self.model.row-tree.map-index-to-position first}
||--        set last = {self.model.row-tree.map-index-to-position last}
||--||--        {if expanded? then
||--||--            set cv.rowspan = last - first + 1
||--||--         else
||--||--            set cv.rowspan = 1
||--||--        }
||--     else
||--        set first = {self.model.col-tree.map-index-to-position first}
||--        set last = {self.model.col-tree.map-index-to-position last}
||--        {if expanded? then
||--            set cv.colspan = last - first + 1
||--         else
||--            set cv.colspan = 1
||--        }
||--    }
||--    set first = gs.first + 1
||--    set last = gs.last
||--    let count:int = last - first + 1
||--    {assert count >= 0}
||--    {if not expanded? then
||--        set count = -count
||--    }

    set first = -1
    set last = -1
    set count = 0
    {for i = 0 below map.size do
        {if map[i] == prev-map[i] then
            {continue}
         elseif map[i] >= 0 and prev-map[i] >= 0 then
            {continue}
        }
        {if first < 0 then
            set first = i
        }
        {if map[i] < 0 then
            {dec count}
         elseif prev-map[i] < 0 then
            {inc count}
        }
    }

    {if gs.row? then
        {if-non-null g = self.top-left-grid then
            {g.reveal-rows first, count}
        }
        {if-non-null g = self.top-grid then
            {g.reveal-rows first, count}
        }
        {if-non-null g = self.left-grid then
            {g.reveal-rows first, count}
        }
        {if-non-null g = self.main-grid then
            {g.reveal-rows first, count}
        }
     else
        {if-non-null g = self.top-left-grid then
            {g.reveal-cols first, count}
        }
        {if-non-null g = self.top-grid then
            {g.reveal-cols first, count}
        }
        {if-non-null g = self.left-grid then
            {g.reveal-cols first, count}
        }
        {if-non-null g = self.main-grid then
            {g.reveal-cols first, count}
        }
    }
    {if not expanded? then
        set gs.expanded? = expanded?
    }
    {self.model.note-cell-changed row, col}
||--    {self.adjust-row-spans row, col, first, count}
    {self.update}
  }

||--  {method private {adjust-row-spans row:int, col:int, first:int, count:int}:void
||--    def last = first + {abs count} - 1
||--    ||FIXME: start at first row that might need to be adjusted, not 0
||--    {for ri = 0 below self.model.rows do
||--        {for ci = 0 below self.model.cols do
||--            def cv = self.model.vals[ri, ci]
||--            {if cv.rowspan > 1 then
||--                {if ri + cv.rowspan >= first
||--                    and not (ri == row and ci == col)
||--                 then
||--                    set cv.rowspan = {max 1, cv.rowspan + count}
||--                    {if-non-null gc = {self.get-grid-cell ri, ci} then
||--                        {self.attach-cell gc}
||--                    }
||--                }
||--            }
||--        }
||--    }
||--  }
        

||--  ||FIXME: keep this?
||--  || Add more things just the way you would in the constructor
||--  {method public open {add-items
||--                          ...
||--                      }:void
||--    {for (arg,k) in ... do
||--        {if-non-null k then
||--            {self.keyword-init-arg k, arg}
||--         else
||--            {self.non-keyword-init-arg arg}
||--        }
||--    }
||--  }

  {doc-next
    {purpose
        Specify the contents of a cell based on the value {param v} and its
        type.
    }
  }
  || Should this be a factory on CellSpec?
  {method public open {make-cell-spec
                          v:any,
                          rowspan:int = self.insert-rowspan,
                          colspan:int = self.insert-colspan
                      }:CellSpec

    let spec:#CellSpec = null
    let editable?:bool = false
    let locked?:bool = true

    || Look for ui generating procs first, and complain if invalid
    {if {proc? v} then
        let ui-spec:any =
            {type-switch v
             case gcep:GridCellEditorProc do
                set editable? = true
                gcep
             case fep:FieldEditorProc do
                set editable? = true
                fep
             case vcp:ValueControlProc do
                set editable? = true
                vcp
             case gcp:GridCellProc do
                gcp
             case fp:FieldProc do
                fp
             case vp:VisualProc do
                vp
             else
                {error
                    {hlmessage
                        Unrecognized proc argument. See CellSpec.ui-spec.
                    }
                }
            }
        {if-non-null ui-spec then
            set spec =
                {ValueCell
                    null,
                    rowspan = rowspan,
                    colspan = colspan,
                    editable? = editable?,
                    locked? = locked?,
                    ui-spec = ui-spec
                }
         else
            {error {hlmessage Internal error}}
        }
    }
    
    {if spec == null then
        set spec =
            {type-switch v
             case cs:CellSpec do
                cs

             case vc:ValueControl do
                {ValueCell
                    vc.value-as-any,
                    editable? = true,
                    locked? = true,
                    rowspan = rowspan,
                    colspan = colspan,
                    ui-spec = vc
                }

             case erg:EmbeddedRecordGrid do
                {ValueCell
                    null,
                    editable? = false,
                    locked? = true,
                    rowspan = rowspan,
                    colspan = colspan,
                    ui-spec = erg
                }

             case rref:RelativeCellRef do
                ||FIXME: Not needed if rref.resolve does the right thing
                def ref = {self.model.get-ref
                              row = self.insert-row + rref.row-offset,
                              col = self.insert-col + rref.col-offset
                          }
                {FormulaSpec
                    Formula.copy,
                    ref.domain,
                    rowspan = rowspan,
                    colspan = colspan,
                    ref
                }

             case ref:DataRef do
                {FormulaSpec
                    Formula.copy,
                    ref.domain,
                    rowspan = rowspan,
                    colspan = colspan,
                    ref
                }

             case v:Visual do
                {ValueCell
                    v,
                    editable? = false,
                    locked? = true,
                    rowspan = rowspan,
                    colspan = colspan,
                    ui-spec = null
                }

             else
                {value-cell
                    v,
                    rowspan = rowspan,
                    colspan = colspan
                }
            }
    }

    set spec.rowspan = {max spec.rowspan, rowspan}
    set spec.colspan = {max spec.colspan, colspan}
    {return {non-null spec}}
  }

  || All arguments must be stored in the CellValue to ensure that the
  || UI can be properly rebuilt from a serialized version, etc.
  {doc-next
    {purpose Initialize a cell in the {docref Worksheet}.}
    {parameter spec, Specifies the initial contents of the cell.}
    {parameter row, The row of the cell. The default value means to use
        the current {docref-abbr Worksheet.insert-row}.
    }
    {parameter col, The column of the cell. The default value means to use
        the current {docref-abbr Worksheet.insert-col}.
    }
    {parameter rowspan, The number of rows to be occupied by the cell.}
    {parameter colspan, The number of columns to be occupied by the cell.}
    {parameter erf, The {docref EmbeddedRecordForm} that the cell belongs
        to, if any.
    }
  }
  {method public open {init-cell
                          spec:CellSpec,
                          row:int = -1,
                          col:int = -1,
                          rowspan:int = 1,
                          colspan:int = 1,
                          erf:#EmbeddedRecordForm = null
                      }:CellValue

    {if row == -1 then
        set row = self.insert-row
    }
    set rowspan = {max rowspan, spec.rowspan}
    {if col == -1 then
        set col = self.insert-col
    }
    set colspan = {max colspan, spec.colspan}
    {if row + rowspan > self.model.rows then
        {error
            {hlformat
                "Item at row %1!s! with rowspan=%2!s! exceeds model size",
                row, rowspan
            }
        }
    }
    {if col + colspan > self.model.cols then
        {error
            {hlformat
                "Item at column %1!s! with colspan=%2!s! exceeds model size",
                col, colspan
            }
        }
    }

    def cv = self.model.vals[row, col]
    set cv.value = spec.value
    set cv.spec = spec
    set cv.editing? = false
    set cv.rowspan = rowspan
    set cv.colspan = colspan
    set cv.embedded-form = erf

    || Just do some fixups and error checks here. ui-spec is primarily for
    || the GridCell.
    {type-switch spec.ui-spec

     case vc:ValueControl do
        {if not spec.editable? then
            || Will use the ValueControl for display only
            set cv.editing? = false
        }

     case erg:EmbeddedRecordGrid do
        set erg.worksheet = self

     case erf:EmbeddedRecordForm do
        || This case is handled by Worksheet.non-keyword-init-arg
        {error {hlmessage Unexpected EmbeddedRecordForm}}

     case ctl:Control do
        {assert spec.locked?}

     case t:ClassType do
        {if {t.get-instance-maker "default"} == null then ||""
            {error {hlformat "No default constructor for %1!s!", t}}
        }

     case v:Visual do
        {assert spec.locked?}
        set cv.editing? = v isa ActiveTraversor and spec.editable?
    }

    {type-switch spec
     case fs:FieldSpec do
        {if erf == null then
            {error
                {hlmessage
                    FieldSpec must be contained within an EmbeddedRecordForm.
                }
            }
        }
        set fs.domain = erf.record-source.fields[fs.field-name].domain
        set fs.value = null

     case fs:FormulaSpec do
        {self.model.make-formula-at
            row, col,
            fs.formula,
            fs.domain,
            {splice fs.refs}
        }
        set cv.value = null

     case vc:ValueCell do

     case cs:CellSpec do

    }
    {return cv}
  }

  {doc-next
    {purpose Get the value of the cell at ({param row}, {param col}).}
  }
  {method public open {get-value row:int, col:int}:any
    def val = {self.model.get-value row, col}
||--    {dump "get-value", row, col, val}
    {return val}
  }


  {doc-next
    {purpose
        Set the value of the cell at ({param row}, {param col})
        to {param val}.
    }
  }
  {method public open {set-value row:int, col:int, val:any}:void
    def cv = self.model.vals[row, col]
    let nv:any = {cv.domain-value val}
    {if nv != cv.value then
        || Use model.set-value so a recalc will be scheduled
        {self.model.set-value row, col, nv}
    }
  }


  ||FIXME: optional-resizers
||--  {method public open {refresh-resizers}:void
||--    {if-non-null g = self.top-left-grid then
||--        set g.resizable-rows?  = self.resizable-rows?
||--        set g.resizable-cols?  = self.resizable-cols?
||--    }
||--    {if-non-null g = self.top-grid then
||--        set g.resizable-cols?  = self.resizable-cols?
||--    }
||--    {if-non-null g = self.left-grid then
||--        set g.resizable-rows?  = self.resizable-rows?
||--    }
||--  }

  || ensure that self.top-left-grid is a WorksheetGrid of the correct size
  {method private {refresh-top-left}:void
    def rows:int = self.visible-frozen-rows
    def cols:int = self.visible-frozen-cols

    {if self.top-left-grid == null then
        set self.top-left-grid =
            {WorksheetGrid
                self,
                rows, cols,
                name = "top-left-grid",
                self.h-ruler-left,
                self.v-ruler-top,
                h-resize? = true, v-resize? = true
            }
        {self.top-left-frame.add replace? = true, self.top-left-grid}
    }
    {if-non-null tlg = self.top-left-grid then
        {assert tlg.rows == rows}
        {assert tlg.cols == cols}
        {tlg.refresh}
    }
  }

  || Build the grid at the left containing frozen column cells
  || Strategy is to clear and rebuild if frozen-cols changes
  {method private {refresh-left}:void
    let rows:int = self.visible-scrolling-rows
    def cols = self.visible-frozen-cols

    {if self.left-grid == null then
        set self.left-grid =
            {WorksheetGrid 
                self,
                rows, cols,
                name = "left-grid",
                self.h-ruler-left,
                self.v-ruler-main,
                h-resize? = false,
                v-resize? = true
            }
        {self.left-frame.add replace? = true, self.left-grid}
    }
    {if-non-null left-grid = self.left-grid then
        {left-grid.refresh}
    }
  }

  {method private {refresh-top}:void
    def rows = self.visible-frozen-rows
    let cols:int = self.visible-scrolling-cols

    {if self.top-grid == null then
        set self.top-grid =
            {WorksheetGrid
                self,
                rows, cols,
                name = "top-grid",
                self.h-ruler-main,
                self.v-ruler-top,
                h-resize? = true, v-resize? = false
            }
        {self.top-frame.add replace? = true, self.top-grid}
    }
    {if-non-null top-grid = self.top-grid then
        {top-grid.refresh}
    }
  }

  {method private {refresh-main}:void
    def rows = self.visible-scrolling-rows
    def cols = self.visible-scrolling-cols

    {if self.main-grid == null then
        set self.main-grid =
            {WorksheetGrid
                self,
                rows, cols,
                name = "main-grid",
                self.h-ruler-main,
                self.v-ruler-main,
                h-resize? = false, v-resize? = false
            }
        {self.main-frame.add replace? = true, self.main-grid}
    }
    {if-non-null main-grid = self.main-grid then
        {main-grid.refresh}
    }
  }

  {doc-next
    {purpose Rebuild the cell grid.}
  }
  {method public open {rebuild-cell-grid}:void
    ||FIXME: clear grids, reset last-whatever to force a rebuild
    {self.refresh}
  }

  ||FIXME: Need to restart iteration if number of rows changes?
  {method protected open {init-embedded-forms}:void
    {for ri = 0 below self.model.rows do
        {if-non-null erf = self.model.embedded-forms[ri, 0] then
            def n = {erf.insert-embedded-form erf.base-row, erf.base-col}
        }
    }
  }

  || Override
  {method public open {refresh}:void
    def rows = self.model.rows
    def cols = self.model.cols
||--    {dump "Worksheet.refresh", rows, cols}

    || Figure out which cells are covered due to rowspan/colspan
    ||FIXME: do this in the model and incrementally
    {self.model.update-covered}

    {if self.last-row-edit-count != self.model.row-tree.edit-count
        or self.last-col-edit-count != self.model.col-tree.edit-count
        or self.frozen-cols != self.last-frozen-cols
        or self.frozen-rows != self.last-frozen-rows
||--        or self._refresh-requested?
     then
        def refresh-forms? = self.main-grid == null
        {self.refresh-rulers}
        {self.refresh-top-left}
        {self.refresh-top}
        {self.refresh-left}
        {self.refresh-main}
        {if refresh-forms? then
            {self.init-embedded-forms}
        }

        set self.last-row-edit-count = self.model.row-tree.edit-count
        set self.last-col-edit-count = self.model.col-tree.edit-count
        set self.last-frozen-rows = self.visible-frozen-rows + 1
        set self.last-frozen-cols = self.visible-frozen-cols + 1
    }

    {self.top-left-grid.refresh-resizers}
    {self.top-grid.refresh-resizers}
    {self.left-grid.refresh-resizers}
    {self.main-grid.refresh-resizers}
  }

  {doc-next
    {purpose
        Attach a cell in the proper quadrant of the {docref Worksheet}.
    }
  }
  {method public open {attach-cell
                          gc:GridCell
                      }:void
    def row = gc.row
    def col = gc.col
    def cv = self.model.vals[row, col]

||--    let gs:#GroupSpec = {self.model.row-tree.get-group col, row, row}
||--    {if gs == null then
||--        set gs = {self.model.col-tree.get-group row, col, col}
||--    }
||--    {if-non-null gs then
||--        {if gs.expanded? then
||--            {if gs.row? and gs.first == row then
||--                set cv.rowspan = gs.span
||--             elseif not gs.row? and gs.first == col then
||--                set cv.colspan = gs.span
||--            }
||--         else
||--            {if gs.row? then
||--                set cv.rowspan = 1
||--             else
||--                set cv.colspan = 1
||--            }
||--        }
||--    }

    def (grid, rpos, cpos) = {self.get-grid-coordinates row, col}
||--    ||FIXME: Should omit covered cells?
||--    {if cv.rowspan > 1 then
||--        {dump "attach-cell", row, col, gc.rowspan, self.name}
||--    }
    {if|| true or 
        not cv.covered?
     then
        {if rpos >= 0 and cpos >= 0 then
            {grid.add-cell
                rpos, cpos, gc,
                rowspan = gc.rowspan, colspan = gc.colspan
            }
        }
    }
  }

  {doc-next
    {purpose
        Determine which quadrant contains the cell at the specified
        row and column. Return it if it exists.
    }
  }
  {method public open {get-grid-cell
                          row:int, col:int
                      }:#GridCell
    {if self.main-grid == null then
        {return null}
    }
    def (g, gr, gc) = {self.get-grid-coordinates row, col}
    {return
        {if gr < 0 then
            null
         else
            g.cells[gr, gc] asa #GridCell
        }
    }
  }

||--  {getter public open {header-width}:Distance
||--    def margin = {self.any-to-Distance self.cell-margin}
||--    {return {min margin, 4pt}}
||--  }

  field private zero-width-notifier:SizeNotifier = {SizeNotifier false}

  {doc-next
    {purpose
        Return the {docref SizeNotifier} at the top of the specified
        column.
    }
  }
  {method public open {get-width-notifier
                          col:int
                      }:SizeNotifier
    def (g, gr, gc) = {self.get-grid-coordinates 0, col}
    {if gr < 0 then
        {return self.zero-width-notifier}
     else
        {return {non-null {g.h-ruler.get-notifier col}}}
    }
  }

  {doc-next
    {purpose
        Determine which quadrant contains the cell at the specified
        row and column. That {docref WorksheetGrid} and the position
        of the cell within it.
    }
  }
  {method public open {get-grid-coordinates
                          row:int, col:int
                      }:(grid:WorksheetGrid, rpos:int, cpos:int)
    def left? = {self.h-ruler-left.includes? col}
    def top? = {self.v-ruler-top.includes? row}
    def grid =
        {if left? then
            {if top? then
                self.top-left-grid
             else
                self.left-grid
            }
         else
            {if top? then
                self.top-grid
             else
                self.main-grid
            }
        }
    def rpos = {grid.v-ruler.get-position row}
    def cpos = {grid.h-ruler.get-position col}
    {return ({non-null grid}, rpos, cpos)}
  }


  {doc-next
    {purpose
        Called during construction to initialize the model.
    }
  }
  {method protected open {init-model model:WorksheetModel}:void
    set self.model = model
    set self.model? = true

||--    set self.cells = {new {ResizableArray-of GridCell},
||--                         self.model.rows, self.model.cols
||--                     }
  }

||--  {method protected open {make-col-header ci:int}:Frame
||--    ||FIXME: give it a style-element
||--    def sn = {Frame style-class = "col-header",
||--                 width = {make-elastic},
||--                 height = {make-elastic}
||--             }
||--    set sn.halign = "center"
||--    set sn.margin = self._cell-margin
||--    {sn.add replace? = true, {bold {format "%c", 'A' + ci}}}
||--    {return sn}
||--  }
||--
||--  {method protected open {make-row-header ri:int}:Frame
||--    let label:Visual = {bold {format "%s", ri + 1}}
||--    def sn = {Frame style-class = "row-header",
||--                 width = {make-elastic},
||--                 height = {make-elastic}
||--             }
||--    set sn.halign = "center"
||--    set sn.valign = "center"
||--    set sn.margin = self._cell-margin
||--    {sn.add label}
||--    {return sn}
||--  }

  {method private {check-cell-parms
                          row:int, row-count:int,
                          col:int, col-count:int
                      }:void
    {if row >= self.model.rows then
        {error {hlmessage Can't insert row beyond bottom edge}}
    }
    {if col >= self.model.cols then
        {error {hlmessage Can't insert colomn beyond right edge}}
    }
    {if row < 0 then
        {error {hlmessage Row index must be zero or more.}}
    }
    {if col < 0 then
        {error {hlmessage Column index must be zero or more.}}
    }
  }

  {doc-next
    {purpose
        Find an embedded form for {param rsds} and insert or delete
        rows to show the proper records.
    }
    {details
        Starting at {param first-row}, find an embedded form with
        {param rsds} as its data source. If rows were deleted since
        the last time it was refreshed, remove the extra cells from
        the worksheet. If rows were added to the data source, add
        rows in the cell array.
    }
    {return-vals
        Return the number of rows added or deleted. If the result is
        nonzero, the caller will start scanning again from the top
        because rows will have been renumbered.
    }
  }
  {method protected open {adjust-embedded-forms
                             rsds:RecordSetDataSource,
                             first-row:int
                         }:int
    let next-row:int = -1
    let rows:int = self.model.rows
    {for ri = first-row below self.model.rows do
        {for ci = 0 below self.model.cols do
            def cv = self.model.vals[ri, ci]
            {if-non-null erf = {self.model.get-embedded-form ri, ci} then
                {if erf.data-source == rsds then
                    {erf.insert-embedded-form ri, ci}
                    {if self.model.rows < rows then
                        set next-row = ri + 1
                     else
                        set rows = self.model.rows
                    }
                }
            }
||FIXME: is this really needed?
||--            {if-non-null fs = cv.field-spec then
||--                {if-non-null gc = {self.get-grid-cell ri, ci} then
||--                    {gc.refresh-value fs}
||--                    set gc.value = null
||--                }
||--            }
        }
        {if next-row >= 0 then
            {break}
        }
    }
    {return next-row}
  }

  {method protected open {handle-observer-message
                             sender:Observable,
                             message:any
                         }:void
||--    {dump sender, message, self}
    ||FIXME: need an interface to support this cleanly
    {super.handle-observer-message sender, message}
    {type-switch sender
     case rsds:RecordSetDataSource do
        let first-row:int = 0
        {while first-row >= 0 do
            set first-row = {self.adjust-embedded-forms rsds, first-row}
        }
    }
    {self.update}
  }


  {doc-next
    {purpose
        Request that the cell at the specified row and column become
        active when the worksheet is refreshed.
    }
  }
  {method public open {set-active row:int, col:int}:void
||--    {dump "set-active", row, col}
    {if self.active-row != row or self.active-col != col then
        set self.active-row = row
        set self.active-col = col
    }
  }

  {method private {traversable? cv:CellValue}:bool
    {if-non-null v = cv.value then
        {type-switch v
         case at:ActiveTraversor do
            {return at.takes-focus?}
         case v:Visual do
            {return false}
        }
    }
    {return cv.editable?}
  }

  {doc-next
    {purpose
        Find the next editable cell relative to the current active cell
        and request that it become active.
    }
  }
  {method public open {find-next-active forward?:bool = true}:(row:int, col:int)
    {if forward? then
||--        {dump forward?, self.active-row, self.active-col}
        let first-col:int = self.active-col + 1
        || Look for an editable cell after the current cell
        {for ri = self.active-row below self.model.rows do
            {for ci = first-col below self.model.cols do
                def cv = self.model.vals[ri, ci]
                {if {self.traversable? cv} then
                    {return (ri, ci)}
                }
            }
            set first-col = 0
        }

        || Not found yet. Wrap to the first cell and keep looking
        {for ri = 0 to self.active-row do
            {for ci = 0 below self.model.cols do
                {if ri == self.active-row and ci == self.active-col then
                    {break}
                }
                def cv = self.model.vals[ri, ci]
                {if {self.traversable? cv} then
                    {return (ri, ci)}
                }
            }
        }
     else
        || Iterate in reverse, with wraparound
        let first-row:int = self.active-row
        let first-col:int = self.active-col - 1
        {if self.active-col <= 0 then
            set first-col = self.model.cols - 1
            set first-row = self.active-row - 1
        }

        || Look for an editable cell before the current cell
        {for ri = first-row downto 0 do
            {for ci = first-col downto 0 do
                def cv = self.model.vals[ri, ci]
                {if {self.traversable? cv} then
                    {return (ri, ci)}
                }
            }
            set first-col = self.model.cols - 1
        }

        || Not found yet. Wrap to the last cell (lower right)
        {for ri = self.model.rows - 1 downto first-row do
            {for ci = self.model.cols - 1 downto 0 do
                {if ri == self.active-row and ci == self.active-col then
                    {break}
                }
                def cv = self.model.vals[ri, ci]
                {if {self.traversable? cv} then
                    {return (ri, ci)}
                }
            }
        }
    }
    {return (self.active-row, self.active-col)}
  }

  {doc-next
    {purpose
        Make the specified cell active or inactive, after committing
        any pending edit.
    }
  }
  {method public open {activate-cell
                          row:int,
                          col:int,
                          active?:bool = true
                      }:void
    {if row != self.active-row or col != self.active-col then
        {if-non-null gc = {self.get-grid-cell row, col} then
            {gc.activate-cell active?}
        }
    }
  }

  || Override
  {method public open {traverse forward?:bool = true}:bool
    def (row, col) = {self.find-next-active forward? = forward?}
    def gc = {self.get-grid-cell row, col}
||--    {dump "traverse", row, col, gc}
    {if row == self.active-row and col == self.active-col then
        || Nothing to traverse to
||--        {dump "already there"}
        {return false}
     else
        {if-non-null gc then
            {gc.activate-cell true}
        }
    }
    {return true}
  }

  || ---------------
  || Event Handling
  || ---------------


||--  {method public open {note-selection-context-activated}:void
||--  }

  {method private {init-pending-selection row:int, col:int}:void
    set self.anchor-row = row
    set self.anchor-col = col
    set self.point-row = row
    set self.point-col = col
  }

  ||NOTE: based on TextEditPanel
  {method public open {on-focus-in e:FocusIn}:void
    ||FIXME: not needed?
||--    {self.selection-context-request-activate}
    {super.on-focus-in e}
  }

  {method public open {on-focus-out e:FocusOut}:void
    || True loss of key focus indicates we should give up ASC as well. 
    || However, if just the FocusManager itself is losing focus do 
    || nothing; Focus will eventually return to this object. This is critical 
    || to allowing the browser's menus to refer to the ASC (lwexler 5/04)
    {if-non-null fm:FocusManager = {self.get-focus-manager} then
        {if fm.active-selection-context == self and
            fm.have-keyboard-focus?
         then
            set fm.active-selection-context = null
        }
    }
    
    {super.on-focus-out e}
  }

  {doc-next
    {purpose
        Determine if the point (x, y) should affect the selection.
    }
    {details
        If the object at the point (x, y) has no effect on the
        selection, return (-2, -2). If it should select all rows,
        return (-1, c), where r is the column number to be
        selected. If it should select all columns, return (r, -1),
        where r is the row to be selected. If it should select all
        cells, return (-1, -1). If exactly one cell is selected,
        return (r, c), the row and column numbers of that cell.
    }
  }
  {method public open {describe-point x:Distance, y:Distance}:(r:int, c:int)
    def discloser =
        {self.find-graphic-at x, y,
            {proc {g:Graphic}:bool
                {return (g isa Discloser)}
            }
        }
    {if discloser != null then
        {return (-2, -2)}
    }
    def g =
        {self.find-graphic-at x, y,
            {proc {g:Graphic}:bool
                {return
                    (g isa GridCell)
                    or (g isa Fill and
                        {g.style-class.find-string "bottom-spacer"} >= 0 ||""
                        or {g.style-class.find-string "right-spacer"} >= 0 ||""
                        or {g.style-class.find-string "top-left"} >= 0 ||""
                       )
                    or (g isa BaseRuler)
                    or (g isa Resizer)
                    or (g isa GridLineFill)
                }
            }
        }
||--    {dump "describe-point", g}
    {type-switch g
     case gc:GridCell do
        {return (gc.row, gc.col)}
     case vr:VerticalRuler do
        def (rx, ry) = {transform-coordinates x, y, self, vr}
        def row = {vr.index-for-point rx, ry}
        {return (row, -1)}
     case hr:HorizontalRuler do
        def (rx, ry) = {transform-coordinates x, y, self, hr}
        def col = {hr.index-for-point rx, ry}
        {return (-1, col)}
     case d:Discloser do
        {return (-2, -2)}
     case r:Resizer do
        {return (-2, -2)}
     case f:GridLineFill do
        {return (-2, -2)}
     case f:Fill do
        {return (-1, -1)}
     case n:Null do
        {return (-2, -2)}
    }
    {return (-1, -1)}
  }

  {method public open {on-pointer-envelope-event 
                          ev:PointerEnvelopeEvent
                      }:void
    
    {if ev.consumed? or ev.contents.consumed? or not self.enabled? then
        {super.on-pointer-envelope-event ev}
        {return}
    }
    
    def (ex, ey, view) =
        {self.transform-from-graphical-root-coordinates
            ev.contents.x, ev.contents.y
        }

    {type-switch ev.contents
     case pp:PointerPress do
||--        {dump pp, self.selecting?, self.shift?, "envelope"}
        {if-non-null fm:FocusManager = {self.get-focus-manager} then
            {if fm.active-selection-context != self then
                {self.selection-context-request-activate}
            }
        }
        def (row, col) = {self.describe-point ex, ey}
||--        {assert not self.selecting?}
        {if row >= -1 or col >= -1 then
            set self.selecting? = true
            set self.shift? = ev.state-mask.shift?
            {if pp.button == left-button and not self.shift? then
                {self.init-pending-selection row, col}
                {if row >= 0 and col >= 0 then
                    def cv = self.model.vals[row, col]
                    {if cv.editable? then
||--                        {dump cv.editable?, cv.locked?}
                        {self.activate-cell row, col}
                    }
||--                    {dump "PointerPress: clear selection"}
                    {self.reset-selection}
                }
             elseif pp.button == right-button then
                set self._context-row = row
                set self._context-column = col
                {ev.consume}
            }
        }
     case pr:PointerRelease do
||--        {dump pr, self.selecting?, self.shift?, "envelope"}
        || Only get here with click-and-release
        {if self.selecting? and pr.button == left-button then
            def (row, col) = {self.describe-point ex, ey}
            {if row >= -1 then
                let editing?:bool = false
                {if {self.active? row, col} then
                    def cv = self.model.vals[row, col]
                    set editing? = cv.editing?
                }
                {if not editing? then
                    {if ev.state-mask.shift? then
                        set self.anchor-row = row
                        set self.anchor-col = col
                     else
                        {self.init-pending-selection row, col}
                    }
                    {self.update-selection}
                    {ev.consume}
                }
            }
        }
        set self.selecting? = false

     case cme:ContextMenuEvent do
||--        {dump cme, self.selecting?, self.shift?, "envelope"}
        def (row, col) = {self.describe-point ex, ey}
        {if row != self._context-row or col != self._context-column then
||--            {dump "consuming a ContextMenuEvent envelope"}
            {ev.consume}
        }
    } 
    {super.on-pointer-envelope-event ev}
  }

  {method public open {on-pointer-press ev:PointerPress}:void
||--    {dump ev, self.selecting?, self.shift?}
    {if ev.consumed? or not self.enabled? or not self.selecting? then
        {super.on-pointer-press ev}
        {return}
    }
    set self.shift? = ev.state-mask.shift?
    {if not self.shift? then
        def (row, col) = {self.describe-point ev.x, ev.y}
        {if row >= -1 then
            set self.point-row =  row
            set self.point-col =  col
            {ev.consume}
        }
    }
    {super.on-pointer-press ev}
  }

  || For ContainerDragScroller

  {method public open {on-drag-started ev:DragStarted}:void
||--    {dump ev, self.selecting?, self.shift?}
    {if self.enabled? and
        not ev.consumed? and
        ev.state-mask.button-1?
     then
        {ev.consume}
        set self.shift? = ev.state-mask.shift?
        set self.selecting? = true
||--        {dump "start-dragscroll"}
        {self.start-dragscroll ev}
    }
    {super.on-drag-started ev}
  }

  {method public open {note-dragscroll-started x:Distance, y:Distance}:void
||--    {dump "note-ds-started", self.selecting?, self.shift?}
    {if self.selecting? and not self.shift? then
||--        {dump "reset-selection", self.selecting?}
        {self.reset-selection}
    }
    def (row, col) = {self.describe-point x, y}
    {if row >= -1 then
        set self.selecting? = true
        set self.anchor-row = row
        set self.anchor-col = col
    }
    {super.note-dragscroll-started x, y}
  }

  {method public open {note-dragscroll-continued  x:Distance, y:Distance}:void
||--    {dump "note-ds-cont", self.selecting?, self.shift?}
    def (row, col) = {self.describe-point x, y}
    {if row < -1 then
        || nothing?
     elseif self.point-row == -1 and self.point-col == -1 then
        || ignore because everything is already selected
     elseif self.point-col == -1 then
        || selecting entire rows
        set self.anchor-row = row
     elseif self.point-row == -1 then
        || selecting entire cols
        set self.anchor-col = col
     else
        set self.anchor-row = row
        set self.anchor-col = col
    }
    ||FIXME: ev.consume?
    {super.note-dragscroll-continued x, y}
    {self.update-selection}
  }

  {method public open {note-dragscroll-ended}:void   
||--    {dump "note-ds-ended", self.selecting?, self.shift?}
    {self.update-selection}
    set self.selecting? = false
    {super.note-dragscroll-ended}
  }

  || ----------
  || Overrides
  || ----------

  {method public open {create-command name:String}:#Command
    
    {return
        {switch name
         case "delete" do ||""
            {WorksheetDelete self}
         case "select-all" do ||""
            {WorksheetSelectAll self}
         case "copy" do ||""
            {WorksheetCopy self}
         case "paste" do ||""
            {WorksheetPaste self}
         case "Worksheet.insert" do ||""
            {WorksheetInsert self}
||--         case "grid-move-next" do ||""
||--            {WorksheetMoveNextCommand self}
||--         case "grid-move-previous" do ||""
||--            {WorksheetMovePreviousCommand self}
||--         case "grid-move-to" do ||""
||--            {WorksheetMoveToCommand self}
         else
            {super.SelectionContext.create-command name}
        }
    }
  }
  

  {method public open {insist-active at:#ActiveTraversor}:void
    {super.insist-active at}
    {type-switch at
     case erg:EmbeddedRecordGrid do
        {if-non-null cg = erg.grid-cell then
            {self.set-active cg.row, cg.col}
        }
    }
  }


||--  {method public open {get-range-as-selected-text
||--                          into:StringBuf,
||--                          start-bound:#GuiMark=null,
||--                          end-bound:#GuiMark=null
||--                      }:void
||--    let sel:GuiRangeSelection = {GuiRangeSelection}
||--    {sel.adjust-to self, {non-null start-bound}, {non-null end-bound}}
||--    let inside?:bool = false
||--    {if-non-null range = sel.range then
||--        {for ri = 0 below self.model.rows do
||--            {for ci = 0 below self.model.cols do
||--                def gc = self.model.cells[ri, ci]
||--                {if {range.intersects-graphic? gc} then
||--                    set inside? = true
||--                    {if-non-null editor = gc.editor then
||--                        def cv = self.model.vals[ri, ci]
||--                        {into.concat cv.formatted-value}
||--                     else
||--                        {gc.get-range-as-selected-text into}
||--                    }
||--                    {into.append '\t'}
||--                }
||--            }
||--            {if inside? then
||--                {into.append '\n'}
||--            }
||--            set inside? = false
||--        }
||--        {if into.size > 0 and into[into.size - 1] == '\n' then
||--            set into.size = into.size - 1
||--        }
||--    }
||--  }

  || SelectionContext
||--  {getter public abstract open {selection}:Selection}
||--  {method public abstract open {select-nothing}:void}  
||--  {method public open {overdraw-selection g:Graphic,  gc:Renderer2d}:void}


  {doc-next
    {purpose Return the current selection in the worksheet.}
  }
  {getter public open {selection}:WorksheetSelection
    {return self._selection}
  }  

  {getter public open {container}:Graphic
    {return self}
  }

  {doc-next
    {purpose Reset the selection but do not notify.}
  }
  {method protected open {reset-selection}:void
    set self._selection = {WorksheetSelection.empty self}
  }

  {doc-next
    {purpose
        Update the selection and fire a {docref SelectionChanged}
        event at self.
    }
  }
  {method protected open {update-selection}:void
    def nsel = {WorksheetSelection.from-corners
                   self,
                   self.anchor-row, self.anchor-col,
                   self.point-row, self.point-col
               }
    {if not {nsel.equal? self._selection} then
        set self._selection = nsel
||--        def new-selection =
||--            {format "%d,%d -> %d,%d (%d x %d)",
||--                nsel.first-row, nsel.first-column,
||--                nsel.row-anchor, nsel.column-anchor,
||--                nsel.model.rows, nsel.column-count
||--            }
||--        {dump new-selection}
        {self.handle-event {SelectionChanged}}
    }
  }


  {doc-next
    {purpose
        Update the selection to be empty and fire a {docref
        SelectionChanged} event at self.
    }
  }
  {method public open {select-nothing}:void
    {if not self._selection.empty? then
        set self._selection = {WorksheetSelection.empty self}
        {self.handle-event {SelectionChanged}}
    }
  }
  
  {doc-next
    {purpose
        Select all records, columns, and/or regions and fire a {docref
        SelectionChanged} event at self.
    }
  }
  {method public open {select-all}:void
    {if not self._selection.all-cells? then
        set self._selection = {WorksheetSelection.all self}
        {self.handle-event {SelectionChanged}}
    }
  }

  {doc-next 
    {purpose
        Delete the current selection.
    }
  }
  {method public open {delete-selection}:void
||--    {if not self.editable? then
||--        {error
||--            {hlmessage 
||--                Attempted to delete selection in non-editable RecordGrid.
||--            }
||--        }   
||--    }
    let selection:WorksheetSelection = self._selection
    ||FIXME: NYI delete-selection
  }
  
  {method public open {on-selection-changed sc:SelectionChanged}:void
    {self.update}
    {self.request-update-commands}
  }


  || Debugging
  {method private {check-invariants}:void
||--    {return}
    {for ri = 0 below {min 100, self.model.rows} do
        {for ci = 0 below self.model.cols do
            def cv = self.model.vals[ri, ci]
            {for erf in self.model.embedded-forms do
                {if-non-null erf then
                    {if erf.base-row == ri and erf.base-col == ci then
                        {if cv.embedded-form != null then
                            {assert cv.embedded-form == erf}
                        }
                    }
                }
            }
            def (g, grow, gcol) = {self.get-grid-coordinates ri, ci}
            {assert grow >= 0}
            def gc = g.cells[grow, gcol] asa #GridCell
            {if gc != null then
                {assert gc.row == ri}
                {assert gc.col == ci}
                {if ri >= self.frozen-rows then
                    {if ci >= self.frozen-cols then
                        {assert g == self.main-grid}
                    }
                }
             else
||--                {dump gc, ri, ci}
            }
        }
    }

  }
    
}

|| -------------------------------------------------------------------------

|| Embedded RecordGrid
|#
  - A SizeNotifier notifies listeners when the width option changes
  - The top of the Worksheet is a HorizontalRuler, which as a SizeNotifier for
    each column
  - An EmbeddedGridHeader will observe a SizeNotifier and change the width option
  - The header-spec on an embedded RecordGrid will create a EmbeddedGridHeader
    to contain the header text while tracking the column size.
#|

{doc-next
    {purpose 
        A {docref Frame} that observes a column header so that it can
        set the RecordGridColumn width to match.
    }
}
{define-class public open EmbeddedGridHeader {inherits Frame, Observer}

  {doc-next
    {purpose The column position of the header within the {docref Worksheet}}
  }
  field public-get protected-set pos:int

  {doc-next
    {purpose
        The {docref RecordGridColumn} from the {docref RecordGrid} associated
        with this header.
    }
  }
  field public-get protected-set rgc:RecordGridColumn

  {doc-next
    {purpose
        The {docref Worksheet} that this {ctext EmbeddedGridHeader} belongs to.
    }
  }
  field public-get protected-set worksheet:Worksheet

  {nonlocal-option public vertical-grid-line-width:any
    def notifier = {self.worksheet.get-width-notifier self.pos}
    {self.adjust-size notifier}
  }

  {doc-next
    {purpose Initialize this object.}
    {parameter worksheet, The {docref Worksheet} that this header is
        associated with.
    }
    {parameter rgc, The {docref RecordGridColumn} that this header
        belongs to.
    }
    {parameter pos, The column number where this column appears in the worksheet.}
    {parameter ..., Graphic options for this object.}
  }
  {constructor public {default
                          worksheet:Worksheet,
                          rgc:RecordGridColumn,
                          pos:int,
                          ...
                      }
    {construct-super.Observer}
    {construct-super.Frame _style-element = "EmbeddedGridHeader", {splice ...}}
    set self.worksheet = worksheet
    set self.rgc = rgc
    set self.pos = pos
    def notifier = {self.worksheet.get-width-notifier pos}
    {self.adjust-size notifier}
||--    {dump "EGH observing", notifier, self.pos}
    {notifier.add-observer self}
  }

  {method protected open {adjust-size notifier:SizeNotifier}:void
    def dx = {self.any-to-Distance self.vertical-grid-line-width}
    def w = {max 0m, notifier.cell-width - dx}
||--    {dump "adjust-size", self.pos, dx, w}
    set self.rgc.width = w
  }

  {method protected open {handle-observer-message
                        source:Observable, message:any
                    }:void
||--    {dump self, source, message}
    {type-switch source
     case sn:SizeNotifier do
        {if not sn.row? then
||--            {dump "observed", self.pos, sn.cell-width/1pt, sn.cell-height/1pt}
            {self.adjust-size sn}
        }
    }
  }
} 

{doc-next
    {purpose
        Subclass of RecordGrid that can be embedded in a {docref Worksheet}.
    }
}
{define-class public open EmbeddedRecordGrid {inherits RecordGrid}

  {doc-next
    {purpose
        The {docref Worksheet} that this {ctext EmbeddedRecordGrid} belongs to.
    }
  }
  field public-get protected-set worksheet:#Worksheet

  {doc-next
    {purpose
        The {docref GridCell} that contains this {docref EmbeddedRecordGrid}.
    }
  }
  field public-get protected-set grid-cell:#GridCell

  {doc-next
    {purpose Initialize this object.}
    {parameter worksheet, The {docref Worksheet} that this {ctext EmbeddedRecordGrid}
        is associated with.
    }
    {parameter record-source, Provides data to be displayed in this grid.
    }
    {parameter sort, Defines the sort order for the dispayed data.
    }
    {parameter filter, A filter to display only a subset of the data.
    }
    {parameter key-spec, Provides the initial value for {docref RecordGrid.key-spec}.
    }
    {parameter header-options, Graphic options for the header.
    }
    {parameter ui-object, An alternative UI object.
    }
    {parameter ..., Graphic options for this object.}
  }
  {constructor public {default
                          worksheet:#Worksheet = null,
                          record-source:#RecordSet = null,
                          sort:#RecordSort  = null,
                          filter:#RecordFilter = null,
                          key-spec:any = null,
                          header-options:RecordGridRowOptions =
                              {RecordGridRowOptions},
                          ui-object:#RecordGridUI =
                              {ProtoSkinnableRecordGridUI},
                          ...
                      }
    set self.worksheet = worksheet
    {construct-super
        record-source = record-source,
        sort = sort,
        filter = filter,
        key-spec = key-spec,
        header-options = header-options,
        ui-object = ui-object,

||--        halign = 1.0,
        display-record-selectors? = false,
        display-navigation-panel? = false,
        display-filler-column? = false,
        region-selection-enabled? = true,
        width = {add-stretch},
        height = {add-stretch},
        {splice ...},
||--        header-spec = {proc {rgc:RecordGridColumn}:Graphic
||--                          {return {self.make-header rgc}}
||--                      },
        display-column-headers? = true
    }

    ||HACK
    || Need to wait for the record grid columns to stabilize
||--    {after .25s do || .1s is too little
||--        {dump "+Add notifiers to RGC"}
||--        {if self.worksheet != null and self.worksheet.main-grid != null then
||--            set self.header-spec =
||--                {proc {rgc:RecordGridColumn}:Graphic
||--                    {return {self.make-header rgc}}
||--                }
||--         else
||--            set self.init-header? = true
||--        }
||--    }
  }

  field private init-header?:bool = true

  {method public open {set-size lc:LayoutContext, bounds:GRect}:void
||--    {dump "set-size", self, self.worksheet}
    def header-proc =
        {proc {rgc:RecordGridColumn}:Graphic
            {return {self.make-header rgc}}
        }

    {super.set-size lc, bounds}
    {if self.init-header? then
        {if self.worksheet != null and self.grid-cell != null then
            set self.header-spec = header-proc
            set self.init-header? = false
||--            {dump self, "... header created!"}
         else
||--            {dump self, "NO header"}
        }
    }
  }

  {method public open {make-header rgc:RecordGridColumn}:Graphic
||--    {dump "make-header", self}
    {if-non-null worksheet = self.worksheet then
||--        let pos:int = {self.record-source.fields.get-index rgc.field-name}
        let pos:int = {self.columns.find rgc}
        {if-non-null gc = self.grid-cell then
            {inc pos, gc.col}
         else
            set self.init-header? = true
||--            {dump "?? make-header: no gc", worksheet}
        }
        {return
            {EmbeddedGridHeader
                worksheet,
                rgc,
                pos,
                halign = "right",
                font-weight = "bold",
                font-size = 8pt,
                rgc.field.caption
            }
        }
     else
        {error 
            {hlmessage
                Attempt to use an EmbeddedRecordGrid before setting
                the 'worksheet' field.
            }
        }
    }
  }

  {method public open {test-record action:String, ...}:void
    {super.test-record action, ...}
||--    {dump action, {splice ...}}
  }

  {method public open {become-active forward?:bool=true}:bool
||--    {dump "become-active", self}
    {return {super.become-active forward? = forward?}}
  }

  {method public open {become-active-from-traversal forward?:bool=true}:bool
||--    {dump "become-active-from-traversal", self}
    {return {super.become-active-from-traversal forward? = forward?}}
  }

}

|| -------------------------------------------------------------------------

|| Kinds of cells
|| CellSpec - simple value
|| EditableCellSpec - editable value
|| FormulaSpec - formula
|| VisualCellSpec - a ui of some sort
|| FieldCellSpec - form field
|| EmbeddedFormSpec - an embedded form
|| EmbeddedGridSpec - an embedded ReecordGrid

|#

What is the ui-spec for?
  - special editor for the value (eg. Slider)
  - proc to generate editor
  - 
  - 

Use Cases
 - 1. Display, no edit (constant value or formula result)
      editable? = false  locked? = true
      o ui-spec = null => use Visual value or domain.format otherwise
      o ui-spec = proc => call the proc when value changes
      o ui-spec = anything else => treat as if null

 - 2. Edit when active using TextField + domain parse/format
      editable? = true locked? = false
      ui-spec = null

 - 3. Edit when active with specified editor
      editable? = true locked = false
      o ui-spec = null => case 2
      o ui-spec = proc => call proc when activated. If returns ValueControl,
        add ValueFinished handler
      o ui-spec = ClassType => Instantiate if ValueControl and add handler

 - 5. Always editing using default editor
      editable? = true, locked? = true
      ui-spec = null

 - 6. Always editing using specified editor
      editable? = true, locked? = true
      o ui-spec = proc => call proc when created. If returns ValueControl,
        add ValueFinished handler
      o ui-spec = ClassType => Instantiate if ValueControl and add handler

  value - current cell value. null, constant, calced, or formula
  ui-spec - null, Visual, ValueControl, proc:Visual, proc:ValueControl

Theory
  - value is displayed. ui-spec is for editing
  - If value is a

#|

{doc-next
    {purpose
        A procedure that will return a visual object to represent the
        value of the cell {param cv}.
    }
}
{def public VisualProc = {proc-type {cv:CellValue}:Visual}}

{doc-next
    {purpose
        A procedure that will return a visual object to represent the
        value of the cell {param cv}.
    }
}
{def public FieldProc = {proc-type {r:#Record, cv:CellValue}:Visual}}
||FIXME: the following is not yet documented in using-worksheet.curl

{doc-next
    {purpose
        A procedure that will create anda return a visual object to
        represent the value of the cell {param cv}.
    }
}
{def public GridCellProc = {proc-type {gc:GridCell}:Visual}}


{doc-next
    {purpose
        A procedure that will create and return a control to display
        and or edit value of the cell.
    }
    {details
        This type of procedure is useful in specifying the control
        to be used in a cell that represents an editable field in an
        {docref EmbeddedRecordForm}. A data binding will be created
        so that the cell value can be displayed and edited.
    }
}
{def public ValueControlProc = {proc-type {}:ValueControl}}

{doc-next
    {purpose
        A procedure that will return a control to display and edit
        a cell value.
    }
    {details
        This type of procedure is useful in specifying the control
        to be used in a cell that represents an editable field in an
        {docref EmbeddedRecordForm}. A data binding will be created
        so that the cell value can be displayed and edited.
    }
}
{def public FieldEditorProc = {proc-type {r:#Record, cv:CellValue}:ValueControl}}

||FIXME: the following is not yet documented in using-worksheet.curl
{def public GridCellEditorProc = {proc-type {gc:GridCell}:ValueControl}}


{doc-next
    {purpose Specifies the initial contents of a cell.}
}
{define-class public open CellSpec

  {doc-next
    {purpose The number of rows to be used to display the cell.}
  }
  field public rowspan:int

  {doc-next
    {purpose The number of columns to be used to display the cell.}
  }
  field public colspan:int

  {doc-next
    {purpose If true, the cell value can be edited.}
  }
  field public editable?:bool

  {doc-next
    {purpose If true, the cell will remain in it's current state at
        all times (editing or not editing).
    }
  }
  field public _locked?:bool

  {doc-next
    {purpose Spedifies the user interface for the cell, when editing.}
  }
  field public constant ui-spec:any

  {doc-next
    {purpose Option bindings to be applied to the cell container.}
  }
  field public constant options:#Arguments

  {doc-next
    {purpose Initialize the specification for a cell.}
    {parameter rowspan, The number of rows to be used to display the cell.}
    {parameter colspan, The number of columns to be used to display the cell.}
    {parameter editable?, If true, the cell will can be edited by the user.}
    {parameter locked?, If true, the cell will remain in it's current state at
        all times (editing or not editing).
    }
    {parameter ui-spec,Spedifies the user interface for the cell, when editing.}
    {parameter ..., Option settings}
  }
  {constructor public {default
                          rowspan:int,
                          colspan:int,
                          editable?:bool = false,
                          locked?:bool = false,
                          ui-spec:any = null,
                          ...
                      }
    set self.rowspan = rowspan
    set self.colspan = colspan
    set self.editable? = editable?
    set self._locked? = locked?
    set self.ui-spec = ui-spec
    set self.options = null

    let argc:int = 0
    {for (arg,k) in ... do
        {inc argc}
        {if-non-null k then
            || OK
         else
            {if arg == null then
                || ignore
             elseif arg isa Arguments and argc == 1 then
                set self.options = arg asa Arguments
             else
                {error 
                    {hlformat "Unexpected non-keyword argument: '%s'", arg}
                }
            }
        }
    }
    {if self.options == null and argc > 0 then
        set self.options = {Arguments ...}
    }
  }

  {doc-next
    {purpose Return an object that is a copy of {param spec}.}
  }
  {constructor public {clone-from spec:CellSpec}
    set self.rowspan = spec.rowspan
    set self.colspan = spec.colspan
    set self.options = spec.options
    set self.editable? = spec.editable?
    set self._locked? = spec._locked?

    set self.ui-spec = 
        {type-switch spec.ui-spec
         case v:Visual do
            {v.clone-appearance}
         else
            spec.ui-spec
        }
  }

  {doc-next
    {purpose The initial value of the cell.}
  }
  {getter public open {value}:any
    {return null}
  }

  {doc-next
    {purpose The domain for values of the cell.}
  }
  {getter public open {domain}:Domain
    {return DataSource.any-domain}
  }

  {doc-next
    {purpose If true the editing state of the cell will not change.}
  }
  {getter public open {locked?}:bool
    {return self._locked?}
  }
}

{doc-next
    {purpose
        An object that provides the initial value and other properties 
        for a cell.
    }
}
{define-class public open ValueCell {inherits CellSpec}

  {doc-next
    {purpose The initial value for the cell.}
  }
  field protected _value:any

  {doc-next
    {purpose The domain for values of a cell.}
  }
  field protected _domain:Domain

  || override
  {getter public open {locked?}:bool
    {return super.locked? or not self.editable?}
  }

  || override
  {getter public open {value}:any
    {return self._value}
  }
  {setter public open {value v:any}:void
    set self._value = v
  }
  
  || override
  {getter public open {domain}:Domain
    {return self._domain}
  }
  {setter public open {domain d:Domain}:void
    set self._domain = d
  }
  
  {doc-next
    {purpose Initialize the specification for a cell with a value.}
    {parameter value, The initial value for a cell.}
    {parameter domain, The domain for values of a cell.}
    {parameter editable?, If true, the cell will can be edited by the user.}
    {parameter locked?, If true, the cell will remain in it's current state at
    {parameter rowspan, The number of rows to be used to display the cell.}
    {parameter colspan, The number of columns to be used to display the cell.}
        all times (editing or not editing).
    }
    {parameter ui-spec,Spedifies the user interface for the cell, when editing.}
    {parameter ..., Option settings}
  }
  {constructor public {default
                          value:any,
                          domain:Domain = {DataSource.get-default-domain value},
                          editable?:bool = false,
                          locked?:bool = false,
                          rowspan:int = 1,
                          colspan:int = 1,
                          ui-spec:any = null,
                          ...
                      }
    {construct-super
        rowspan, colspan,
        ui-spec = ui-spec,
        editable? = editable?,
        locked? = locked?,
        {splice ...}
    }
    set self._value = value
    set self._domain = domain
  }

  {doc-next
    {purpose Return an object that is a copy of {param spec}.}
  }
  {constructor public {clone-from spec:ValueCell}
    {construct-super
        spec.rowspan,
        spec.colspan,
        spec.ui-spec,
        editable? = spec.editable?,
        locked? = spec.locked?,
        spec.options
    }
    set self._value = spec.value
    set self._domain = spec.domain
  }
}

{doc-next
    {purpose
        Used internally to store initial cell properties that
        were found in the rest args for an {docref EmbeddedRecordForm}.
    }
}
{define-class public open FormCell {inherits CellSpec}
  field public arg:any

  {doc-next
    {purpose Initialize the object.}
    {parameter arg, A positional argument from the {docref EmbeddedRecordForm}
        constructor.
    }
    {parameter rowspan, The number of rows to be occupied by the cell.}
    {parameter colspan, The number of columns to be occupied by the cell.}
    {parameter ..., Option bindings.}
  }
  {constructor public {default
                          arg:any,
                          rowspan:int = 1,
                          colspan:int = 1,
                          ...
                      }
    {type-switch arg
     case cs:CellSpec do
        {error
            {hlmessage 
                Use the CellSpec itself instead of creating a FormCell for it.
            }
        }
    }
    {construct-super
        rowspan, colspan,
        editable? = false,
        locked? = true,
        {splice ...}
    }
    set self.arg = arg
  }

  {doc-next
    {purpose Return an object that is a copy of {param spec}.}
  }
  {constructor public {clone-from spec:FormCell}
    {construct-super
        spec.rowspan,
        spec.colspan,
        spec.ui-spec,
        editable? = spec.editable?,
        locked? = spec.locked?,
        spec.options
    }
    set self.arg = spec.arg
  }
}


{doc-next
    {purpose
        Specifies the initial values for a cell that contains a formula.
    }
}
{define-class public open FormulaSpec {inherits ValueCell}

  {doc-next
    {purpose A procedure to calculate the cell value.}
  }
  field public-get protected-set formula:CalcProc

  {doc-next
    {purpose References to the input values used to compute the cell value.}
  }
  field public-get protected-set refs:{Array-of DataRef}

  {getter public open {locked?}:bool
    {return true}
  }

  {doc-next
    {purpose Initialize the specification for a cell that contains a formula.}
    {parameter formula, The formula to be placed in the cell.}
    {parameter domain, The domain for values of a cell.}
    {parameter rowspan, The number of rows to be used to display the cell.}
    {parameter colspan, The number of columns to be used to display the cell.}
    {parameter ui-spec,Spedifies the user interface for the cell, when editing.}
    {parameter ..., Option settings}
  }
  {constructor public {default
                          formula:CalcProc,
                          domain:Domain,
                          rowspan:int = 1,
                          colspan:int = 1,
                          ui-spec:any = null,
                          ...
                      }
    def refs = {new {Array-of DataRef}}
    def options = {Arguments}
    {for (a,k) in ... do
        {if-non-null k then
            {options.append a, keyword = k}
         else
            {type-switch a
                ||FIXME: worksheet is not known here. But we could define a
                || UnparsedStringRef that would get handled when options are
||--             case s:String do
||--                {refs.append {(self asa DataSource).get-ref s}}
             case cr:DataRef do
                {refs.append cr}
             else
                {error
                    {hlformat "Unexpected positional argument: '%s'", a}
                }
            }
        }
    }

    {construct-super
        null,
        domain = domain,
        editable? = false,
        locked? = true,
        rowspan = rowspan,
        colspan = colspan,
        ui-spec = ui-spec,
        options
    }

    set self.refs = refs
    set self.formula = formula
  }

  {doc-next
    {purpose Return an object that is a copy of {param spec}.}
  }
  {constructor public {clone-from spec:FormulaSpec}
    {construct-super
        spec.value,
        domain = spec.domain,
        editable? = spec.editable?,
        locked? = spec.locked?,
        rowspan = spec.rowspan,
        colspan = spec.colspan,
        ui-spec = spec.ui-spec,
        spec.options
    }

    set self.refs = spec.refs
    set self.formula = spec.formula
  }
}


{doc-next
    {purpose The specification for a cell that represents a field
        in an {docref EmbeddedRecordForm}.
    }
    {details
        This type of {docref CellSepc} can only be used in the constructor
        for an {docref EmbeddedRecordForm}.
    }
}
{define-class public open FieldSpec {inherits ValueCell}

  {doc-next
    {purpose The name of the field to be shown in the cell.}
  }
  field public constant field-name:String

  {doc-next
    {purpose Initialize the specification for a cell that represents a field
        in an embedded form.
    }
    {parameter field-name, The field name.}
    {parameter editable?, If true, the cell will can be edited by the user.}
    {parameter locked?, If true, the cell will remain in it's current state at
    {parameter rowspan, The number of rows to be used to display the cell.}
    {parameter colspan, The number of columns to be used to display the cell.}
        all times (editing or not editing).
    }
    {parameter ui-spec,Spedifies the user interface for the cell, when editing.}
    {parameter ..., Option settings}
  }
  {constructor public {default
                          field-name:String,
                          rowspan:int = 1,
                          colspan:int = 1,
                          editable?:bool = false,
                          locked?:bool = false,
                          ui-spec:any = null,
                          ...
                      }
    {construct-super
        null,
        rowspan = rowspan,
        colspan = colspan,
        editable? = editable?,
        locked? = locked?,
        ui-spec = ui-spec,
        {splice ...}
    }

    set self.field-name = field-name
  }

  {doc-next
    {purpose Return an object that is a copy of {param spec}.}
  }
  {constructor public {clone-from spec:FieldSpec}
    {construct-super
        null,
        domain = spec.domain,
        editable? = spec.editable?,
        locked? = spec.locked?,
        rowspan = spec.rowspan,
        colspan = spec.colspan,
        ui-spec = spec.ui-spec,
        spec.options
    }

    set self.field-name = spec.field-name
  }
}


{doc-next
    {purpose Specify a width for each column in a {docref Worksheet}.}
    {details
        The arguments are converted to the {docref Distance} type
        and used to set the initial width of the columns. If there
        are extra values, they are ignored. If there are fewer values
        than columns, the additional columns are assigned
        {docref Worksheet.default-column-width}.

        You can also specify the width of an individual row using
        the {ctext column-width} keyword argument in the {docref
        Worksheet.default} constructor.
    }
}
{define-proc public {widths ...}:RulerSpec
  {return {RulerSpec Orientation.horizontal, 0, ...}}
}

{doc-next
    {purpose Specify a height for each row in a {docref Worksheet}.}
    {details
        The arguments are converted to the {docref Distance} type
        and used to set the initial height of the rows. If there
        are extra values, they are ignored. If there are fewer values
        than rows, the additional rows are assigned
        {docref Worksheet.default-row-height}. 

        You can also specify the height of an individual row using
        the {ctext row-height} keyword argument in the {docref
        Worksheet.default} constructor.
    }
}
{define-proc public {heights ...}:RulerSpec
  {return {RulerSpec Orientation.vertical, 0, ...}}
}

|| Specify parameters to be used when g is added to the Worksheet The
|| rest args are evenutally applied to the GridCell

{doc-next
    {purpose
        Specify a {docref ValueCell} for a value that is not editable.
    }
    {details
        This procedure is used when constructing a new {docref
        Worksheet}. It is used to specify a cell that contains a
        constant value.
    }
    {parameter v, The value for the cell.}
    {parameter domain, The {docref Domain} for the cell value.}
    {parameter rowspan, The number of rows occupied by the cell.}
    {parameter colspan, The number of columns occupied by the cell.}
    {parameter ui-spec, Provides the value for {docref CellSpec.ui-spec}
        property.
    }
    {parameter ..., Option bindings to be placed on the {docref Frame} that contains
        the value.
    }
}
{define-proc public {value-cell
                        v:any,
                        domain:Domain = {DataSource.get-default-domain v},
                        rowspan:int = 1,
                        colspan:int = 1,
                        ui-spec:any = null,
                        ...
                    }:CellSpec
    def args = {Arguments ...}
    {if {number? v} then
        def (align, found?) = {args.get-keyword-argument-if-exists "halign"}
        {if not found? then
            {args.append "right", keyword = "halign"}
        }
    }
    {return
        {ValueCell
            v,
            domain = domain,
            rowspan = rowspan,
            colspan = colspan,
            editable? = false,
            locked? = true,
            ui-spec = ui-spec,
            {splice args}
        }
    }
}

{doc-next
    {purpose
        A cell that has no value but displays the {docref Grephic} specified
        by the {docref-abbr CellSpec.ui-spec} property.
    }
    {parameter rowspan, The number of rows occupied by the cell.}
    {parameter colspan, The number of columns occupied by the cell.}
    {parameter ui-spec, Provides the value for {docref CellSpec.ui-spec}
        property.
    }
    {parameter ui, An object to be displayed in the cell. This corresponds to the
        {docref CellSpec.ui-spec} property.
    }
    {parameter ..., Option bindings to be placed on the {docref Frame} that contains
        the {param ui-spec}.
    }
}
{define-proc public {display-cell
                        ui:any,
                        rowspan:int = 1,
                        colspan:int = 1,
                        ...
                    }:CellSpec
    {return
        {ValueCell
            null,
            rowspan = rowspan,
            colspan = colspan,
            editable? = false,
            locked? = true,
            ui-spec = ui,
            {splice ...}
        }
    }
}

{doc-next
    {purpose
        Specify a {docref ValueCell} for a value that can be edited.
    }
    {details
        This procedure is used when constructing a new {docref
        Worksheet}. It is used to specify a cell that contains a
        value that can be edited.

        An editor appears when the user clicks on the cell. By
        default, the editor will be a {docref TextField}. It will be
        a {docref DateField} if the value is a {docref DateTime}. You
        can use the {param ui-spec} to specify any other type of control.
    }
    {parameter v, The value for the cell.}
    {parameter domain, The {docref Domain} for the cell value.}
    {parameter rowspan, The number of rows occupied by the cell.}
    {parameter colspan, The number of columns occupied by the cell.}
    {parameter ui-spec, Provides the value for {docref CellSpec.ui-spec}
        property.
    }
    {parameter ..., Option bindings to be placed on the {docref Frame} that contains
        the value.
    }
}
{define-proc public {input-cell
                        v:any,
                        domain:Domain = {DataSource.get-default-domain v},
                        ui-spec:any = null,
                        rowspan:int = 1,
                        colspan:int = 1,
                        ...
                    }:CellSpec
    def args = {Arguments ...}
    {if {number? v} then
        def (align, found?) = {args.get-keyword-argument-if-exists "halign"}
        {if not found? then
            {args.append "right", keyword = "halign"}
        }
    }
    {return
        {ValueCell
            v,
            domain = domain,
            ui-spec = ui-spec,
            rowspan = rowspan,
            colspan = colspan,
            editable? = true,
            {splice args}
        }
    }
}

{doc-next
    {purpose
        Specify a cell that contains a currency value.
    }
    {details
        This procedure is used when constructing a new {docref
        Worksheet}. It is used to specify a cell that contains a
        currency value. The domain will be {docref
        DataSource.currency-domain}. The editor will be a {docref
        TextField}.

        Internally, the value is stored as the displayed value divided
        by 100. The working locale currency is used to display the
        value (divided by 100).
    }
    {parameter v, The value for the cell.}
    {parameter rowspan, The number of rows occupied by the cell.}
    {parameter colspan, The number of columns occupied by the cell.}
    {parameter ui-spec, Provides the value for {docref CellSpec.ui-spec}
        property.
    }
    {parameter ..., Option bindings to be placed on the {docref Frame} that contains
        the value.
    }
}
{define-proc public {currency-cell
                        v:any,
                        rowspan:int = 1,
                        colspan:int = 1,
                        editable?:bool = false,
                        ...
                    }:CellSpec
    {return
        {ValueCell
            v,
            domain = DataSource.currency-domain,
            editable? = editable?,
            rowspan = rowspan,
            colspan = colspan,
            halign = "right",
            {splice ...}
        }
    }
}

{doc-next
    {purpose
        Specify a {docref ValueCell} for a value that contains a formula.
    }
    {details
        This procedure is used when constructing a new {docref
        Worksheet}. It is used to specify a cell that contains a
        formula.

        When it is evaluated, the {param formula} is invoked as follows:
        {ctext {formula target, ...}} where {param target} is a reference
        to the current cell and ... are the positional arguments passed
        to this procedure.
    }
    {parameter formula, A procedure that calculates a value, (see
        {docref CalcProc}).
    }
    {parameter domain, The {docref Domain} for the cell value.}
    {parameter ui-spec, Provides the value for {docref CellSpec.ui-spec}
        property.
    }
    {parameter rowspan, The number of rows occupied by the cell.}
    {parameter colspan, The number of columns occupied by the cell.}
    {parameter ui-spec, Provides the value for {docref CellSpec.ui-spec}
        property.
    }
    {parameter ..., Positional arguments must be {docref DataRef}s and are passed
        to the formula as input arguments.

        Keyword arguments are option bindings to be placed on
        the {docref Frame} that contains the value.
    }
}
{define-proc public {formula-cell
                        formula:CalcProc,
                        domain:Domain = DataSource.double-domain,
                        ui-spec:any = null,
                        rowspan:int = 1,
                        colspan:int = 1,
                        ...
                    }:FormulaSpec
    {if not {proc? formula} then
        {error {hlmessage The first positional parameter must be
                   a formula procedure.
               }
        }
    }
    def args = {Arguments ...}
    {if {number? domain.default-value} then
        def (align, found?) = {args.get-keyword-argument-if-exists "halign"}
        {if not found? then
            {args.append "right", keyword = "halign"}
        }
    }
    {return
        {FormulaSpec
            formula,
            domain,
            rowspan = rowspan,
            colspan = colspan,
            ui-spec = ui-spec,
            {splice args}
        }
    }
}

{doc-next
    {purpose Specify a cell that displays the contents of some other cell.}
    {parameter ref, A reference to a value to be displayed in this cell.}
    {parameter ui-spec, Provides the value for {docref CellSpec.ui-spec}
        property.
    }
    {parameter rowspan, The number of rows occupied by the cell.}
    {parameter colspan, The number of columns occupied by the cell.}
    {parameter ..., Option bindings to be placed on the {docref Frame} that contains
        the value.
    }
}
{define-proc public {ref-cell
                        ref:DataRef,
                        ui-spec:any = null,
                        rowspan:int = 1,
                        colspan:int = 1,
                        ...
                    }:FormulaSpec
    def domain = ref.domain
    def args = {Arguments ...}
    {if {number? domain.default-value} then
        def (align, found?) = {args.get-keyword-argument-if-exists "halign"}
        {if not found? then
            {args.append "right", keyword = "halign"}
        }
    }
    {return
        {formula-cell
            Formula.copy,
            ref,
            domain = domain,
            rowspan = rowspan,
            colspan = colspan,
            ui-spec = ui-spec,
            {splice args}
        }
    }
}

{doc-next
    {purpose
        Define a group of two or more rows at the current cell.
    }
    {details
        When rows are grouped an expansion triangle is added at the
        left of the first row in the group. If expanded, all rows in
        the group are visible. If collapsed, only the first row is
        visible.

        Groups can be nested by defining another group consisting of
        rows that are within the span of the higher level group.
    }
    {parameter rows, The number of rows in the group.}
}
{define-proc public {row-group
                        rows:int
                    }:GroupProto
    {return
        {GroupProto true, rows}
    }
}

{doc-next
    {purpose
        Define a group of two or more columns at the current cell.
    }
    {details
        When columns are grouped an expansion triangle is added at the
        top of the leftmost column in the group. If expanded, all
        columns in the group are visible. If collapsed, only the first
        column is visible.

        Groups can be nested by defining another group consisting of
        columns that are within the span of the higher level group.
    }
    {parameter cols, The number of columns in the group.}
}
{define-proc public {col-group
                        cols:int
                    }:GroupProto
    {return
        {GroupProto false, cols}
    }
}


{doc-next
    {purpose
        Define a {docref RecordForm} that will be repeated in a
        {docref Worksheet} for each record in a {docref RecordSetDataSource}.
    }
}
{define-class public open EmbeddedRecordForm {inherits InitRestArgParser}

  {doc-next
    {purpose The row index of this {ctext EmbeddedRecordForm} in the model.}
  }
  field public base-row:int = -1

  {doc-next
    {purpose The column index of this {ctext EmbeddedRecordForm} in the model.}
  }
  field public base-col:int = -1

  {doc-next
    {purpose
        The {docref Worksheet} that this {ctext EmbeddedRecordForm} belongs to.
    }
  }
  field protected _worksheet:#Worksheet

  {doc-next
    {purpose
        A form will be created for each record in this {docref RecordSet}.
    }
  }
  field protected data-source:RecordSetDataSource

  {getter protected open {_record-source}:#RecordSet
    {return self.data-source.record-set}
  }

  {doc-next
    {purpose
        Return the {docref RecordSet} that is providing data
        for this {docref EmbeddedRecordForm}.
    }
  }
  {getter public open {record-source}:RecordSet
    {if-non-null src = self._record-source then
        {return src}
     else
        {return {EmptyRecordSet}}
    }
  }


  field protected id-field:String

  field protected items:{Array-2-of #CellSpec}

  ||FIXME: Only used during construction. Should be private?
  {doc-next
    {purpose
        The rest args are processed twice. The first time this is true
        and it counts the rows and columns in the form template.
    }
  }
  field protected _count-cells?:bool = false

  {doc-next
    {purpose The number of rows in the form template.}
  }
  field protected init-rows:int

  {doc-next
    {purpose The number of columns in the form template.}
  }
  field protected init-cols:int

  field protected insert-row:int
  field protected insert-col:int
  field protected insert-rowspan:int = 1
  field protected insert-colspan:int = 1

  field private _internal-view:RecordView

  field protected forms:{Array-of RecordForm}

  {doc-next
    {purpose The number of rows in the embedded form template.}
  }
  {getter public open {form-rows}:int
    def (rows, cols) = {self.items.size}
    {return rows}
  }

  {doc-next
    {purpose The number of columns in the embedded form template.}
  }
  {getter public open {form-cols}:int
    def (rows, cols) = {self.items.size}
    {return cols}
  }

||--  {getter public open {total-row-count}:int
||--    def (form-rows, form-cols) = {self.items.size}
||--    {return form-rows * self.forms.size}
||--
||--  }

  {doc-next
    {purpose Initialize this object.}
    {parameter data-source, Provides data to be displayed in this grid.
    }
    {parameter id-field, The field that is a unique id field for the dataset.
    }
    {parameter worksheet, The {docref Worksheet} that this {ctext EmbeddedRecordGrid}
        is associated with.
    }
    {parameter sort, Defines the sort order for the dispayed data.
    }
    {parameter filter, A filter to display only a subset of the data.
    }
    {parameter ..., Graphic options for this object.}
  }
  {constructor public {default
                          data-source:RecordSetDataSource,
                          id-field:String = "id",
                          worksheet:#Worksheet = null,
                          sort:#RecordSort = null,
                          filter:#RecordFilter = null,
                          ...
                      }
    set self.data-source = data-source
    set self.id-field = id-field
    {if-non-null worksheet then
        set self.worksheet = worksheet
    }
    {if-non-null record-source = self._record-source then
        {if record-source.load-state == RecordSetLoadState.unloaded 
         then
            {record-source.load}
        }
    }
    || Count the cells so we can allocate the items array
    {with self._count-cells? = true do
        {self.process-rest-args ...}
    }
    set self.items =
        {new {Array-2-of #CellSpec}, self.init-rows, self.init-cols}

    set self.forms = {new {Array-of RecordForm}}

    set self.insert-row = 0
    set self.insert-col = 0
    set self.insert-rowspan = 1
    set self.insert-colspan = 1
    {self.process-rest-args ...}
    set self._internal-view = 
        {RecordView
            self.record-source,
            sort = sort,
            filter = filter
        }
  }

  {method private {increment-insertion-pos spec:CellSpec}:void
    {inc self.insert-col, spec.colspan}
    {if-non-null worksheet = self.worksheet then
        {if self.insert-col >= self.worksheet.model.cols then
            set self.insert-col = 0
            {inc self.insert-row, spec.rowspan}
        }
    }
    set self.insert-rowspan = 1
    set self.insert-colspan = 1
  }

  {method protected open {keyword-init-arg key:String, value:any}:void
    {switch key
     case "row" do ||""
        set self.insert-row = value asa int
     case "col", "column" do ||""
        set self.insert-col = value asa int
     case "rowspan" do ||""
        set self.insert-rowspan = value asa int
     case "colspan" do ||""
        set self.insert-colspan = value asa int
     else
        {if self._count-cells? then
            || This will complain about any other keyword
            {super.keyword-init-arg key, value}
        }
    }
  }

  {method public open {non-keyword-init-arg a:any}:void
    def spec =
        {type-switch a

         case cs:CellSpec do
            cs

         case s:String do
            {FieldSpec
                s,
                rowspan = self.insert-rowspan,
                colspan = self.insert-colspan,
                embedded-form = self
            }

         else
            || Anything else will be converted to a CellSpec when the form
            || is expanded.
            {FormCell
                a,
                rowspan = self.insert-rowspan,
                colspan = self.insert-colspan
            }
        }

    {if self._count-cells? then
        || During initialization; need to count the rows and columns
        set self.init-rows = {max self.init-rows, self.insert-row + spec.rowspan}
        set self.init-cols = {max self.init-cols, self.insert-col + spec.colspan}
     else
        set self.items[self.insert-row, self.insert-col] = spec
    }
    {self.increment-insertion-pos spec}
  }

  {doc-next
    {purpose
        Return the {docref Worksheet} that contains this form,
        if there is one.
    }
  }
  {getter public open {worksheet}:#Worksheet
    {return self._worksheet}
  }

  {doc-next
    {purpose
        Specify the {docref Worksheet} that contains this form.
    }
    {details
        This {docref EmbeddedRecordForm} will attach itself as
        an observer of the worksheet and respond to updates.
    }
  }
  {setter public open {worksheet w:Worksheet}:void
    {if self._worksheet == null then
        set self._worksheet = w
        {self.worksheet.observe self.data-source}
     elseif self._worksheet != w then
        {error {hlmessage worksheet already set}}
    }
  }


  {doc-next
    {purpose 
        Records currently being displayed.
    }
    {details
        Represents the view of the data being actually shown.
        
        Modify this {docref RecordView}'s properties in order 
        to change the data being shown.
    }
  }
  {getter public open {records}:RecordView
    {return self._internal-view}
  }

  {doc-next
    {purpose Sort to be applied to the {ctext records}.}
    {details 
        The default implementation of this method simply 
        sets the property with the same name on the 
        {ctext records} collection.
    }
    {override Not typically overridden}
  }
  {getter public open {sort}:#RecordSort
    {return self.records.sort}
  }
  {setter public open {sort value:#RecordSort}:void
    set self.records.sort = value
  }
        

  {doc-next
    {purpose Filter to be applied to the {ctext records}.}
    {details 
        The default implementation of this method simply
        sets the property with the same name on 
        the {ctext records} collection.
    }
    {override Not typically overridden}
  }
  {getter public open {filter}:#RecordFilter
    {return self.records.filter}
  }
  {setter public open {filter value:#RecordFilter}:void
    set self.records.filter = value
  }

  {method private {clear-forms}:void
    def (form-rows, form-cols) = {self.items.size}
    {for rf:RecordForm key ri in self.forms do
        {for fri = 0 below form-rows do
            {for fci = 0 below form-cols do
                def frow = self.base-row + ri * form-rows + fri
                def fcol = self.base-col + fci
                {if-non-null spec = self.items[fri, fci] then
                    {self.worksheet.model.vals[frow, fcol].clear-form-cell}
                    {if-non-null gc = {self.worksheet.get-grid-cell frow, fcol}
                     then
                        {gc.clear}
                    }
                }
            }
        }
    }
    {self.forms.clear}
  }

  {method private {validate-forms}:bool
    let valid?:bool = true
    {for form in self.forms do
        {if form.current-record == null then
            set valid? = false
            {break}
        }
    }
    {return valid?}
  }

  {doc-next
    {purpose Embed a form in the worksheet.}
    {details
        Use the form template given by the {docref EmbeddedRecordForm}
        associated with the {docref CellValue} at the specified row
        and column to create a form for each record in the data source.
    }
  }
  {method public open {insert-embedded-form
                          row:int, col:int
                      }:int

    || Somewhat of a kludge. The Worksheet constructor syntax uses one
    || row to specify the EmbeddedRecordForm. So that is one less row
    || to insert.
    ||FIXME: add a method init-embedded-form to be called from constructor
    let rows-reserved:int = 0

    {if self.base-row == -1 then
        set self.base-row = row
        set self.base-col = col
        set rows-reserved = 1
     else
        {assert row == self.base-row and col == self.base-col}
    }
    def (form-rows,form-cols) = {self.items.size}
    def old-nrecs = self.forms.size
    def nrecs = self.records.size
    def nrows = (nrecs - old-nrecs) * form-rows

    || If the number of records is unchanged, data bindings should
    || ensure the form fields are correct, so can return immediately.
    {if old-nrecs == nrecs and {self.validate-forms} then
        {return nrecs}
    }

    {self.clear-forms}
    {if nrows > 0 then
        {self.worksheet.insert-rows
            row + old-nrecs + rows-reserved, nrows - rows-reserved
        }
     else
        def erf = {self.worksheet.model.get-embedded-form self.base-row, self.base-col}
        {assert erf == self}
        {self.worksheet.insert-rows
            row + rows-reserved, nrows - rows-reserved
        }
    }
    {if nrecs == 0 then
        {return 0}
    }

    {if nrecs != old-nrecs  then
        ||FIXME: adjust heights of newly inserted rows to match existing
        {if old-nrecs == 0 and rows-reserved == 0 then
            || Move the EmbeddedRecordForm back to it's original location
            def erf = self.worksheet.model.vals[row + nrows, col].embedded-form
            set self.worksheet.model.vals[row + nrows, col].embedded-form =
                self.worksheet.model.vals[row, col].embedded-form
            set self.worksheet.model.vals[row, col].embedded-form = erf
        }
    }

    {for r:Record key ri in self.records do
        def filter = {RecordData}
        set filter[self.id-field] = r[self.id-field] || this record only
        def form = {RecordForm
                       record-source = self.record-source,
                       filter = filter,
                       display-navigation-panel? = false
                   }
||--        {dump "-- Created new filter and form"} ||FIXME: can these be re-used?
        {form.request-current-record-change 0}
        {self.forms.append form}
        {for fri = 0 below form-rows do
            {for fci = 0 below form-cols do
                def frow = row + ri * form-rows + fri
                def fcol = col + fci
                {if-non-null spec = self.items[fri, fci] then
                    def gc = {self.worksheet.get-grid-cell frow, fcol}
                    {if-non-null gc then
                        set gc.data-binding-context = form
                     else
                        ||FIXME: this should never happen
||--                        {dump "?? no GridCell", frow, fcol}
                        {assert false}
                    }
                    def fspec = 
                        {type-switch spec
                         case fc:FormCell do
                            {self.worksheet.make-cell-spec
                                fc.arg,
                                rowspan = fc.rowspan,
                                colspan = fc.colspan
                            }
                         else
                            spec
                        }
                    def cv = {self.worksheet.init-cell
                                 fspec,
                                 row = frow,
                                 col = fcol,
                                 erf = self
                             }
                    || does this make sense?
                    {assert cv.locked? == (not spec.editable?)} || or else assign here
                }
||--                {if-non-null gc then
||--                    {gc.refresh}
||--                }
            }
        }
    }
    {return form-rows * self.records.size}
  }

  {doc-next
    {purpose
         If the cell at row {param ri} and column {param ci} is within an
         {docref EmbeddedRecordForm}, return the {docref RecordForm} 
         that is bound to the corresponding record.
    }
  }
  {method public open {get-RecordForm ri:int, ci:int}:#RecordForm
    let rf:#RecordForm = null
    def fri = ri - self.base-row      || Row index within the form
    let (nr:int, nc:int) = {self.items.size}
    def iri = fri mod nr  || 
    def rn = fri div nr
    {if rn >= 0 and rn < self.forms.size then
      {return self.forms[rn]}
    }
    {return null}
  }
}

|| ---------------------------------------------------------------------------

{doc-next
    {purpose 
        Selection returned by a {docref Worksheet}.
    }    
    {details
        NOTE: Applications should {italic not} attempt to make 
        changes or call modifying methods on this object.  In order
        to change the contents of this selection, call methods 
        directly on the related {docref RecordGrid} instead.  See 
        {docref Selection} for more information.
    }
}
{define-class public open WorksheetSelection
  {inherits Selection}


  {doc-next
    {purpose
        The {docref Worksheet} that this {ctext WorksheetSelection} belongs to.
    }
  }
  field public-get protected-set worksheet:Worksheet

  {doc-next
    {purpose
        Index of the first row in the selection.
    }
    {details
        If negative, it means all rows are selected. Use {docref-abbr
        WorksheetSelection.begin-row} if iterating over row indices in
        a loop.
    }
  }
  field public-get protected-set first-row:int

  {doc-next
    {purpose
        Index of the first column in the selection.
    }
    {details
        If negative, it means all columns are
        selected. Use {docref-abbr WorksheetSelection.begin-column} if
        iterating over column indices in a loop.
    }
  }
  field public-get protected-set first-column:int

  {doc-next
    {purpose
        Number of rows included in the selection.
    }
  }
  field public-get protected-set row-count:int
  
  {doc-next
    {purpose
        Number of columns included in the selection.
    }
  }
  field public-get protected-set column-count:int

  {doc-next
    {purpose
        The row index of the current cell within the selection.
    }
    {details
        Must be one of the four corners of the region.
    }
  }
  field public-get protected-set row-anchor:int

  {doc-next
    {purpose
        The column index of the current cell within the selection.
    }
    {details
        Must be one of the four corners of the region.
    }
  }
  field public-get protected-set column-anchor:int

  {doc-next
    {purpose
        Construct this object.
    }
    {parameter first-row,
        Index of the first record in this region.
    }
    {parameter first-column,
        Index of the first column in this region.
    }
    {parameter row-count,
        Number of rows included in this region.
        A value of -1 means all rows.
    }
    {parameter column-count,
        Number of columns included in this region.
        A value of -1 means all columns.
    }
    {parameter row-anchor,
        Row index of the current cell in the selection. If not
        specified, it will be the last row.
    }
    {parameter column-anchor,
        Column index of the current cell in the selection. If not
        specified, it will be the last column.
    }
  }
  {constructor public {default
                          worksheet:Worksheet,
                          first-row:int,
                          first-column:int,
                          row-count:int,
                          column-count:int,
                          row-anchor:int = -1,
                          column-anchor:int = -1
                      }
    {if first-row < 0 or first-column < 0 then
        {error {hlmessage Invalid WorksheetSelection specification.}}
    }

    set self.worksheet = worksheet
    set self.first-row = first-row
    set self.first-column = first-column
    set self.row-count = row-count
    set self.column-count = column-count
    set self.row-anchor =
        {min {max row-anchor, first-row}, first-row + row-count - 1}
    set self.column-anchor =
        {min {max column-anchor, first-column}, first-column + column-count - 1}
  }


  {doc-next
    {purpose
        Construct this object from two corner points.
    }
    {parameter row-anchor,
        Index of the start record in this region.
    }
    {parameter column-anchor,
        Index of the start column in this region.
    }
    {parameter row-point,
        Index of the end record in this region.
    }
    {parameter column-point,
        Index of the end column in this region.
    }
    {since 7.0}
  }
  {constructor public {from-corners
                          worksheet:Worksheet,
                          row-anchor:int,
                          column-anchor:int,
                          row-point:int,
                          column-point:int
                      }
||--    {if row-anchor < 0 or column-anchor < 0 or
||--        row-point < 0 or column-point < 0
||--     then
||--        {error {hlmessage Invalid WorksheetSelection specification.}}
||--    }

    set self.worksheet = worksheet
    set self.first-row = {min row-anchor, row-point}
    set self.first-column = {min column-anchor, column-point}
    set self.row-count = {abs row-anchor - row-point} + 1
    set self.column-count = {abs column-anchor - column-point} + 1
    set self.row-anchor = row-anchor
    set self.column-anchor = column-anchor
  }

  {doc-next
    {purpose Construct an empty selection.}
  }
  {constructor public {empty
                          worksheet:Worksheet
                      }
    set self.worksheet = worksheet
    set self.first-row = 0
    set self.first-column = 0
    set self.row-count = 0
    set self.column-count = 0
    set self.row-anchor = 0
    set self.column-anchor = 0
  }

  {doc-next
    {purpose Construct a selection for all cells in the worksheet.}
  }
  {constructor public {all
                          worksheet:Worksheet
                      }
    set self.worksheet = worksheet
    set self.first-row = -1
    set self.first-column = -1
    set self.row-count = -1
    set self.column-count = -1
    set self.row-anchor = 0
    set self.column-anchor = 0
  }

  {doc-next
    {purpose
        Determine whether two {ctext WorksheetSelection}s are equal.
    }
    {parameter r,
        the selection to be compared with {ctext self}.
    }
  } 
  {method public open {equal? r:WorksheetSelection}:bool
    {return
        self.worksheet == r.worksheet and
        self.first-row == r.first-row and
        self.first-column == r.first-column and
        self.row-count == r.row-count and
        self.column-count == r.column-count
    }
  }

  {doc-next
    {purpose
        Determine whether this region contains a cell location.
    }
    {parameter row-index,
        {ctext int}. Row index of cell of interest. 
    }
    {parameter column-index,
        {ctext int}. Column index of cell of interest. 
    }
    {return-vals 
        {ctext true} if this cell location is within the region.
        Otherwise {ctext false}.
    }
  }
  {method public open {contains-cell? 
                          row-index:int,
                          column-index:int
                      }:bool
    {return
        {if self.all-cells? then
            true
         elseif self.all-rows? then
            column-index >= self.first-column and
            column-index < self.first-column + self.column-count
         elseif self.all-cols? then
            row-index >= self.first-row and
            row-index < self.first-row + self.row-count
         else
            row-index >= self.first-row and 
            row-index < self.first-row + self.row-count and
            column-index >= self.first-column and 
            column-index < self.first-column + self.column-count
        }
    }
  }

  {doc-next
    {purpose Return true of the selection contains no cells.}
  }
  {getter public open {empty?}:bool
    {return self.row-count == 0 and self.column-count == 0}
  }

  {doc-next
    {purpose Return true of the selection contains all rows.}
  }
  {getter public open {all-rows?}:bool
    {return self.first-row == -1}
  }

  {doc-next
    {purpose Return true of the selection contains all columns.}
  }
  {getter public open {all-cols?}:bool
    {return self.first-column == -1}
  }

  {doc-next 
    {purpose 
        Return true when the selection covers the entire {docref Worksheet}.
    }
  }
  {getter public open {all-cells?}:bool
    {return self.first-column == -1 and self.first-row == -1}
  }

  {doc-next
    {purpose The index of the first row in the selection.}
  }
  {getter public open {begin-row}:int
    {return {max 0, self.first-row}}
  }

  {doc-next
    {purpose The index of the last row in the selection.}
  }
  {getter public open {end-row}:int
    {return {if self.first-row < 0 then
                self.worksheet.model.rows - 1
             else
                self.first-row + self.row-count - 1
            }
    }
  }

  {doc-next
    {purpose
        Return the number of rows intersected by the current selection.
    }
  }
  {getter public open {rows}:int
    {return
        {if self.empty? then
            0
         else
            self.end-row - self.begin-row + 1
        }
    }
  }

  {doc-next
    {purpose The index of the first column in the selection.}
  }
  {getter public open {begin-column}:int
    {return {max 0, self.first-column}}
  }

  {doc-next
    {purpose The index of the last column in the selection.}
  }
  {getter public open {end-column}:int
    {return {if self.first-column < 0 then
                self.worksheet.model.cols - 1
             else
                self.first-column + self.column-count - 1
            }
    }
  }

  {doc-next
    {purpose
        Return the number of columns intersected by the current selection.
    }
  }
  {getter public open {cols}:int
    {return 
        {if self.empty? then
            0
         else
            self.end-column - self.begin-column + 1
        }
    }
  }
}

|| -------------------------------------------------------------------------
||--{define-proc public {make-header rgc:RecordGridColumn}:Graphic
||--    {return
||--        {EmbeddedGridHeader
||--            worksheet, rgc,
||--            {rs.fields.get-index rgc.field-name},
||--            font-weight = "bold",
||--            font-size = 8pt,
||--            rgc.field.caption
||--        }
||--    }
||--}

|| Register EmbeddedRecordGrid with the LookAndFeel
{define-proc package {register-control-group
                         control-type:Type,
                         skinnable-ui-type:Type,
                         control-skin:#Type,
                         control-feel:#Type
                     }:void
||--    || Debug code:
||--    {if not {control-type.subtype-of? Control} or
||--        not {skinnable-ui-type.subtype-of? SkinnableControlUI} or
||--        not {skinnable-ui-type.subtype-of? ControlUI}
||--     then
||--        {error}
||--    }
||--    {if-non-null control-skin then
||--        {if not {control-skin.subtype-of? ControlSkin} then
||--            {error}
||--        }
||--    }
||--    {if-non-null control-feel then
||--        {if not {control-feel.subtype-of? ControlFeel} then
||--            {error}
||--        }
||--    }
    def lnf = the-standard-look-and-feel
    {type-switch skinnable-ui-type
     case ct:ClassType do
        {if-non-null maker = {ct.get-constructor "default"} then ||""
            {lnf.register-ui-proc
                control-type,
                {proc {}:ControlUI
                    {return {maker.new} asa ControlUI}
                }
            }
            {if-non-null control-feel then
                {lnf.register-control-feel skinnable-ui-type, control-feel}
            }
            {if-non-null control-skin then
                {lnf.register-control-skin skinnable-ui-type, control-skin}
            }
        }
    }
    
    || FIXME: error on fall-through?
}

||""((
{do
    def lnf = the-standard-look-and-feel
    def skinnable-ui-type =  ProtoSkinnableRecordGridUI
    {register-control-group
        EmbeddedRecordGrid,
        ProtoSkinnableRecordGridUI,
        ProtoRecordGridSkin,
        StandardRecordGridFeel
||--            ProtoRecordGridSkin,
||--            ProtoRecordGridFeel
    }
||--    {lnf.register-control-feel skinnable-ui-type, ProtoRecordGridFeel}
||--    {lnf.register-control-skin skinnable-ui-type, ProtoRecordGridSkin}

    ||FIXME: need ability to add these rules to user's rules
    {install-style-sheet
        {StyleSheet
            {StyleRule "Worksheet",
                grid-line-color = "silver",
                selected-background = "#FDF6B0",
                selected-color = "black",
                background = Worksheet.readonly-bg
            },

||--            {StyleRule "TextField",
||--                border-spec =
||--                    {BorderSpec top-margin = 1px, bottom-margin = 1px}
||--            },

            {StyleRule "RecordGrid/internal-grid",
                border-spec = null
            },

||--            {StyleRule "RecordGrid", ||FIXME: is this needed?
||--                grid-line-color = "silver"
||--            },

            {StyleRule "HorizontalRuler",
                vorigin = "top", horigin = "left",
                vstretch? = true, valign = "top"
            },
            {StyleRule "VerticalRuler",
                vorigin = "top", horigin = "left",
                hstretch? = true, halign = "left"
            },

            {StyleRule "WorksheetGrid/h-resize-rule",
                width = 1px,
                background = "black",
                vorigin = "top", horigin = "left"
            },
            {StyleRule "WorksheetGrid/v-resize-rule",
                height = 1px,
                background = "black",
                vorigin = "bottom", horigin = "left"
            },

            {StyleRule "GridCell",
                width = {make-elastic},
                height = {make-elastic},
                halign = "left",
                background = Worksheet.readonly-bg
            },

            {StyleRule
                "Resizer.vertical",
                height = 2mm,
                background = "transparent",
                width = {make-elastic minimum-size = 2mm},
                cursor = {Cursor.get-top-bottom-resize-cursor}
||--                ,background = "#d0f0f0a0", ||FIXME: DEBUG
            },
            {StyleRule
                "Resizer.horizontal",
                background = "transparent",
                width = 2mm,
                height = {make-elastic minimum-size = 2mm},
                cursor = {Cursor.get-left-right-resize-cursor}
||--                ,background = "#d0f0f0a0", ||FIXME: DEBUG
            },
            {StyleRule
                "SizeNotifier",
                vorigin = "top", horigin = "left"
            },
            {StyleRule
                "SizeNotifier.horizontal",
                background = Worksheet.header-bg,
                color = Worksheet.header-color
            },
            {StyleRule
                "TextField",
                control-appearance-changeable? = true
            },
            {StyleRule
                "SizeNotifier.vertical",
                background = Worksheet.header-bg,
                color = Worksheet.header-color
            }

            || Debugging style rules
||--            ,
||--            {StyleRule "Fill.top-left",
||--                background = "pink"
||--            }
||--            ,{StyleRule
||--                "Fill/vertical-grid-line",
||--                border-width = 1px, border-color = "green"
||--            },
        }
    }
}
||""))

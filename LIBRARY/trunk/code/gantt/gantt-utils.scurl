||| Copyright 1998-2010, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.
|||
||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.
||| ----------------------------------------------------------------------------

{define-proc package {pixel-align-point
                         g:Graphic,
                         local-x:Distance,
                         local-y:Distance
                     }:(new-x:Distance, new-y:Distance)
    {if-non-null v = {g.get-view} then
||--        {return (local-x, local-y)}
        let constant (window-x:Distance, window-y:Distance) =
            {g.transform-to-display-coordinates
                local-x,
                local-y
            }
        def psize = g.display-context.pixel-size
        {return
            {g.transform-from-display-coordinates
                psize * {ceiling (window-x / psize) asa float - 0.5f},
                psize * {ceiling (window-y / psize) asa float - 0.5f}
            }
        }
     else
        {return (local-x, local-y)}
    }
}

|| ----------------------------------------------------------------------

{doc-next
    {purpose A cell for choosing a resource by name (or some other attribute).}
    {details
        This generic class can be instantiated to provide a type
        of {docref RecordGridCell} that can be used as the
        {docref RecordGridColumn.cell-spec} in a column where
        a resource is associated with a task. The {param label-field}
        specifies which column of the {docref ResourceTable} is used
        to identify the resource. Usually this will be "name" or
        "initials".
    }
}
{define-class public open {ChooseResourceField-by label-field:String}
  {inherits ChooseValueCell}

  {doc-next
    {purpose
        Construct this object.
    }
  }
  {constructor public {default}
    {construct-super}
  }

  {method protected open {create-list-value-array}:{Array-of ListValueItem}
    let constant lm:{Array-of ListValueItem} = {{Array-of ListValueItem}}
    {if-non-null pm = self.project-model then
        {for r:Record in {pm.resources.rs.select} do
            {lm.append
                {ListValueItem 
                    r["id"], 
                    label = {url-decode-string r[label-field] asa String}
                }
            }
        }
        {lm.append {ListValueItem 0, label = " "}}
    }
    {return lm}
  }
  
  {method public open {format data:any}:String
    let (data:any, valid?:bool) = {self.get-data}

    let s:String = {super.format data}
    {if {s.find '#'} > -1 then
        let parts:StringArray = {s.split split-chars = "#"} ||""
        set s = parts[0]
    }
    {return {url-decode-string s}}
  }

}

|| ----------------------------------------------------------------------

||FIXME: add these to the API somehow
{def package scheduled-color = "#ffe04080" asa FillPattern}
{def package today-color = "#efef5270" asa FillPattern}
{def package today-border-color = "darkgreen" asa FillPattern}
{def package holiday-color = "#ffa08080" asa FillPattern}

||FIXME: Would be nice to show a vertical line at the pm.schedule-date
||FIXME: Would be nice to show a vertical line at today
{define-class public open GanttCell
  {inherits StandardRecordGridCell}
  
  field private bar:GanttBar
  field protected scale:CalendarScale

  {constructor public {default scale:CalendarScale}
    {construct-super}
    set self.scale = scale
    ||FIXME: set border-color in a style sheet
    set self.bar = {GanttBar self.scale, border-color = "gray"}
    {self.add-internal self.bar}
    set self.cells-take-focus? = false
  }
  
  {getter public open {critical-color}:FillPattern
    {return "#FF7502" asa FillPattern}
  }
  {getter public open {critical-completed-color}:FillPattern
    {return "crimson" asa FillPattern}
  }
  {getter public open {group-color}:FillPattern
    {return "#7EFF52" asa FillPattern}
  }
  {getter public open {group-completed-color}:FillPattern
    {return "#02C502" asa FillPattern}
  }
  {getter public open {task-color}:FillPattern
    {return "#96B9FA" asa FillPattern}
  }
  {getter public open {task-completed-color}:FillPattern
    {return "cornflowerblue" asa FillPattern}
  }


  ||FIXME: No need to require a TaskRecord. Access fields by name instead.
  {method public open {refresh-data}:void
    let (data:String, valid?:bool) = {self.get-formatted-data}
    {if-non-null r = self.record then
        def tr = {TaskRecord r}
        {self.bar.clear-events}
        set self.bar.calendar-scale =
            self.column.header-spec asa CalendarScale
        {if-non-null b = tr.begin, e = tr.end then
            let begin:DateTime = b
            let end:DateTime = e
            let color:FillPattern = self.task-color
            let cdone:FillPattern = self.task-completed-color
            {if tr.has-subtasks? then
                set color = self.group-color
                set cdone = self.group-completed-color
             elseif tr.critical? then
                set color = self.critical-color
                set cdone = self.critical-completed-color
            }
            let completed:Time = tr.c * {begin.elapsed ending = end}
            def tt = {format "%s (%s) %s-%s", ||""
                         tr.name, tr.owner,
                         tr.begin.info.locale-date, tr.end.info.locale-date
                     }
            ||DEBUG
            {if begin > end then
                {dump "begin > end", tr.name}
                {breakpoint}
            }
            {self.bar.add-event
                {EventDisplayInfo 
                    begin, end,
                    color = color,
                    tooltip = 
                        {format "%s (%s) %s-%s", ||""
                            tr.name, tr.owner,
                            tr.begin.info.locale-date, tr.end.info.locale-date
                        }
                }
            }

            {if completed > 1h then
||--                set end = begin + {max 0.0, {round completed/1d}} * 1d
                set end = begin + completed
                {self.bar.add-event
                    {EventDisplayInfo 
                        begin, end,
                        color = cdone,
                        tooltip = tt
                    }
                }
                set begin = end
                set end = e
            }
        }
    }
  }

}

{define-proc public {make-gantt-cell col:RecordGridColumn}:RecordGridCell
    {type-switch col.header-spec
     case scale:CalendarScale do
        {return {GanttCell scale}}
    }
    {return {StandardStringCell}}
}

||--{doc-next
||--    {purpose A {docref RecordGridCell} that can be used to display the
||--        bars of a a Gantt chart.
||--    }
||--    {details
||--        ||FIXME: add detail
||--    }
||--}
||--{define-class public open {GanttCell-for scale:{proc-type {}:CalendarScale}}
||--  {inherits StandardRecordGridCell}
||--  
||--  field private bar:GanttBar
||--
||--
||--  {constructor public {default}
||--    {construct-super}
||--    set self.bar = {GanttBar scale}
||--    {self.add-internal self.bar}
||--    set self.cells-take-focus? = false
||--  }
||--  
||--  {method public open {refresh-data}:void
||--    let (data:String, valid?:bool) = {self.get-formatted-data}
||--    {if-non-null r = self.record then
||--        def tr = {TaskRecord r}
||--        {self.bar.clear-events}
||--        {if-non-null begin = tr.begin, end = tr.end then
||--            {self.bar.add-event
||--                {EventDisplayInfo 
||--                    begin, end, 
||--                    color = 
||--                        {if tr.critical? 
||--                         then "darkorange" else "cornflowerblue" ||""
||--                        },
||--                    tooltip = 
||--                        {format "%s (%s) %s-%s", ||""
||--                            tr.name, tr.owner,
||--                            tr.begin.info.iso-date, tr.end.info.iso-date
||--                        }
||--                }
||--            }
||--        }
||--    }
||--  }
||--
||--}

|| ----------------------------------------------------------------------

{define-class public open TaskDialog {inherits RecordForm}

  {nonlocal-option public project-model:#ProjectModel
  }

  field protected c-ctl:SpinControl
  field protected name-ctl:TextField
  field protected parent-ctl:DropdownList
  field protected owner-ctl:DropdownList
  field protected effort-ctl:TextField
  field protected constraint-ctl:DropdownList
  field protected constraint-date-ctl:DateField
  field protected link-ctl:TextField
  field protected status-ctl:DropdownList
  field protected begin-ctl:DateField
  field protected end-ctl:DateField

||--  field protected req-project-ctl:DropdownList
||--  field protected req-task-ctl:DropdownList


  {constructor public {default
                          record-source:#RecordSet = null,
                          current-index:int = -1,
                          sort:#RecordSort = null,
                          filter:#RecordFilter = null,
                          key-spec:any = "_ord",
                          ...
                      }

    {construct-super 
        record-source = record-source,
        sort = sort,
        filter = filter,
        key-spec = key-spec,
        display-navigation-panel? = false,
        {splice ...}
    }

    {self.request-current-record-change current-index}

    set self.c-ctl = 
        {SpinControl
            width = 48pt,
            {bind value to "c", ||""
                {format c-value:double as
                    c-value * 100.0
                },
                {parse c-slider:double as
                    c-slider / 100.0
                }
            }
        }

    set self.effort-ctl = 
        {TextField
            width = 48pt,
            {bind value to "effort", ||""
                {format effort:Time as
                    {format "%.2f", effort/1d} ||""
                },
                {parse str:String as
                    {str.to-double}*1d
                }
            }
        }

    set self.name-ctl =
        {TextField
            width = {make-elastic preferred-size = 3in},
            {bind value to "name"} ||""
        }

    set self.parent-ctl =
        {DropdownList
            list-item-creation-proc =
                {proc {val:any}:ListItem
                    {if val == 0 then
                        {return
                            {ListValueItem 
                                val,
                                label = {lmessage (Top level project)}
                            }
                        }
                     elseif val == "-" then ||""
                        {return {ListSeparator}}
                     else
                        def tr = 
                            {self.project-model.tasks.get-TaskRecord-by-id
                                val asa int
                            }
                        {return {ListValueItem val, label = tr.name}}
                    }
                },
            {bind value to "pid",
                {format fval:any as
                    {value {dump fval}
                        fval
                    }
                },
                {parse pval:any as
                    {value {dump pval}
                        pval
                    }
                }

            } ||""
        }

    set self.owner-ctl =
        {DropdownList
            width = 96pt,
            {splice {self.project-model.create-resource-list-model}},
            {bind value to "owner"} ||""
        }

    set self.constraint-ctl =
        {DropdownList
||--            {bind value to "constraint"}, ||""
||--            {on e:ValueFinished at c:ValueControl do
||--                {c.update-data-binding "value"} ||""
||--            }
        }

    set self.constraint-date-ctl =
        {DateField
            {bind value to "constraint-date"} ||""
        }

    set self.link-ctl =
        {TextField
            {bind value to "link"} ||""
        }

    set self.status-ctl =
        {new {EnumDropdown-of TaskStatus},
            width = 72pt,
            {bind value to "status"} ||""
        }

    set self.begin-ctl =
        {DateField
            width = 72pt,
            {bind value to "begin"} ||""
        }

    set self.end-ctl =
        {DateField
            width = 72pt,
            {bind value to "end"} ||""
        }


    let tbl:Table = 
        {Table columns = 4,
            margin = 6pt,

            {lmessage Name:},  {cell colspan = 3, {value self.name-ctl}},

            {lmessage Owner:}, 
            {HBox self.owner-ctl, {Fill}},
            {lmessage Effort:}, 
            {HBox self.effort-ctl, {lmessage Days}, {Fill}},

            {lmessage Begin:}, {HBox self.begin-ctl, {Fill}},
            {lmessage End:}, {HBox self.end-ctl, {Fill}},

            {lmessage Status:}, {HBox self.status-ctl, {Fill}},
            {lmessage Completed:}, 
            {HBox self.c-ctl, "%", {Fill}}, ||""

||FIXME: Handle task parent better
||--            {lmessage Part of:},  self.parent-ctl,

            {Fill height = 9pt}, {skip}, {skip}, {skip},

            {skip}, {skip},
            {cell colspan = 2,
                {HBox spacing = 6pt, 
                    {Fill},
                    {ok-button
                        {on e:Action do
                            {if-non-null err = {self.update} then
                                {popup-message err.message}
                                {e.consume}
                             else
                                {self.update}
                            }
                        }
                    }, 
                    {cancel-button}
                }
            }
        }

    {self.update-controls}
    {self.add tbl}
  }

  {method public open {update-controls}:void
    {if-non-null r = self.current-record then
        def tr = {TaskRecord r}
        set self.c-ctl.enabled? = not tr.has-subtasks?
        set self.name-ctl.enabled? = true
        set self.parent-ctl.enabled? = true
        set self.owner-ctl.enabled? = true
        set self.effort-ctl.enabled? = not tr.has-subtasks?
        set self.constraint-ctl.enabled? = not tr.has-subtasks?
        set self.constraint-date-ctl.enabled? = not tr.has-subtasks?
        set self.link-ctl.enabled? = true
        set self.status-ctl.enabled? = true
        set self.begin-ctl.enabled? = not tr.has-subtasks?
        set self.end-ctl.enabled? = not tr.has-subtasks?
    }

    let parent-list:{Array-of TaskRecord} =  || Ones that have subtasks
        {new {Array-of TaskRecord}}
    let task-list:{Array-of TaskRecord} =    || Those without subtasks (yet)
        {new {Array-of TaskRecord}}
    {for r:Record in self.records do
        def tr = {self.project-model.tasks.get-TaskRecord r}
        {if tr.has-subtasks? then
            {parent-list.append tr}
         else
            {task-list.append tr}
        }
    }

    let dlm:ListModel = self.parent-ctl.data-model

    ||NOTE: the value of a ListValueItem comes from the data-model
    {dlm.clear}
    {dlm.append 0}
    {for tr:TaskRecord in parent-list do
        {dlm.append tr.id}
    }
    {dlm.append "-"} ||""
    {for tr:TaskRecord in task-list do
        {dlm.append tr.id}
    }
  }

  {method public open {on-current-record-changed e:CurrentRecordChanged}:void
    {super.on-current-record-changed e}
    {self.update-controls}
  }

}

|| ----------------------------------------------------------------------

{define-proc package {focus-record rsd:RecordSetDisplay, id:int}:void
    {for r:Record key ri in rsd.records do
        {if r["id"] asa int == id then ||""
            {rsd.request-current-record-change ri}
            {after 0s do
                {type-switch rsd
                 case grid:RecordGrid do
                    let target-cell:#RecordGridCell = null
                    {try
                        ||FIXME: why is this exception thrown sometimes?
                        set target-cell = 
                            {grid.ui.get-cell-at
                                grid.records[ri],
                                grid.columns[0]
                            }
                     catch ignore:Exception do
                    }
                    {if-non-null target-cell then
                        {grid.ui.set-grid-focus target-cell}
                    }
                }
            }
            {break}
        }
    }
}



{doc-next
    {purpose A command used to create a new resource.}
}
{define-class public open NewResourceCommand {inherits CommandImpl}

  field protected resource-table:ResourceTable
  field protected record-display:RecordSetDisplay

  {doc-next
    {purpose Construct a {ctext NewResourceCommand}}
  }
  {constructor public {default
                          resource-table:ResourceTable,
                          record-display:RecordSetDisplay
                      }
    set self.resource-table = resource-table
    set self.record-display = record-display
    {construct-super "new-resource"} ||""
  }
  
  {getter public open {enabled?}:bool
    def rs = self.resource-table.rs
    || Enabled unless there is already a new (empty) resource
    {return not self.resource-table.project.busy?
        and {rs.select-one filter = {RecordData name = ""}} == null
        and {rs.select-one filter = {RecordData initials = ""}} == null
    }
  }

  ||Methods to implement CommandImpl (docs inherited}
  {method protected open {execute}:void
    def id = {self.resource-table.new-resource}
    {focus-record self.record-display, id}
  }
  
}

{doc-next
    {purpose A command used to edit a task.}
}
{define-class public open EditTaskCommand {inherits CommandImpl}

  field protected project-model:ProjectModel
  field protected record-display:RecordSetDisplay
  {doc-next
    {purpose Construct an {ctext EditTaskCommand}}
  }
  {constructor public {default 
                          project-model:ProjectModel,
                          record-display:RecordSetDisplay
                      }
    set self.project-model = project-model
    set self.record-display = record-display
    {construct-super "Gantt.edit-task"} ||""
  }
  
  {getter public open {enabled?}:bool
    def rs = self.project-model.tasks.rs
    {return not self.project-model.busy? and self.record-display.current-index >= 0}
  }

 
  ||Methods to implement CommandImpl (docs inherited}
  {method protected open {execute}:void
    def form = {TaskDialog
                   record-source = self.record-display.record-source,
                   key-spec = "_ord", ||""
                   current-index = self.record-display.current-index,
                   project-model = self.project-model
               }
    {form.show
        title = {lmessage Edit Task}
    }
  }
  
}

{doc-next
    {purpose A command used to add a new subtask.}
}
{define-class public open NewSubtaskCommand {inherits AddChildNodeCommand}

  field protected project-model:ProjectModel

  {doc-next
    {purpose Construct an {ctext NewSubtaskCommand}}
  }
  {constructor public {default 
                          project-model:ProjectModel,
                          grid:TreeGrid
                      }
    set self.project-model = project-model
    {construct-super grid, name = "Gantt.add-subtask"}
  }

  {getter public open {enabled?}:bool
    def rs = self.project-model.tasks.rs
    {return super.enabled? and not self.project-model.busy?
        and {rs.select-one filter = {RecordData name = ""}} == null
    }
  }

 
  ||Methods to implement CommandImpl (docs inherited}
  {method protected open {execute}:void
    {super.execute}
    {after 0s do
        {if-non-null cr = self.current-record then
            def id = cr["id"] asa int
            {focus-record self.record-display, id}
            def form = {TaskDialog
                           record-source = self.record-display.record-source,
                           key-spec = "_ord", ||""
                           current-index = self.record-display.current-index,
                           project-model = self.project-model
                       }
            {form.show
                title = {lmessage Edit Subtask}
            }
        }
    }
  }
}

{doc-next
    {purpose A command used to add a new task.}
}
{define-class public open NewTaskCommand {inherits AddNodeCommand}

  field protected project-model:ProjectModel

  {doc-next
    {purpose Construct an {ctext NewTaskCommand}}
  }
  {constructor public {default 
                          project-model:ProjectModel,
                          grid:TreeGrid
                      }
    set self.project-model = project-model
    {construct-super grid, name = "Gantt.add-task"} ||""
  }

  {getter public open {enabled?}:bool
    def rs = self.project-model.tasks.rs
    {return super.enabled? and not self.project-model.busy?
        and {rs.select-one filter = {RecordData name = ""}} == null
    }
  }

 
  ||Methods to implement CommandImpl (docs inherited}
  {method protected open {execute}:void
    {super.execute}
    {after 0s do
        {if-non-null cr = self.current-record then
            def id = cr["id"] asa int
            {focus-record self.record-display, id}
            def form = {TaskDialog
                           record-source = self.record-display.record-source,
                           key-spec = "_ord", ||""
                           current-index = self.record-display.current-index,
                           project-model = self.project-model
                       }
            {form.show
                title = {lmessage Edit Task}
            }
        }
    }
  }

}

|| ----------------------------------------------------------------------

{doc-next
    {purpose A command used to create a new calendar event.}
}
{define-class public open NewEventCommand {inherits CommandImpl}

  field protected project-model:ProjectModel
  field protected record-display:RecordSetDisplay

  {doc-next
    {purpose Construct a {ctext NewEventCommand}}
  }
  {constructor public {default
                          project-model:ProjectModel,
                          record-display:RecordSetDisplay
                      }
    set self.project-model = project-model
    set self.record-display = record-display
    {construct-super "new-event"} ||""
  }


  {getter public open {enabled?}:bool
    def rs = self.project-model.events.rs
    || Enabled unless there is already a new (empty) event
    {return not self.project-model.events.project.busy?
        and {rs.select-one filter = {RecordData descr = ""}} == null
    }
  }

||--  {method public open {focus-record id:int}:void
||--
||--    {after 0s do
||--        {for r:Record key ri in self.record-display.records do
||--            {if r["id"] asa int == id then ||""
||--                {self.record-display.request-current-record-change ri}
||--                {break}
||--            }
||--        }
||--    }
||--  }

  ||Methods to implement CommandImpl (docs inherited}
  {method protected open {execute}:void
    def id = {self.project-model.events.new-event}
    def rv = {RecordView
                 self.project-model.events.rs,
                 filter = {RecordData id = id}
             }
    def form = {EventDialog
                   record-source = rv,
                   key-spec = "id", ||""
                   current-index = 0,
                   project-model = self.project-model
               }
    {focus-record self.record-display, id}
    {form.show
        title = {lmessage Edit New Calendar Entry}
    }
    {if form.return-state == Dialog.cancel then
        {{rv.select}[0].delete}
     else
        {self.project-model.refresh}
    }
  }
}

{doc-next
    {purpose A command used to edit properties of a calendar event.}
}
{define-class public open EditEventCommand {inherits CommandImpl}

  field protected project-model:ProjectModel
  field protected record-display:RecordSetDisplay

  ||FIXME: What if there were no RecordGrid for selecting the event?
  || Need something besides record-display...
  {doc-next
    {purpose Construct an {ctext EditTaskCommand}}
  }
  {constructor public {default 
                          project-model:ProjectModel,
                          record-display:RecordSetDisplay
                      }
    set self.project-model = project-model
    set self.record-display = record-display
    {construct-super "edit-event"} ||""
  }
  
  {getter public open {enabled?}:bool
    def rs = self.project-model.events.rs
    {return not self.project-model.busy? and self.record-display.current-index >= 0}
  }

 
  ||Methods to implement CommandImpl (docs inherited}
  {method protected open {execute}:void
    def form = {EventDialog
                   record-source = self.record-display.record-source,
                   key-spec = "id", ||""
                   current-index = self.record-display.current-index,
                   project-model = self.project-model
               }
    {form.show
        title = {lmessage Edit Calendar Entry}
    }
  }

}


{define-class public open EventDialog {inherits RecordForm}

  {nonlocal-option public project-model:#ProjectModel
    ||FIXME: Remove this change handler if not needed
  }

  field protected who-ctl:DropdownList
  field protected descr-ctl:TextField
  field protected first-ctl:DateField
  field protected open-ctl:RadioFrame
  field protected final-ctl:DateField
  field protected repeat-ctl:RadioFrame
  field protected note-ctl:TextArea

  {constructor public {default
                          record-source:#RecordSet = null,
                          current-index:int = -1,
                          sort:#RecordSort = null,
                          filter:#RecordFilter = null,
                          key-spec:any = null,
                          ...
                      }

    {construct-super 
        record-source = record-source,
        sort = sort,
        filter = filter,
        key-spec = key-spec,
        display-navigation-panel? = false,
        {splice ...}
    }

    {self.request-current-record-change current-index}

    set self.who-ctl =
        {DropdownList
            width = 2in,
            {splice {self.project-model.create-resource-list-model
                        default-label = "(All)"
                    }
            },
            {bind value to "who"} ||""
        }

    set self.descr-ctl =
        {TextField
            width = 2.0in,
            {bind value to "descr"} ||""
        }

    set self.first-ctl =
        {DateField
            width = 72pt,
            {bind value to "first"} ||""
        }

    set self.final-ctl =
        {DateField
            width = 72pt,
            {bind value to "final"} ||""
        }

    set self.open-ctl =
        {RadioFrame
            {HBox
                spacing = 9pt,
                {RadioButton
                    label = {lmessage Open Ended},
                    radio-value = true
                },
                {HBox
                    spacing = 3pt,
                    {RadioButton
                        label = "",||{lmessage Ends on:},
                        radio-value = false
                    },
                    self.final-ctl,
                    {Fill}
                }
            },
            {bind value to "final",
                {format fval:any as || convert from context to value
                    fval == null
                },
                {parse pval:any as  || convert from value to context
                    {if pval asa bool then
                        null
                     else
                        self.final-ctl.value
                    }
                }
            },
            {on ValueChanged at rf:RadioFrame do
                set self.final-ctl.enabled? = not rf.value asa bool
            }
        }
    
    set self.note-ctl =
        {TextArea
            width = 2in, height = 48pt,
            vorigin = 12/48,
            {bind value to "note"} ||""
        }

    set self.repeat-ctl =
        {RadioFrame
            {bind value to "repeat"}, ||""
            {VBox
                {RadioButton
                    label = {lmessage None},
                    radio-value = RepeatPeriod.none
                },
                {RadioButton
                    label = {lmessage Weekly},
                    radio-value = RepeatPeriod.week
                },
                {RadioButton
                    label = {lmessage Monthly, same date},
                    radio-value = RepeatPeriod.month
                },
                {RadioButton
                    label = {lmessage Monthly, same day and week},
                    radio-value = RepeatPeriod.month-day
                },
                {RadioButton
                    label = {lmessage Yearly, same date},
                    radio-value = RepeatPeriod.year
                },
                {RadioButton
                    label = {lmessage Yearly, same day and week of month},
                    radio-value = RepeatPeriod.year-month-day
                }
            }
        }



    let tbl:Table = 
        {Table columns = 2,
            halign = "right",
            margin = 6pt,
            
            {lmessage Calendar:}, {HBox self.who-ctl, {Fill}},

            {lmessage Description:}, {HBox self.descr-ctl, {Fill}},

            {lmessage First Time:}, {HBox self.first-ctl, {Fill}},


            {hlmessage Repeats:}, {HBox self.repeat-ctl, {Fill}},

            {lmessage Ends:}, {HBox self.open-ctl, {Fill}},

            {lmessage Notes:}, {HBox self.note-ctl, {Fill}},

            {Fill height = 6pt}, {skip},

            {skip},
            {cell colspan = 2,
                {HBox spacing = 6pt, 
                    {Fill},
                    {ok-button
                        {on e:Action do
                            {if-non-null err = {self.update} then
                                {popup-message err.message}
                                {e.consume}
                             else
                                {self.update}
                            }
                        }
                    }, 
                    {cancel-button}
                }
            }
        }

    {self.update-controls}
    {self.add tbl}
  }

  {method public open {update-controls}:void
    {if-non-null r = self.current-record then
        def tr = {EventRecord r}
        set self.who-ctl.enabled? = true
        set self.descr-ctl.enabled? = true
        set self.first-ctl.enabled? = true
        set self.final-ctl.enabled? = true
        set self.repeat-ctl.enabled? = true
        set self.note-ctl.enabled? = true
     else
        set self.who-ctl.enabled? = false
        set self.descr-ctl.enabled? = false
        set self.first-ctl.enabled? = false
        set self.final-ctl.enabled? = false
        set self.repeat-ctl.enabled? = false
        set self.note-ctl.enabled? = false
    }
  }

  {method public open {on-current-record-changed e:CurrentRecordChanged}:void
    {super.on-current-record-changed e}
    {self.update-controls}
  }

}

|| ----------------------------------------------------------------------

{doc-next
    {purpose Set up a correspondence between dates on a calendar and
        a position on the screen.
    }
    {details
        This class was designed to help plot task schedules in a Gantt
        chart. It can be used for any visual display where information
        is plotted against calendar dates. Weekend days can be omitted
        if desired.

        This class is {docref Observable}. If any property change
        might have an effect on the display of data plotted using one
        of these objects, the observers are sent a message.  The
        message is null, so the observers must either rebuild the
        display completely or cache values of interest and look
        for changes.
    }
}
{define-class public open CalendarScaleSpec {inherits Observable}

  field protected _min-date:DateTime
  field protected _max-date:DateTime

  field protected _workdays-only?:bool
  field protected _adjusting?:bool

  {doc-next {purpose Initialize a new {docref CalendarScaleSpec}.}
    {parameter start-date, The first date to be shown.}
    {parameter max-date, The last date to be shown.}
    {parameter workdays-only?, If true, weekend days are ignored.}
  }
  {constructor public {default
                          min-date:DateTime,
                          max-date:DateTime,
                          workdays-only?:bool = true
                      }
    set self._max-date = max-date
    set self._min-date = min-date
    set self._workdays-only? = workdays-only?
  }

  || FIXME: don't do this. The observer can just check for adjusting?
  {method protected open {notify-observers
                             message:any = null
                         }:void
    {if self.adjusting? then
        {super.notify-observers}
     else
        {super.notify-observers message = "changed"}
    }
  }

  {getter public open {min-date}:DateTime
    {return self._min-date}
  }
  {setter public open {min-date v:DateTime}:void
    set self._min-date = v
    {self.notify-observers}
  }
  
  {getter public open {max-date}:DateTime
    {return self._max-date}
  }
  {setter public open {max-date v:DateTime}:void
    set self._max-date = v
    {self.notify-observers}
  }

  {getter public open {workdays-only?}:bool
    {return self._workdays-only?}
  }
  {setter public open {workdays-only? v:bool}:void
    set self._workdays-only? = v
    {self.notify-observers}
  }

  {getter public open {adjusting?}:bool
    {return self._adjusting?}
  }
  {setter public open {adjusting? v:bool}:void
    set self._adjusting? = v
    {if not self._adjusting? then
        {self.notify-observers}
    }
  }

  {doc-next
    {purpose Return true if {param dt} is the first visible day of the
        month.
    }
    {details
        If {docref CalendarScaleSpec.workdays-only?} is true, then the
        first visible day of the month will be the first Monday of the
        month. If the first of the month is on a weekend, the first
        visible day will be the following Monday.
    }
  }
  {method public open {first-day-of-month? dt:DateTime}:bool
    {if self.workdays-only? then
        {if dt.info.day == 2 and dt.info.day-of-week == 1 then
            {return true}
         elseif dt.info.day == 3 and dt.info.day == 1 then
            {return true}
        }
    }
    {return dt.info.day == 1}
  }

  {doc-next
    {purpose Indicate if the specified date {param t} should be displayed.}
    {details
        A date should not be displayed if it is before the
        {docref-abbr CalendarScaleSpec.begin-date} or after
        {docref-abbr CalendarScaleSpec.max-date}, or if it is a
        weekend day and {docref CalendarScaleSpec.workdays-only?} is
        true.
    }
  }
  {method public open {displayed-date? t:DateTime}:bool
    {if t < self.min-date or t > self.max-date then
        {return false}
    }
    {if self.workdays-only? then 
        def weekend? = t.info.day-of-week == 6 or t.info.day-of-week == 7
        {return not weekend?}
    }
    {return true}
  }

  {doc-next
    {purpose Given a date, return a position relative to the origin at
        {docref-abbr CalendarScaleSpec.begin-date}.
    }
    {parameter date, The date for which a position is desired.
        Unless {param include-end?} is true, the position
        corresponds to the last moment before this date.
    }
    {parameter dx, The distance amount that corresponds to one day.}
    {parameter include-end?, If true, the returned distance corresponds
        to the end of the day given by {param date}.
    }
  }
  {method public open {map-date-to-position 
                          date:DateTime,
                          day-width:Distance,
                          full-day?:bool = true,
                          include-end?:bool = false
                      }:Distance
    def days = {self.displayed-days self.min-date, date,
                   include-end? = include-end?, full-day? = full-day?
               }
    {return days * day-width}
  }

  {method public open {map-position-to-date
                          position:Distance,
                          day-width:Distance
                      }:DateTime
    let days:int = (position div day-width) asa int
    {if self.workdays-only? then
        def weeks = days div 5
        def lwd = days rem 5
        let wd:int = 0
        def sdn = self.min-date.info.day-of-week
        {if sdn == 6 then
            set wd = 2
         elseif sdn == 7 then
            set wd = 1
        }
        {if sdn + lwd > 5 then
            {inc wd, 2}
        }
        {inc wd, weeks * 2}
        {inc days, wd}
    }
    {return self.min-date + days * 1d}
  }

  {method private {get-adjustment days:int, sdn:int, edn:int}:int
    {if days <= 0 then
        {return -days}
    }
    {if days <= 7 then
        || Various cases within one week
        {if edn < sdn then
            {return 2} || Can only happen if weekend in between
         elseif edn == 7 then
            {if sdn == 7 then {return 1} else {return 2}}
         elseif edn == 6 then
            {return 1}
         elseif sdn == 7 and edn == 6 then
            {return 2}
         else
            {return 0}
        }
    }

    let adj:int = 0
    {if sdn == 6 then
        {inc adj, 2}
        {dec days, 6}
     elseif sdn == 7 then
        {inc adj, 1}
        {dec days, 5}
     else
        {dec days, 5 - sdn}
    }

    {if edn == 7 then
        {inc adj, 2}
        {dec days, 6}
     elseif edn == 6 then
        {inc adj, 1}
        {dec days, 5}
     else
        {dec days, edn - 1}
    }

    || included weekends?
    def nw = (((days - 0) + 6) div 7)
    {inc adj, nw * 2}
    {return adj}
  }

  {method private {align-date dt:DateTime}:DateTime
    {if self.workdays-only? then
        {if dt.info.day-of-week == 6 then
            {inc dt, 2d}
         elseif dt.info.day-of-week == 7 then
            {inc dt, 1d}
        }
    }
    {return dt}
  }

  {method public open {displayed-days
                          start:DateTime,
                          end:DateTime,
                          full-day?:bool = true,
                          include-end?:bool = false
                      }:double
    let d0:DateTime = {self.align-date start}
    let d1:DateTime = {self.align-date end}

    || zero days if end is before start
    {if d1 < d0 then
        {return 0.0}
    }

    {if full-day? then
        set d0 = {DateTime
                     d0,
                     year = d0.info.year,
                     month = d0.info.month,
                     day = d0.info.day
                 }
        set d1 = {DateTime
                     d1,
                     year = d1.info.year,
                     month = d1.info.month,
                     day = d1.info.day
                 }
    }
    {if include-end? then
        set  d1 = {self.align-date d1 + 1d}
    }

    || Want to round up, but be careful about daylight time change!
    let days:int = (({d0.elapsed ending = d1}+22h)/1d) asa int
    let ddays:double = (({d0.elapsed ending = d1})/1d)
    {if days != ddays then
||--        {dump days, ddays}
    }

    {if self.workdays-only? then
        def d-adj = d1 - 0d || 1d
        let sdn:int = d0.info.day-of-week
        let edn:int = d-adj.info.day-of-week
        def dadj = {self.get-adjustment days, sdn, edn}
        {dec days, dadj}
        {dec ddays, dadj}
    }
    {return ddays}
  }
}


{doc-next
    {purpose Display a calendar scale in a rectangle with ticks for
        each date.
    }
    {details
        This object is used to render a scale with marks for each day
        in the associated {docref CalendarScaleSpec}. It observers
        the {param spec} and rebuilds the scale as necessary. The
        preferred width and height are determined by the {docref
        font-size} option in combination with {param spec.scale}.
    }
}
|| This can observe the Spec (which is the model)
|| 
{define-class public open CalendarScale {inherits Canvas, Observer, Observable}

  field public-get protected-set _spec:CalendarScaleSpec
  field public-get protected-set date-formatter:DateTimeFormatter =
      {DateTimeFormatter locale = {get-working-locale}, include-time? = false}

  {local-option public tall?:bool = false
    {self.note-spec-changed}
  }

  field private entered?:bool || Pointer is inside somewhere 
  field private pressed?:bool || Pressed while inside

  field protected offset-days:int = 0
  field private first-y:Distance
  field private first-x:Distance
  field private first-offset:int = 0
  field private min-offset:int = 0
  field private max-offset:int = 0
  field protected _divisions:ShapeGroup

  field protected _font-size:Distance
  field public-get protected-set left-margin:Distance = 0pt

  ||FIXME: not used
  || The date displayed at the left
  field protected left-date:DateTime

  {nonlocal-option public project-model:#ProjectModel
    {self.init}
  }

  {nonlocal-option public font-size:any
    set self._font-size =
        {self.any-to-Distance self.font-size,
            convert-font-relative-values? = true,
            for-font-size? = true
        }
    set self.left-margin = 0pt
    {self.note-spec-changed}
  }

  {constructor public {default
                          spec:CalendarScaleSpec,
                          ...
                      }
    set self.left-date = {DateTime.date}||FIXME
    set self._spec = spec
    set self.date-formatter =
        {DateTimeFormatter locale = {get-working-locale}, include-time? = false}
    {construct-super.Observer}
    {construct-super.Observable}
    set self._divisions = {ShapeGroup}
    {construct-super.Canvas
        tooltip = 
            {Tooltip.from-proc
                duration = 4s,
                {proc {v:Visual, x:Distance, y:Distance}:Graphic
                    def t =
                        {self.spec.map-position-to-date 
                            x - self.offset, self.day-width
                        }
                    {return
                        {Frame
                            margin = 2px,
                            t.info.locale-date
                        }
                    }
                }
            },
        {splice ...}
    }
    ||FIXME: Need a "grab" cursor
    set self.cursor = cursor-hand
    {self.add x = 0m, y = 0m, self._divisions}
    set self.opaque-to-events? = true
    {self.observe spec}
    {self.init}
||--    {self.note-spec-changed}
  }

  || Support dragging to change spec.min-date

  {method public open {on-pointer-enter e:PointerEnter}:void
    set self.entered? = true
    {super.on-pointer-enter e}
  }

  {method public open {on-pointer-leave e:PointerLeave}:void
    set self.entered? = false
    set self.pressed? = false
    {super.on-pointer-leave e}
  }

  {method public open {on-drag-started e:DragStarted}:void
    {if not e.consumed? and self.entered? then
        set self.pressed? = true
        set self.spec.adjusting? = true
        {e.continue-implicit-pointer-grab self}
        {e.consume}
        set self.first-x = e.x
        set self.first-y = e.y
        set self.first-offset = self.offset-days
    }
    {super.on-drag-started e}
  }

  {method public open {on-pointer-release e:PointerRelease}:void
    {e.consume}
    {if self.pressed? and e.button == left-button then
        set self.pressed? = false
        set self.spec.adjusting? = false
        let entered?:bool = false
        {if-non-null layout = self.layout then
            set entered? = {{layout.get-cell-bounds}.within? e.x, e.y}
        }
        {if not entered? then
            set self.entered? = entered?
        }
    }
    {super.on-pointer-release e}
  }

  {getter public open {offset}:Distance
    {return self.offset-days * self.day-width}
  }

  {method private {refresh-offset}:void
    def qx = self.offset-days * self.day-width
    {self._divisions.set-translation-in-parent qx, 0m}
    {self.notify-observers message = qx}
  }

  || Fire an adjustment with value equal to the number of pixels moved
  {method public open {on-pointer-motion e:PointerMotion}:void
    {if self.pressed? then
        {if-non-null layout = self.layout then
            let dx:Distance = (e.x - self.first-x)
            let nd:int = {floor dx/self.day-width} asa int
||--            def ex = dx - nd * self.day-width
||--            {dump self.offset-days, nd}
||--            {if e.y < self._font-size then
||--                set nd = nd * 4
||--            }
            set self.offset-days = self.first-offset + nd
            {if self.offset-days < self.min-offset then
                set self.offset-days = self.min-offset
                set nd = 0
             elseif self.offset-days > self.max-offset then
                set self.offset-days = self.max-offset
                set nd = 0
            }
            {if {abs nd} > 0 then
                {self.refresh-offset}
            }
            {e.consume}
        }
    }
    {super.on-pointer-motion e}
  }


  {method protected open {handle-observer-message
                             sender:Observable,
                             message:any
                         }:void
    {self.notify-observers message = message}
    {self.note-spec-changed}
  }

  {getter public open {spec}:CalendarScaleSpec
    {return self._spec}
  }

|| Don't allow setting, because it complicates observing
||--  {setter public open {spec v:CalendarScaleSpec}:void
||--    set self._spec = v
||--    {self.note-spec-changed}
||--  }

  {getter public open {day-width}:Distance
    ||FIXME: round to pixel size?
    {return self._font-size * 0.75}
  }

  {getter public open {header-height}:Distance
    def m = {if self.tall? then 2.6 else 1.5}
    {return self._font-size * m}
  }

  {getter public open {bar-height}:Distance
    {return self._font-size * 0.9}
  }

  {method public open {map-date-to-position 
                          date:DateTime,
                          full-day?:bool = true,
                          include-end?:bool = false
                      }:Distance
    {return {self.spec.map-date-to-position 
                date, self.day-width,
                full-day? = full-day?,
                include-end? = include-end?
            } + self.left-margin
    }
  }

  {method private {init}:void
    {dump self.project-model}
    {if-non-null pm = self.project-model then
        def default-offset-days =
            -{self.spec.displayed-days pm.min-date, pm.begin-date} asa int
        set self.min-offset =
            -{self.spec.displayed-days pm.end-date, pm.max-date} asa int
            + default-offset-days
        set self.max-offset = 1
        {if self.offset-days < self.min-offset or
            self.offset-days > self.max-offset 
         then
            set self.offset-days = default-offset-days
        }
        {self.add-divisions}
        {self.refresh-offset}
    }
  }

  ||FIXME: May need to fix this so many requests result in exactly one update
  {method public open {note-spec-changed}:void
|| FIXME: figure out when to reset the scrolling
||--    set self.pressed? = false
||--    set self.offset-days = 0
    {self.init}
  }

  {method public open {add-divisions}:void
    {self._divisions.clear}

    def fs = self._font-size
    def px =  {self.any-to-Distance 1px}
    def bottom = self.header-height
    let month-y:Distance = fs
    let day-y:Distance = {if self.tall? then fs * 2.0 else month-y}
    let monday-y:Distance = bottom - fs/2.2
    let tick-y:Distance = bottom - fs/3.5
    def today = {DateTime.date}
    def last-date = self.spec.max-date + 90d

    || First display alternating background
    let alt?:bool = false
    def alt-bg = {self.alternate-row-background.to-FillPattern}

    let x1:Distance = 0m
    let y1:Distance = 0m
    let rx:Distance = 0m
    let ry:Distance = 0m

    let t:DateTime = self.spec.min-date
    let nm:DateTime = t
    {while t <= last-date do
        def x = {self.map-date-to-position t}
        set nm = {DateTime.date
                     year = t.info.year,
                     month = t.info.month + 1,
                     day = 1
                 }
        def wx = {self.map-date-to-position nm} - x
        set (x1, y1) = {pixel-align-point self, x, 0m}
        set (rx, ry) = {pixel-align-point self, wx, bottom}
        {if alt? then
            {self._divisions.add 
                x = x1, y = y1,
                {RectangleShape {GRect 0m, rx, 0m, ry}, color = alt-bg}
            }
        }
        set alt? = not alt?
        set t = nm
    }

    || Now display the labels and ticks
    set t = self.spec.min-date
    {while t <= last-date do
        def monday? = t.info.day-of-week == 1
        def tick-top = {if monday? then monday-y else tick-y}
        def x = {self.map-date-to-position t}
        {if true or {self.spec.displayed-date? t} then
            set (x1, y1) = {pixel-align-point self, x, tick-top}
            set (rx, ry) = {pixel-align-point self, fs/12, bottom - tick-top}
||--            {self._divisions.add
||--                x = x1, y = y1,
||--                {RectangleShape
||--                    {GRect rx, 0m, 0m, ry}, color = self.border-color
||--                }
||--            }

            || Label with the date on Mondays
            {if monday? then
                def label =
                    {if self.tall? then
                        {format "%d", t.info.day}
                     else
                        {format "%02d/%02d", t.info.month, t.info.day}
                    }
                {self._divisions.add
                    x = x, y = day-y,
                    {TextShape
||--                        translation = {Distance2d x, day-y},
                        color = self.border-color, halign = "left",
                        label
                    }
                }
            }

            || Label each day with a tooltip
            let (holiday?:bool, descr:String) =
                {self.project-model.events.holiday? t}
            def color =
                {if holiday? then
                    holiday-color
                 elseif t == today then
                    set descr = {hlmessage Today}
                    today-color
                 else
                    null
                }
            {if-non-null color then
                set (x1, y1) = {pixel-align-point self, x, 0m}
                set (rx, ry) = {pixel-align-point self, self.day-width, bottom}
                {self._divisions.add
                    x = x1, y = y1,
                    {RectangleShape
                        {GRect px, rx, 0m, ry},
                        tooltip = {format 
                                      {hlmessage %s - %s},
                                      t.info.locale-date,
                                      descr
                                  },
                        color = color
                    }
                }
            }

            || If tall format, label with  month and year on first of month
            {if self.tall? and {self.spec.first-day-of-month? t} then
                def label = self.date-formatter.month-names[t.info.month - 1]
                 & " " & {String t.info.year}
                {self._divisions.add
                    x = x + 1pt, y = month-y,
                    {TextShape 
                        color = self.border-color,
                        halign = "left", label}
                }
            }
        }
        set t = t + 1d
    }

    || Adjust sizes
    set self.height = bottom
    set self.width =
        {self.spec.displayed-days
            self.spec.min-date, last-date} * self.day-width
  }

  {method public open {draw renderer2d:Renderer2d}:void
    {super.draw renderer2d}
    let bounds:GRect = {self.layout.get-bounds}
    let top-edge:Distance    = -bounds.ascent
    let bottom-edge:Distance =  bounds.descent
    let left-edge:Distance   = -bounds.lextent
    let right-edge:Distance  =  bounds.rextent
    
    def fs = self._font-size
    def px =  {self.any-to-Distance 1px}
    def bottom = self.header-height
    let month-y:Distance = fs
    let day-y:Distance = {if self.tall? then fs * 2.0 else month-y}
    let monday-y:Distance = bottom - fs/2.2
    let tick-y:Distance = bottom - fs/3.5
    def today = {DateTime.date}

    def last-date = self.spec.max-date + 90d
    let t:DateTime = self.spec.min-date
    {while t <= last-date do
        def monday? = t.info.day-of-week == 1
        def tick-top = {if monday? then monday-y else tick-y}
        def x = {self.map-date-to-position t} + self.offset
        def (x1, y1) = {pixel-align-point self, x, tick-top}
        def (rx, ry) = {pixel-align-point self, fs/12, bottom - tick-top}
||--                x = x1, y = y1,
||--                {RectangleShape
||--                    {GRect rx, 0m, 0m, ry}, color = self.border-color
||--                }
||--            }

            || Label with the date on Mondays
        {with-render-properties 
            draw-operation = DrawOperation.mask on renderer2d do     
            {renderer2d.render-rectangle
                x1, y1, rx, ry, fill-pattern = self.border-color
            }
        }
        set t = t + 1d
    }
  }
  
}

|| ----------------------------------------------------------------------

{doc-next
    {purpose A helper class used to carry the information required to
        display one segment in a {docref GanttBar}.
    }
}
{define-value-class public final EventDisplayInfo
  field public constant begin:DateTime
  field public constant end:DateTime
  field public constant color:FillPattern = "black"
  field public constant tooltip:String = ""

  {doc-next
    {purpose Construct a new {docref EventDisplayInfo}.}
  }
  {constructor public {default
                          begin:DateTime,
                          end:DateTime,
                          color:FillPattern = "black",
                          border-color:FillPattern = "gray",
                          tooltip:String = ""
                      }
    set self.begin = begin
    set self.end = end
    set self.color = color
    set self.tooltip = tooltip
  }
}

{doc-next
    {purpose A graphical object that will display on bar of a Gantt
        chart, corresponding to one scheduled activity.
    }
}
{define-class public open GanttBar {inherits Canvas, Observer}

  field public-get protected-set _calendar-scale:CalendarScale

  field public constant events:{Array-of EventDisplayInfo} =
      {new {Array-of EventDisplayInfo}}

  {nonlocal-option public font-size:any
    || Refer to self._spec for measurements, but need to refresh now
    {self.refresh}
  }

  field protected _refresh-requested?:bool = false

  {method public open {schedule-refresh}:void
    {if not self._refresh-requested? then
        set self._refresh-requested? = true
        {after 0s do
            {self.refresh}
            set self._refresh-requested? = false
        }
    }
  }
  {constructor public {default
                          calendar-scale:any,
                          ...
                      }
    {construct-super.Observer}
    {construct-super.Canvas {splice ...}}
    set self._calendar-scale = 
        {type-switch calendar-scale
         case p:{proc-type {}:CalendarScale} do
            {p}
         else
            calendar-scale asa CalendarScale
        }
    {self.observe self.calendar-scale}
||--    {self.observe self.calendar-scale.spec}
    {self.note-info-changed}
  }

  {method public open {add-event ...:EventDisplayInfo}:void
    {for e:EventDisplayInfo in ... do
        {self.events.append e}
    }
    {self.schedule-refresh}
  }

  {method public open {clear-events}:void
    {self.events.clear}
    {self.schedule-refresh}
  }

  {method protected open {handle-observer-message
                             sender:Observable,
                             message:any
                         }:void
    {type-switch message
     case ms:String do
        || Sent by CalendarScaleSpec when any attribute is changed
        {if ms == "changed" then
            {self.note-info-changed}
        }
     case d:Distance do
        || Sent by CalendarScale for scrolling behavior
        {for s:Shape in self.shape-children do
            {s.set-translation-in-parent d, 0m}
        }            
    }
  }

  {getter public open {spec}:CalendarScaleSpec
    {return self._calendar-scale.spec}
  }

  {getter public open {calendar-scale}:CalendarScale
    {return self._calendar-scale}
  }
||FIXME: if set is allowed, need to stop observing
  {setter public open {calendar-scale v:CalendarScale}:void
    set self._calendar-scale = v
    {self.note-info-changed}
  }

  {method public open {note-info-changed}:void
    {self.schedule-refresh}
  }

  {method public open {refresh}:void
    let x:Distance = 0m
    let dx:Distance = self.calendar-scale.day-width
    def dy = self.calendar-scale.bar-height
    let y:Distance = dy * .5
    def bottom = y + dy + y
    let px:Distance = {self.any-to-Distance 1px}

    {self.clear}
    {for e key ei in self.events do
        set x = {self.calendar-scale.map-date-to-position e.begin}
        set dx = {self.calendar-scale.map-date-to-position
                     e.end, full-day? = false} - x
        def segment = {RectangleShape
                          border-width = px,
                          border-color = self.border-color,
                          {GRect -x, x + dx + px, -y, y + dy},
                          color = e.color
                      }
        {if e.tooltip != "" then
            set segment.tooltip = e.tooltip
        }
        {self.add 
||--            x = x + 1 * px, y = y,
            segment
        }
        {segment.set-translation-in-parent self.calendar-scale.offset, 0m}
    }

    {if-non-null pm = self.project-model then
        set x = {self.calendar-scale.map-date-to-position pm.schedule-date}
        def fs = self.calendar-scale._font-size
        set dx = self.calendar-scale.day-width
        let x1:Distance = 0m
        let y1:Distance = 0m
        let rx:Distance = 0m
        let ry:Distance = 0m
        set (x1, y1) = {pixel-align-point self, x + px, 0m}
        set (rx, ry) = {pixel-align-point self, x + dx + 2 * px, bottom}
        def segment =
            {RectangleShape
                color = today-color,
                {GRect -x1, rx, y1, ry}
            }
        {self.add segment}
        {segment.set-translation-in-parent self.calendar-scale.offset, 0m}
    }

    || Adjust overall sizes
    set self.height = bottom
    set self.width =
        {self.spec.map-date-to-position
            self.calendar-scale.spec.max-date, self.calendar-scale.day-width
        }
  }

}

|| ----------------------------------------------------------------------

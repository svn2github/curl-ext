||| Copyright 1998-2010, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.
|||
||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.
||| ----------------------------------------------------------------------------

|#-------------------------------------------------------------------------

  To Do

  o Put depth, ln, rn, and hide into a separate object that takes
    one column in the model. (TreeGridNodeInfo)
    - ExpanderCell already assumes it is in a TreeGrid

    o Use a TreeNodeDomain to parse and format. Only needs to
      serialize _ord and _expand. _id and _pid would be in the user's
      record. Others can be computed.

    o RecordSet supplied by caller. Needs id and pid fields to define
      the tree structure. Also one column for TreeGridNodeInfo.


#|||-----------------------------------------------------------------------


||FIXME: Notify observers, or don't inherit from Observable
{doc-next
    {purpose Data model for the {docref TreeGrid}.}
    {details
        This is one way to represent a hierarchy in a {docref
        RecordSet}.  The relationship between a parent node and it's
        children is modelled using a parent id, so that each child
        essentially points to it's parent. Additional columns are
        used to make the tree easier to work with, or to represent
        the state of a node. 

        The {docref RecordSet} that stores the tree model will contain
        columns that represent the tree as well as additional columns
        of data that are determined by the requirements of the
        application that is using the tree. The columns used by the
        tree model are given names starting with an underscore (such
        as "_pid" for the parent id) to help prevent conflict with
        application specific fields. The model must have a unique id
        column (of type int). The name of this column is "_id" by
        default. You can specify an different column name if your
        application already has a unique id field. The other field
        names are predefined: "_pid", "_ord", "_expand", "_depth",
        "_ln", "_rn", "_hide",

        The {param _ord} column is used to control the order in which
        nodes are displayed. The {docref TreeGrid} always displays
        records sorted by this column. Operations such as using drag
        and drop to rearrange the children or sorting by some other
        column in the model are implemented by changing the {param
        _ord} values and relying on the {ctext TreeGrid} to display
        them in the desired order.

        The {param _depth} column is used to indent each node label
        according to the depth in the hierarchy.

        The {param _ln} and {param _rn} columns are computed by
        numbering the nodes in a depth first tree walk. The {param
        _ln} numbers are assigned on the way down, the {param _rn}
        numbers on the way back up. Any leaf node will have {ctext _rn
        == _ln + 1}. On any record, the difference between _ln and _rn
        divided by two and rounded down gives the number of nodes
        below that node in the hierarchy. You can select a node and
        it's children by selecting for _ln greater than or equal to
        the node's _ln and _rn less than or equal to the nodes _rn.

        The {param _expand?} column indicates if a node is expanded or
        collapsed. When collapsed, the children are not shown.  This
        is controlled by the {param _hide} column, which is recomputed
        any time the {param _expand?} field is changed. When the
        _expand? field is changed, the _hide field is changed on all
        of the child nodes.
    }
}
{define-class public open RecordSetTreeModel {inherits Observable}

  {doc-next
    {purpose
        The name of the field that determines the order in which
        records are displayed.
    }
  }
  let public constant pos-field:String = "_ord"
  let public constant parent-id-field:String = "_pid"
  let public constant depth-field:String = "_depth"

  {doc-next
    {purpose 
        The name of the unique id field in {docref
        RecordSetTreeModel.source}.
    }
  }
  field public-get protected-set id-field:String = "_id"

  {doc-next
    {purpose
        The fields used to support display and manipulatoin of the
        tree.
    }
  }
  def public tree-fields =
      {new {Array-of RecordField},
        {RecordField "_pid", ||""
            caption = "pid", ||""
            domain = int,
            index-type = RecordFieldIndexType.none
        },
        {RecordField "_ord", ||""
            caption = "ord", ||""
            domain = int,
            index-type = RecordFieldIndexType.none
        },
        {RecordField "_expand?", ||""
            caption = "exp?", ||""
            domain = bool
        },
        {RecordField "_depth", ||""
            caption = {lmessage depth},
            domain = int,
            index-type = RecordFieldIndexType.none
        },
        {RecordField "_ln", ||""
            caption = "ln", ||""
            domain = int,
            index-type = RecordFieldIndexType.none
        },
        {RecordField "_rn", ||""
            caption = "rn", ||""
            domain = int,
            index-type = RecordFieldIndexType.none
        },
        {RecordField "_hide",  ||""
            caption = "hide",  ||""
            domain = bool,
            index-type = RecordFieldIndexType.none
        }
      }


  ||FIXME: If we want to share an id field, we need a way to allow the
  ||application to assign the id to a new record.
  {doc-next
    {purpose The fields in the a {docref RecordSet} used to store the tree.}
    {details
        This method computes the complete set of fields used for the
        {docref RecordSet} that stores the tree data.
        These fields are the standard tree fields (see {docref
        RecordSetTreeModel.tree-fields}), the {param id-field}, and
        any additional fields that are required by a specific
        application.

        In the simplest case, pass in the fields required by the
        application. This will result in a list of fields that
        includes the the standard tree fields followed by application
        specific fields.

        If the application already contains a unique id field,
        and you give the name of this field as {param id-field} then
        the {docref RecordSetTreeModel} will not add another id field.

        If you need complete control over the order of the fields,
        pass in a complete set of fields, including the standard tree
        fields and a field with a name that matches {param id-field}.
    }
    {parameter id-field,
        The name of the unique id field in the record. Use this if the 
        application already contains a unique id field.
    }
    {parameter ..., additional field definitions for the {docref RecordSet}
        that stores the tree data.
    }
  }
  {define-proc public {get-fields
                          id-field:String = "_id",
                          ...:RecordField
                      }:RecordFields
    let need-id?:bool = true
    let need-standard?:bool = true
    {for rf:RecordField in ... do
        {if rf.name == id-field then
            set need-id? = false
        }
        {if rf.name == RecordSetTreeModel.parent-id-field then
            set need-standard? = false
        }
    }
       
    {return
        {if need-id? and need-standard? then
            || User supplied only the custom fields
            {RecordFields
                {RecordField id-field,
                    caption = {lmessage id},
                    domain = int,
                    index-type = RecordFieldIndexType.unique
                },
                {splice RecordSetTreeModel.tree-fields},
                {splice ...}
            }
         elseif not need-id? and not need-standard? then
            || User wants complete control over fields and order
            {RecordFields
                {splice ...}
            }
         else
            || User has id-field but wants the other standard fields
            {RecordFields
                {splice RecordSetTreeModel.tree-fields},
                {splice ...}
            }
        }
      }
  }

  {doc-next
    {purpose The {docref RecordSet} used to store the tree nodes.}
  }
  field public-get protected-set source:CsvRecordSetB

  {doc-next
    {purpose
        This counter is incremented any time the model is changed.
        Use it to determine if cache or other dependent data needs to be
        recomputed.
    }
  }
  field public-get protected-set source-change-count:int

  {doc-next
    {purpose Set of ids of nodes (records) that should be hidden because the
        parent node is collapsed.
    }
    {details
        This set of hidden nodes is computed in a tree walk. Then the
        "_hide" field is set accordingly.        
    }
  }
  field private hidden-nodes:{Set-of int} = {new {Set-of int}}

  {doc-next
    {purpose
        The unfiltered tree records in canonical order, used for
        implementing commands that rearrange the tree nodes.
    }
  }
  field public-get protected-set ordered-records:RecordView =
      {uninitialized-value-for-type RecordView}

  {doc-next
    {purpose 
        The tree records with hidden nodes filtered out. These are the
        records visible in the {docref TreeGrid} used to display the
        tree.
    }
  }
  field public-get protected-set  display-records:RecordView =
      {uninitialized-value-for-type RecordView}

  {doc-next
    {purpose
        Indicates that a refresh should be performed once the applet
        returns to the event loop.
    }
  }
  field protected _refresh-requested?:bool = false

  {doc-next
    {purpose
        Initialize a {docref RecordSetTreeModel} with data from
        a {docref RecordSet}.
    }
    {details
        The {param source} records must have at least the fields given
        by {docref RecordSetTreeModel.tree-fields}. Any number of
        additional fields can be present.
    }
    {parameter id-field,
        The name of the unique id field in the record. Use this if the 
        application already contains a unique id field.
    }
    {parameter source, The {docref RecordSet} containing the data representing
        the tree.
    }
  }
  {constructor public {default
                          id-field:String = "_id",
                          source:CsvRecordSetB
                      }
    {construct-super}
    set self.id-field = id-field
    set self.source = source
    {self.init-views}
  }

  {doc-next
    {purpose
        Construct a {docref RecordSetTreeModel} given the application
        fielda and an optional location.
    }
    {details
        This constructor will use a {docref CsvRecordSetB} to store
        the tree records. If {param url} is not null, the data will be
        read from the specified location. If it is null, the tree data
        will be in-memory only.
    }
    {parameter url, The location where the tree data is stored.}
    {parameter id-field,
        The name of the unique id field in the record. Use this if the 
        application already contains a unique id field.
    }
    {parameter character-encoding, The character encoding used for the
        data file.
    }
    {parameter backup?, If true a backup of the csv file will be made
        the first time the data is committed to disk.
    }    
    {parameter ..., Any number of {docref EventHandler} and/or
        {docref RecordField}s.

        Event handlers are for {docref RecordSetEvent}s that are fired
        at the {docref RecordSet} used to store the tree model.

        Record fields are used to construct the underlying {docref 
        RecordSet}.
    }
  }
  {constructor public {from-fields
                          url:#Url,
                          id-field:String = "_id",
                          character-encoding:CharEncoding = "utf8", ||""
                          backup?:bool = false,
                          ...
                      }
    {construct-super}
    set self.id-field = id-field
    let handlers:{Array-of EventHandler} = {new {Array-of EventHandler}}
    let fields:{Array-of RecordField} = {new {Array-of RecordField}}
    {for a in ... do
        {type-switch a
         case eh:EventHandler do
            {handlers.append eh}
         case rf:RecordField do
            {fields.append rf}
         else
            {error 
                {format
                    {hlmessage Expected an EventHandler or RecordField: %s},
                    a
                }
            }
        }
    }
    set self.source =
        {CsvRecordSetB
            url,
            {RecordSetTreeModel.get-fields
                id-field = id-field, {splice fields}
            },
            id-field = id-field,
            modifiable? = true,
            character-encoding = character-encoding,
            backup? = backup?,
            {splice handlers}
        }
    {self.init-views}
  }

  {doc-next
    {purpose
        Construct a {docref RecordSetTreeModel} given the application
        fielda and an optional location.
    }
    {details
        This constructor will use a {docref CsvRecordSetB} to store
        the tree records. If {param url} is not null, the data will be
        read from the specified location. If it is null, the tree data
        will be in-memory only.
    }
    {parameter url, The location where the tree data is stored.}
    {parameter id-field,
        The name of the unique id field in the record. Use this if the 
        application already contains a unique id field.
    }
    {parameter ..., Any number of {docref EventHandler} and/or
        {docref RecordField}s.

        Event handlers are for {docref RecordSetEvent}s that are fired
        at the {docref RecordSet} used to store the tree model.

        Record fields are used to construct the underlying {docref 
        RecordSet}.
    }
  }
  {constructor public {from-RecordSet
                          rs:RecordSet,
                          groups:StringArray,
                          id-field:String = "_id",
                          ...:EventHandler
                      }
    {construct-super}
    set self.id-field = id-field
    set self.source =
        {CsvRecordSetB
            null,
            {RecordSetTreeModel.get-fields
                id-field = id-field, {splice rs.fields}
            },
            id-field = id-field,
            modifiable? = true,
            {splice ...}
        }
    {self.init-views}

    def last-gval = {RecordData}
    def pids = {new {Array-of int}, 0}

    || Make a sort string
    def sort-spec = {StringBuf}
    {for gname:String in groups do
        {if gname == self.id-field then
            {error {hlmessage You cannot group by the id field.}}
        }
        {pids.append 0}
        {if sort-spec.size > 0 then
            {sort-spec.concat ", "}
        }
        {sort-spec.concat gname}
        ||FIXME: an option for reverse sort on some fields
||--            {sort-spec.concat " DESC"}
        set last-gval[gname] = null
    }

    let level:int = 1
    def rv = {RecordView rs, sort = {sort-spec.to-String}}
    {for r:Record in rv do
        let gl:int = 0
        {for gname:String in groups do
            {inc gl}
            || Need a new parent record?
            {if r[gname] != last-gval[gname] then
                set last-gval[gname] = r[gname]
                def nr = {self.source.new-record}
                {for name:String in groups do
                    set nr[name] = r[name]
                    {if name == gname then
                        {break}
                    }
                }
                set nr[RecordSetTreeModel.parent-id-field] = pids[gl - 1]
                set nr["_expand?"] = true
                {self.source.append nr}
                set level = gl
                set pids[gl] = nr[self.id-field] asa int
            }
        }
        def nr = {self.source.new-record}
        set nr[RecordSetTreeModel.parent-id-field] = pids[level]
        set nr["_expand?"] = true
        {for rf:RecordField in rs.fields do
            {if rf.name != self.id-field then
                set nr[rf.name] = r[rf.name]
            }
        }
        {self.source.append nr}
    }
||--    {self.schedule-refresh}
    {self.refresh}
    {self.reorder}
  }

  {doc-next
    {purpose
        Initialize a {docref RecordSetTreeModel} using a
        {docref CsvRecordSetB} read from a file.
    }
    {parameter url, The location of the file of tree data, in CSV format.
    }
    {parameter id-field,
        The name of the unique id field in the record. Use this if the 
        application already contains a unique id field.
    }
    {parameter fields, The fields in the data file.
    }
    {parameter character-encoding, The character encoding used for the
        data file.
    }
    {parameter backup?, If true, a backup file will be created when
        the data file is written.
    }
    {parameter ..., Any number of {docref EventHandler} and/or
        {docref RecordField}s.

        Event handlers are for {docref RecordSetEvent}s that are fired
        at the {docref RecordSet} used to store the tree model.

        Record fields are used to construct the underlying {docref 
        RecordSet}.
    }
  }
  {constructor public {from-Url
                          url:Url,
                          id-field:String = "_id",
                          character-encoding:CharEncoding = "utf8", ||""
                          backup?:bool = false,
                          ...:any
                      }
    {construct-super}
    set self.id-field = id-field
    let handlers:{Array-of EventHandler} = {new {Array-of EventHandler}}
    let fields:{Array-of RecordField} = {new {Array-of RecordField}}
    {for a in ... do
        {type-switch a
         case eh:EventHandler do
            {handlers.append eh}
         case rf:RecordField do
            {fields.append rf}
         else
            {error 
                {format
                    {hlmessage Expected an EventHandler or RecordField: %s},
                    a
                }
            }
        }
    }
    set self.source =
        {CsvRecordSetB
            url, 
            {RecordSetTreeModel.get-fields
                id-field = id-field, {splice fields}
            },
            id-field = id-field,
            modifiable? = true,
            character-encoding = character-encoding,
            backup? = backup?,
            {splice handlers}
        }
    {self.init-views}
  }

  {doc-next
    {purpose
        Save the underlying data to the specified location. All future
        reading and writing will be to this location.
    }
    {details
        This will throw a {docref CastException} if {docref
        RecordSetTreeModel.source} is not a {docref CsvRecordSetB}.
    }
  }
  {method public open {save-as location:Url}:void
    ||FIXME: Will this work with any EventManagingRecordSet?
    || maybe this does not belong here.
    {(self.source asa CsvRecordSetB).save-as location}
  }

  {method private {check-required-field field:String}:void
    def i = {self.source.fields.get-index field}
  }

  {doc-next
    {purpose
        Return the depth of the node represented by {param r}.  Top
        level nodes have depth 0.
    }
  }
  {method public open {get-depth r:Record}:int
    {return r["_depth"] asa int} ||""
  }

  {method private {init-views}:void
    {self.check-required-field self.id-field}
    {for rf:RecordField in RecordSetTreeModel.tree-fields do
        {self.check-required-field rf.name}
    }

    {self.source.add-event-handler
        {on e:RecordsChanged at rs:RecordSet do
            {self.schedule-refresh}
        }
    }
    {self.source.add-event-handler
        {on e:RecordSetLoadStateChanged at rs:RecordSet do
            {if rs.load-state == RecordSetLoadState.complete then
                {self.schedule-refresh}
            }
        }
    }

    set self.ordered-records = {RecordView self.source, sort = "_ord"} ||""

    set self.display-records = 
        {RecordView self.source,
            sort = "_ord", ||""
            filter = 
                {proc {r:Record}:bool
                    {return not {self.hidden-nodes.member?
                                    r[self.id-field] asa int
                                }
                    }
||--                    {return not (r["_hide"] asa bool)} ||""
                }
        }

    {self.refresh}
||--    {self.schedule-refresh}
  }

  {doc-next
    {purpose
        Request a refresh, which will recompute the data columns used
        to represent the tree structure.
    }
    {details 
        The calculations run after the current event has been handled,
        with {docref RecordSet.batch-events?} = true so that only one
        {docref RecordSetEvent} is generated after all of the calculations
        are complete.
    }
  }
  {method public open {schedule-refresh}:void
    {inc self.source-change-count}
    {if not self._refresh-requested? then
        set self._refresh-requested? = true
        {after 0.0s do
            {with self.source.batch-events? = true do
                {self.refresh}
            }
            set self._refresh-requested? = false
        }
    }
  }

  {doc-next
    {purpose
        Given a node, return the number of records that encompass all
        of its subsidiary nodes.
    }
    {parameter r, The record that represents a tree node.}
  }
  {method public open {count-subordinates r:Record}:int
    def count = (r["_rn"] asa int - r["_ln"] asa int + 1) div 2 ||""
    {return count - 1}
  }

  {doc-next
    {purpose
        Recalculate the columns that are derived from the hierarchy
        defined by the parent relation.
    }
  }
  {method public open {refresh}:void
    || Use the parent relation to Compute depth, ln, rn for the tree
    let n:int = 0
    let rstm:RecordSetTreeModel = self

    || Compute the attribute that are derived from the parent/child relation
    {walk-record-tree self.source,
        id-field = self.id-field,
        pre =
            {proc {parent:Record, children:{Array-of Record}}:void
                {inc n}
                set parent["_ln"] = n ||""
                {if parent[RecordSetTreeModel.parent-id-field] == 0 then
                    set parent["_depth"] = 0} ||""
                {for c:Record in children do
                    set c["_depth"] = parent["_depth"] asa int + 1 ||""
                }
            },
        post = 
            {proc {parent:Record, children:{Array-of Record}}:void
                {inc n}
                set parent["_rn"] = n ||""
            }
    }

    || Determine which nodes should be hidden, and hide them
    {self.hidden-nodes.clear}

    {walk-record-tree 
        id-field = self.id-field,
        self.source,
        pre =
            {proc {parent:Record, children:{Array-of Record}}:void
                def p-expand? = parent["_expand?"] asa bool ||""
                {for c:Record in children do
                    {if not p-expand?
                        or {self.hidden-nodes.member?
                               parent[self.id-field] asa int}
                     then
                        {self.hidden-nodes.insert c[self.id-field] asa int}
                    }
                }
            }
    }
    {for r:Record in self.source do
        set r["_hide"] = ||""
            {self.hidden-nodes.member? r[self.id-field] asa int}
    }
    set self._refresh-requested? = false
  }

  {doc-next
    {purpose
        Given a record {param r} that represents a tree node, return
        the records that are beneath it in the heirarchy.
    }
  }
  {method public open {node-and-children r:Record}:{Array-of Record}
    def ln = r["_ln"] asa int ||""
    def rn = r["_rn"] asa int ||""
    {return {self.ordered-records.select
                filter =
                    {proc {r:Record}:bool
                        {return r["_ln"] asa int >= ln ||""
                            and r["_ln"] asa int <= rn ||""
                        }
                    }
            }
    }
  }


  || This is currently done within the refresh method:
  {doc-next
    {purpose
        Assign the ordinal values to fix the nodes in the current order.
    }
    {details
        Logically all nodes that have the same parent are unordered.
        The "_ord" field is used to impose an order. When a tree is
        first created, this method can be called to assign the ordinal
        positions. From then on, the position is maintained just like
        any other data.
    }
  }
  {method public open {reorder}:void
    let n:int = 1
    let rstm:RecordSetTreeModel = self
    {walk-record-tree self.source,
        id-field = self.id-field,
        pre =
            {proc {parent:Record, children:{Array-of Record}}:void
                set parent[RecordSetTreeModel.pos-field] = n
                {inc n, 1}
            }
    }
  }
}

{doc-next
    {purpose
        A specialized sort for use in a {docref TreeGrid}.
    }
    {details
        A tree sort when all sibling nodes are sorted, at every
        level of the tree. This means that comparing two records
        may require comparing parent records, at least up to a
        common parent.
    }
}
||FIXME: add doc strings once this settles down
{define-class public open TreeRecordSort {inherits RecordSort}

  field public-get protected-set sort-field:String

  field protected sort:DefaultRecordSort

  field protected _record-set:#RecordSet
  field protected _sort-requested?:bool = false
  field protected _reverse?:bool = false
  {method public open {schedule-sort}:void
    {if not self._sort-requested? then
        set self._sort-requested? = true
        {after 0.0s do
            {if-non-null rs = self._record-set then
                {self.sort-sequence
                    {rs.select},
                    rs,
                    reverse? = self._reverse?
                }
            }
            set self._sort-requested? = false
        }
    }
  }

  {constructor public {default sort-field:String}
    set self.sort-field = sort-field
    set self.sort = {DefaultRecordSort.from-string sort-field}
  }

  {method public open {compare r1:Record, r2:Record}:int
    ||FIXME: not quite right
    set self._record-set = r1.record-set
    {self.schedule-sort}
    {return 0}
||--    {dump "compare", r1[self.id-field], r2[self.id-field]}
||--    {if-non-null rs = r1.record-set then
||--||--    {return {self.sort.compare r1, r2}}
||--||--    {after 0s do
||--||--        {self.adjust-ord r1.record-set}
||--||--    }
||--
||--        {return {self.tree-compare rs, r1, r2}}
||--     else
||--        {return 0}
||--    }
  }  

  field private busy?:bool = false

  {method private {adjust-ord
                      recs:{Sequence-of Record},
                      record-set:RecordSet
                  }:void
||--    set self.sort-domain = record-set.fields[self.sort-field].domain
||--    {if self.busy? then
||--        {return}
||--     else
||--        set self.busy? = true
||--    }
    let src:RecordSet = record-set
    {while src isa RecordView do
        set src = (src asa RecordView).source
    }
    {with src.batch-events? = true do
        {for r:Record key ri in recs do
            set r[RecordSetTreeModel.pos-field] =
                ri + 1000 ||DEBUG: add 1000 to make it obvious
        }
    }
    set self.busy? = false
  }

  {method private {tree-compare record-set:RecordSet, a:Record, b:Record}:int
    def a-pid = a[RecordSetTreeModel.parent-id-field] asa int
    def b-pid = b[RecordSetTreeModel.parent-id-field] asa int
    {if a-pid == b-pid then
        {return {self.sort.compare a, b}}
    }
    def ap = {record-set.select-one
                 filter = {RecordData id = a-pid}}
    def bp = {record-set.select-one
                 filter = {RecordData id = b-pid}}
    {if-non-null ap, bp then
        {return {self.tree-compare record-set, ap, bp}}
     else
        {if ap == null then
            {return {self.tree-compare record-set, a, {non-null bp}}}
         elseif bp == null then
            {return {self.tree-compare record-set, {non-null ap}, b}}
        }
        {return 0}
    }
  }

  {method public open {sort-sequence
                          list:{Sequence-of Record},
                          record-set:RecordSet,
                          reverse?:bool = false
                      }:void

    def recs = {record-set.select}
    set self._reverse? = reverse?
||--    {dump "Before:"}
||--    {for r in recs do {dump r[self.id-field]}}

    def find-parent-at-depth =
        {proc {r:Record, depth:int}:Record
            let rd:int = r[RecordSetTreeModel.depth-field] asa int
            {while rd > depth do
                def pid = r[RecordSetTreeModel.parent-id-field] asa int
                def pr = {record-set.select-one filter = {RecordData id = pid}}
                set rd = pr[RecordSetTreeModel.depth-field] asa int
                {if rd == depth then
                    {return {non-null pr}}
                }
            }
            {return r}
        }

    || FIXME: probably need a hash for child -> parent, to avoid select-one
    def comp =
        {proc {a:Record, b:Record}:int
            || Only compare records at the same depth within the tree
            def a-depth = a[RecordSetTreeModel.depth-field] asa int
            def b-depth = b[RecordSetTreeModel.depth-field] asa int
            {if a-depth > b-depth then
                set a = {find-parent-at-depth a, b-depth}
            }
            {if b-depth > a-depth then
                set b = {find-parent-at-depth b, a-depth}
            }

            def a-pid = a[RecordSetTreeModel.parent-id-field] asa int
            def b-pid = b[RecordSetTreeModel.parent-id-field] asa int
||--            {dump a[self.id-field], a-pid, b[self.id-field], b-pid}
            def aval = a[self.sort-field]
            def bval = b[self.sort-field]
            {if a-pid == b-pid then
                {return {self.sort.compare a, b}}
            }
            def ap = {record-set.select-one
                         filter = {RecordData id = a-pid}}
            def bp = {record-set.select-one
                         filter = {RecordData id = b-pid}}
            {if-non-null ap, bp then
                {return {comp ap, bp}}
             else
                {if ap == null then
                    {return {comp a, {non-null bp}}}
                 elseif bp == null then
                    {return {comp {non-null ap}, b}}
                }
                {return 0}
            }
        }

    {recs.sort
        comparison-proc =
            {if reverse? then
                {proc {r1:Record, r2:Record}:bool
                    {return -{self.tree-compare record-set, r1, r2} <= 0}
                }
             else
                {proc {r1:Record, r2:Record}:bool
                    {return {self.tree-compare record-set, r1, r2} <= 0}
                }
            }

||--            {if reverse? then
||--                {proc {r1:Record, r2:Record}:bool
||--                    {return -{comp r1, r2} <= 0}
||--                }
||--             else
||--                {proc {r1:Record, r2:Record}:bool
||--                    {return {comp r1, r2} <= 0}
||--                }
||--            }
    }
||--    {dump "After:"}
||--    {for r in recs do {dump r[self.id-field]}}
    {self.adjust-ord recs, record-set}
  }
}


{doc-next
    {purpose
        A {docref RecordFilter} that takes the tree structure of a
        {docref TreeGrid} into account.
    }
    {details
        This filter delegates to an ordinary {docref RecordFilter} to
        determine if a record should be included. If it passes, then
        all records that represent an ancestor node also pass.
    }
}
{define-class public open TreeRecordFilter {inherits RecordFilter}

  {doc-next
    {purpose The filter that determines if the current record passes.}
  }
  field protected record-filter:RecordFilter

  {doc-next
    {purpose The grid that this filter is attached to.}
  }
  field protected treegrid:TreeGrid

  {doc-next
    {purpose An array indexed by the "_ln" number from a record. The
        value of {ctext filter-cache[_ln]} is true if the record passed
        the filter.
    }
  }
  field protected filter-cache:{Array-of bool}

  {doc-next
    {purpose
        Count changes to avoid recomputing the {docref
        TreeRecordFilter} unless something has changed.
    }
  }
  field protected filter-change-count:int = -1

  {doc-next
    {purpose
        Construct a {docref TreeRecordFilter} from a {docref RecordFilter}.
    }
  }
  {constructor public {default treegrid:TreeGrid, filter:RecordFilter}
    set self.record-filter = filter
    set self.treegrid = treegrid
    set self.filter-cache = {new {Array-of bool}}
  }
  

  {doc-next
    {purpose Does the filter include a record?}
    {details
        This method should return {ctext false} if and only if  
        the input record should be discarded by any 
        {docref RecordView} with this filter applied. 
    }
  }
  {method public open {includes? r:Record}:bool
    {self.refresh}
    {return self.filter-cache[r["_ln"] asa int]}
  }   

  {method protected open {refresh}:void
    {if self.filter-change-count != self.treegrid.model.source-change-count then
        let max-ln:int = 0
        {for r:Record in self.treegrid.model.source do
            def ln = r["_ln"] asa int
            {if ln > max-ln then
                set max-ln = ln
            }
        }
        set self.filter-cache =
            {new {Array-of bool}.from-size, max-ln + 1, false}

        {for r:Record in self.treegrid.model.source do
            def ln = r["_ln"] asa int
            def rn = r["_rn"] asa int
            {if ln + 1 == rn then
                set self.filter-cache[ln] = {self.record-filter.includes? r}
            }
        }
        {walk-record-tree self.treegrid.model.source,
            id-field = self.treegrid.model.id-field,
            post =
                {proc {parent:Record, children:{Array-of Record}}:void
                    def ln = parent["_ln"] asa int
                    {for cr:Record in children do
                        def cln = cr["_ln"] asa int
                        {if self.filter-cache[cln] then
                            set self.filter-cache[ln]  = true
                            {break}
                        }
                    }
                }
        }
        set self.filter-change-count = self.treegrid.model.source-change-count
    }
  }

}


|| ------------------
|| TreeGrid Commands
|| ------------------

||FIXME: get the id field and store it as int to save lookups later

{doc-next
    {purpose Base class for commands that operate on a {docref TreeGrid}.}
}
{define-class abstract public open TreeGridCommand
  {inherits RecordSetDisplayCommand}

  {doc-next
    {purpose
        The {docref TreeGrid} that contains this {docref Command} in
        it's {docref CommandContext}.
    }
  }
  field public-get protected-set grid:TreeGrid

  {doc-next
    {purpose
        A getter to return the {docref RecordSetTreeModel} associated
        with this command.
    }
  }
  {getter public open {model}:RecordSetTreeModel
    {return self.grid.model}
  }

  {doc-next
    {purpose
        Construct a {docref TreeGridCommand} by giving it a name
        and a {docref TreeGrid} to operate on.
    }
  }
  {constructor public {default
                          name:String,
                          grid:TreeGrid
                      }
    set self.grid = grid
    {construct-super name, grid}
  }

  {doc-next
    {purpose The field that determines the order of records in a {docref
        TreeGrid}.
    }
  }
  {getter public open {pos-field}:String
    {return RecordSetTreeModel.pos-field}
  }

  {doc-next
    {purpose The insertion point of the selection in the current cell.}
  }
  field protected current-point:int

  {doc-next
    {purpose The "anchor" end of the selection in the current cell.}
  }
  field protected current-anchor:int

  {doc-next
    {purpose The row index of the current cell in the associated {docref
        TreeGrid}.
    }
  }
  field protected current-row-index:int

  {doc-next
    {purpose The column index of the current cell in the associated {docref
        TreeGrid}.
    }
  }
  field protected current-column-index:int

  {doc-next
    {purpose
        Remember the current cell location and selection and commit
        pending changes.
    }
  }
  {method public open {commit-current-cell}:void
    set self.current-point = -1
    set self.current-row-index = -1
    {if-non-null cc = (self.record-display asa RecordGrid).ui.grid-focus then
        {type-switch cc
         case sc:StandardBaseEditableStringCell do
            {type-switch sc.current-editor
             case tf:BaseTextField do
                set self.current-point = tf.selected-range.point
                set self.current-anchor = tf.selected-range.anchor
            }
        }
        set self.current-row-index = cc.record-index
        set self.current-column-index =
            {cc.grid.columns.find {non-null cc.column}}
        {cc.grid.ui.set-grid-focus null}
    }
  }

  {doc-next
    {purpose Restore the focus to the current cell.}
    {details
        This method will attempt to restore keyboard focus to the current
        cell, with the same selection as before, after one or several nodes
        have been moved by a command.
    }
    {parameter crid, The id of the current record.}
  }
  {method public open {refocus-current-cell crid:int}:void
    || If the cell to focus on is new, don't try to restore selection
    {if-non-null cr = self.current-record then
        {if crid != cr[self.model.id-field] asa int then ||""
            set self.current-point = -1
        }
     else
        set self.current-point = -1
    }

    || Do this after the RecordGrid has a chance to create new cells, etc.
    {after 0s do
        {if crid > 0 then
            {for r:Record key ri in self.record-display.records do
                {if r[self.model.id-field] asa int == crid then ||""
                    set self.current-row-index = ri
                    {break}
                }
            }
        }
        {if self.current-row-index >= 0 then
            def grid = self.record-display asa RecordGrid
            let target-cell:#RecordGridCell = null
            {try
                ||FIXME: why is this exception thrown sometimes?
                set target-cell = 
                    {grid.ui.get-cell-at
                        grid.records[self.current-row-index],
                        grid.columns[self.current-column-index]
                    }
             catch ignore:Exception do
            }
            {if-non-null target-cell then
                {grid.ui.set-grid-focus target-cell}
            }
            {if self.current-point >= 0 then
                {type-switch target-cell
                 case sc:StandardBaseEditableStringCell do
                    {type-switch sc.current-editor
                     case tf:BaseTextField do
                        def range = tf.selected-range
                        set range.anchor =
                            {min tf.data-model.size, self.current-anchor}
                        set range.point =
                            {min tf.data-model.size, self.current-point}
                    }
                }
            }
        }
    }
  }

  {doc-next
    {purpose
        Change the current record to the record with the specified {param id}.
    }
  }
  {method public open {focus-record id:int}:void

    {after 0s do
        {for r:Record key ri in self.record-display.records do
            {if r[self.model.id-field] asa int == id then ||""
                {self.record-display.request-current-record-change ri}
                {break}
            }
        }
    }
  }

  {doc-next
    {purpose
        Return the current record from the {docref TreeGrid}
        associated with this command.
    }
  }
  {getter public open {current-record}:#Record
    {return self.record-display.current-record}
  }

  {doc-next
    {purpose
        Given an "ordered record index", that is an index in {docref
        TreeGrid.ordered-records}, return the physical record index
        (an index into the source RecordSet).
    }
  }
  {method public open {map-ori-to-cri ori:int}:int
    def id = self.ordered-records[ori][self.model.id-field] asa int ||""
    {for r:Record key ri in self.record-display.records do
        {if r[self.model.id-field] == id then ||""
            {return ri}
        }
    }
    {return -1}
  }

  {doc-next
    {purpose
        Given a physical record index (an index into the source
        RecordSet), return an "ordered record index", that is an index
        in {docref TreeGrid.ordered-records}.
    }
  }
  {method public open {map-cri-to-ori cri:int}:int
    def id = self.record-display.records[cri][self.model.id-field] asa int ||""
    {for r:Record key ri in self.model.ordered-records do
        {if r[self.model.id-field] == id then ||""
            {return ri}
        }
    }
    {return -1}
  }

||--  {getter public open {current-index}:int
||--    {return self.map-cri-to-
||--    def cid = self.current-record[self.model.id-field] asa int ||""
||--    {for r:Record key ri in self.model.ordered-records do
||--        {if r[self.model.id-field] == cid then ||""
||--            {return ri}
||--        }
||--    }
||--    {return -1}
||--||--    {return self.record-display.current-index}
||--  }

||--  {getter public open {tree-records}:RecordSet
||--    def trv = self.record-display.record-source asa RecordView
||--    {return (trv.source asa RecordSetTreeModel).source}
||--  }

  {doc-next
    {purpose
        Return the {docref RecordSetTreeModel.ordered-records} from the
        {docref TreeGrid} that this command is operating on.
    }
  }
  {getter public open {ordered-records}:RecordView
    {return self.model.ordered-records}
  }

  {doc-next
    {purpose
        Count the number of records that represent the node at ni and
        its children.
    }
  }
  {method public open {count-node-and-children ni:int}:int
    def orecs = self.ordered-records
    def count = 
        (orecs[ni]["_rn"] asa int - orecs[ni]["_ln"] asa int + 1) div 2 ||""
    {return count}
  }

  {doc-next
    {purpose
        Find the parent of the specified dept of the node at node-index.
    }
  }
  {method public open {find-parent-node ni:int, level:int}:int
    def orecs = self.ordered-records
    {if ni < orecs.size and ni >= 0 then
        def nd = orecs[ni]["_depth"] asa int ||""
        {if nd < level then 
            {return -1}
        }
        {for i = ni downto 0 do
            def d = orecs[i]["_depth"] asa int ||""
            {if d == level then
||--                {dump ni, i}
                {return i}
            }
        }
    }
    {return -1}
  }

}

{doc-next
    {purpose
        A {docref TreeGridCommand} that will indent the current node by
        one level. This command is disabled if the node above is not
        a sibling in the tree.
    }
}
{define-class public open IndentNodeCommand {inherits TreeGridCommand}

  {doc-next
    {purpose Construct an {ctext IndentNodeCommand} with the name
        {ctext "Tree.indent-node"}.
    }
  }
  {constructor public {default grid:TreeGrid}
    {construct-super "Tree.indent-node", grid} ||""
  }
  
  {doc-next
    {purpose
        The command is enabled if the current node has a prior sibling.
    }
  }
  {getter public open {enabled?}:bool
    || You can indent as long as there is a sibling above you
    {if-non-null cr = self.current-record then
        def pri = self.record-display.current-index - 1
        {if pri >= 0 then
            def pr = self.record-display.records[pri]
            {return pr[RecordSetTreeModel.parent-id-field] == cr[RecordSetTreeModel.parent-id-field]
                or pr["_depth"] == cr["_depth"] asa int + 1 ||""
            }
        }
    }
    {return false}
  }

  {doc-next
    {purpose
        Indent the current node by one level.
    }
  }
  {method protected open {execute}:void
    {if-non-null cr = self.record-display.current-record then
        def cri = self.record-display.current-index
        def crid = cr[self.model.id-field] asa int ||""
        {self.commit-current-cell}
        {if cri > 0 then
            set self.grid.filter = null
            {with self.model.source.batch-events? = true do
                def pri = cri - 1
                def pr = self.record-display.records[pri]
                set pr["_expand?"] = true ||""
                {if pr["_depth"] == cr["_depth"] asa int + 1 then ||""
                    set cr[RecordSetTreeModel.parent-id-field] =
                        pr[RecordSetTreeModel.parent-id-field]
                 else
                    set cr[RecordSetTreeModel.parent-id-field] =
                        pr[self.model.id-field]
                }
            }
        }
        {self.refocus-current-cell crid}
||--        {if-non-null cell = current-cell then
||--            {self.focus-record crid}
||--            {after 0s do
||--                {cell.grid.ui.set-grid-focus cell}
||--            }
||--        }
    }
  }
}

{doc-next
    {purpose
        A {docref TreeGridCommand} that will un-indent the current
        node by one level. This command is disabled if the node is
        a root node.
    }
}
{define-class public open UndentNodeCommand {inherits TreeGridCommand}

  {doc-next
    {purpose Construct an {ctext UndentNodeCommand} with the name
        {ctext "Tree.unindent-node"}.
    }
  }
  {constructor public {default grid:TreeGrid}
    {construct-super "Tree.unindent-node", grid} ||""
  }
  
  {doc-next
    {purpose
        The command is enabled as long as the current node has a parent.
    }
  }
  {getter public open {enabled?}:bool
    || You can unindent as long as you have a parent
    {if-non-null cr = self.record-display.current-record then
        {return cr["_depth"] != 0} ||""
    }
    {return false}
  }

  {method protected open {execute}:void
    {if-non-null cr = self.record-display.current-record then
        set self.grid.filter = null
        def ocri = {self.map-cri-to-ori self.record-display.current-index}
        def orecs = self.ordered-records
        def crid = cr[self.model.id-field] asa int ||""
        def pi = {self.find-parent-node ocri, cr["_depth"] asa int - 1} ||""
        def np = {self.count-node-and-children pi}   || parent and sibs
        def nc = {self.count-node-and-children ocri} || children to be moved
        def ns = np - nc || number staying put
        {with self.model.source.batch-events? = true do
            {self.commit-current-cell}
            def pr = orecs[pi]
            || make it a sibling of it's parent
            set cr[RecordSetTreeModel.parent-id-field] =
                pr[RecordSetTreeModel.parent-id-field]
            || Move other siblings up
            {for i = ocri + nc below pi + np do
                set orecs[i][self.pos-field] = 
                    orecs[i][self.pos-field] asa int - nc
            }
            || Move current and children below parent and children
            def nb = (pi + np) - (ocri + nc)
            {for i = ocri below ocri + nc do
                set orecs[i][self.pos-field] =
                    orecs[i][self.pos-field] asa int + nb
            }
        }
        {self.refocus-current-cell crid}
    }
  }
}

{doc-next
    {purpose
        Delete the current node, including children.
    }
}
{define-class public open DeleteNodeCommand {inherits TreeGridCommand}

  {doc-next
    {purpose
        If true, display a confirmation dialog before deleting a node
        and its children.
    }
  }
  field public warn?:bool = false

  {doc-next
    {purpose Construct an {ctext DeleteNodeCommand} with the name
        {ctext "Tree.delete-node"}.
    }
  }
  {constructor public {default grid:TreeGrid}
    {construct-super "Tree.delete-node", grid} ||""
  }
  
  {doc-next
    {purpose
        The current node can always be deleted, so return true if
        there is a current node.
    }
  }
  {getter public open {enabled?}:bool
    || You can indent as long there is a current node.
    {if-non-null cr = self.record-display.current-record then
        {return true}
    }
    {return false}
  }

  {doc-next
    {purpose
        Delete the current node (and children).
    }
  }
  {method protected open {execute}:void
    {if-non-null cr = self.current-record then
        || Seems OK to keep filter, if any
        def cri = self.record-display.current-index
        def ocri = {self.map-cri-to-ori cri}
        def orecs = self.ordered-records
        def nd = {self.count-node-and-children ocri}
        {if nd > 1 and self.warn? then
            {if {popup-question
                    title = {hlmessage Delete Items},
                    {hlmessage 
                        Delete this item and its children?
                    }
                } != Dialog.yes
             then
                {return}
            }
        }
        {with self.model.source.batch-events? = true do
            || No need to commit pending change, since it will be deleted
            {for i = ocri + nd below orecs.size do
                set orecs[i][self.pos-field] =
                    (orecs[i][self.pos-field] asa int) - nd
            }
            {for i = 0 below nd do
                {orecs[ocri + i].delete}
            }
            || Focus on the same index as before, never mind the id
            {after 0s do
                def tri = {min cri, self.record-display.records.size - 1}
                {self.focus-record
                    self.record-display.records[tri][self.model.id-field] asa int ||""
                }
            }
        }
    }
  }
}


{doc-next
    {purpose
        A {docref TreeGridCommand} that will create a new node as a sibling
        of the current node.
    }
}
{define-class public open AddNodeCommand {inherits TreeGridCommand}

  {doc-next
    {purpose Construct an {ctext AddNodeCommand} with the name
        {ctext "Tree.add-node"}.
    }
  }
  {constructor public {default
                          grid:TreeGrid,
                          name:String = "Tree.add-node" ||""
                      }
    {construct-super name, grid}
  }
  
  {doc-next
    {purpose Return true if there is a current node. }
  }
  {getter public open {enabled?}:bool
    {if-non-null cr = self.record-display.current-record then
        {return true}
    }
    {return true}
  }

  {doc-next
    {purpose Add a sibling to the current node.}
  }
  {method protected open {execute}:void
    set self.grid.filter = null
    {if self.model.ordered-records.size == 0 then
        || First node
        {with self.model.source.batch-events? = true do
            def nr = {self.model.source.new-record}
            set nr[RecordSetTreeModel.parent-id-field] = 0
            set nr[self.pos-field] = 1
            {self.model.source.append nr}
            {self.refocus-current-cell nr[self.model.id-field] asa int} ||""
        }
        {return}
    }
    {if-non-null cr = self.record-display.current-record then
        let crid:int = cr[self.model.id-field] asa int ||""
        def ocri = {self.map-cri-to-ori self.record-display.current-index}
        def orecs = self.ordered-records
        def nc = {self.count-node-and-children ocri}
        {with self.model.source.batch-events? = true do
            {self.commit-current-cell}
            {for i = ocri + nc below orecs.size do
                set orecs[i][self.pos-field] =
                    (orecs[i][self.pos-field] asa int) + 1
            }
            def nr = {self.model.source.new-record}
            set nr[RecordSetTreeModel.parent-id-field] =
                cr[RecordSetTreeModel.parent-id-field]
            set nr[self.pos-field] = cr[self.pos-field] asa int + nc
            {self.model.source.append nr}
            {self.refocus-current-cell nr[self.model.id-field] asa int}
        }
    }
  }
}

{doc-next
    {purpose
        Create a new node with current node as it's parent
    }
}
{define-class public open AddChildNodeCommand {inherits TreeGridCommand}

  {doc-next
    {purpose Construct an {ctext AddChildNodeCommand} with the name
        {ctext "Tree.add-child-node"}
    }
  }
  {constructor public {default 
                          grid:TreeGrid,
                          name:String = "Tree.add-child-node" ||""
                      }
    {construct-super name, grid}
  }
  
  {doc-next
    {purpose
        The command is enabled as long as there is a current node.
    }
  }
  {getter public open {enabled?}:bool
    || You can do this as long as there is a current node.
    {if-non-null cr = self.record-display.current-record then
        {return true}
    }
    {return false}
  }

  {doc-next
    {purpose
        Create a new node with current node as it's parent
    }
  }
  {method protected open {execute}:void
    {if-non-null cr = self.record-display.current-record then
        set self.grid.filter = null
        def ocri = {self.map-cri-to-ori self.record-display.current-index}
        def orecs = self.ordered-records
        let crid:int = cr[self.model.id-field] asa int ||""
        {with self.model.source.batch-events? = true do
            {self.commit-current-cell}
            {for i = ocri + 1 below orecs.size do
                set orecs[i][self.pos-field] =
                    (orecs[i][self.pos-field] asa int) + 1
            }
            def nr = {self.model.source.new-record}
            set nr[RecordSetTreeModel.parent-id-field] =
                cr[self.model.id-field]
            set nr[self.pos-field] = cr[self.pos-field] asa int + 1
            set cr["_expand?"] = true ||""
            {self.model.source.append nr}
            {self.refocus-current-cell nr[self.model.id-field] asa int}
        }
    }
  }
}

{doc-next
    {purpose Exchange this node with it's prior sibling, if any.}
}
{define-class public open MoveNodeUpCommand {inherits TreeGridCommand}

  {doc-next
    {purpose Construct a {ctext MoveNodeUpCommand} with the name
        {ctext "Tree.move-node-up"}.
    }
  }
  {constructor public {default grid:TreeGrid}
    {construct-super "Tree.move-node-up", grid} ||""
  }
  
  {doc-next
    {purpose
        The command is enabled as long as the current node has a sibling
        before it.
    }
  }
  {getter public open {enabled?}:bool
    || You can move up as long as there is a sibling above
    {if-non-null cr = self.current-record then
        set self.grid.filter = null
        def ocri = {self.map-cri-to-ori self.record-display.current-index}
        {if ocri > 0 then
            def orecs = self.ordered-records
            def nai = {self.find-parent-node ocri - 1, cr["_depth"] asa int} ||""
            {return nai >= 0}
        }
    }
    {return false}
  }
 
  {doc-next
    {purpose Exchange this node with it's prior sibling.}
  }
  {method protected open {execute}:void
    {if-non-null cr = self.current-record then
        set self.grid.filter = null
        def ocri = {self.map-cri-to-ori self.record-display.current-index}
        def orecs = self.ordered-records
        def crid = cr[self.model.id-field] asa int ||""
        def nu = {self.count-node-and-children ocri}
        def nai = {self.find-parent-node ocri - 1, cr["_depth"] asa int} ||""
        {if nai >= 0 then
            let nd:int = {self.count-node-and-children nai}
            {with self.model.source.batch-events? = true do
                {self.commit-current-cell}
                || Move current node and children up
                {for i = 0 below nu do
                    def ni = ocri + i
                    set orecs[ni][self.pos-field] =
                        orecs[ni][self.pos-field] asa int - nd
                }
                || Move previous node and children down
                {for i = 0 below nd do
                    def ni = nai + i
                    set orecs[ni][self.pos-field] =
                        orecs[ni][self.pos-field] asa int + nu
                }
                {self.refocus-current-cell crid}
            }
        }
    }
  }
}

{doc-next
    {purpose Exchange this node with it's next sibling, if any.}
}
{define-class public open MoveNodeDownCommand {inherits TreeGridCommand}

  {doc-next
    {purpose Construct a {ctext MoveNodeDownCommand} with the name
        {ctext "Tree.move-node-doen"}.
    }
  }
  {constructor public {default grid:TreeGrid}
    {construct-super "Tree.move-node-down", grid} ||""
  }
  
  {doc-next
    {purpose
        The command is enabled as long as the current node has a sibling
        below it.
    }
  }
  {getter public open {enabled?}:bool
    || You can move down as long as there is a sibling below
    {if-non-null cr = self.current-record then
        def ocri = {self.map-cri-to-ori self.record-display.current-index}
        def orecs = self.ordered-records
        def nd = {self.count-node-and-children ocri}
        {if ocri + nd < orecs.size then
            {return orecs[ocri][RecordSetTreeModel.parent-id-field] == orecs[ocri + nd][RecordSetTreeModel.parent-id-field]}
        }
    }
    {return false}
  }
 
  {doc-next
    {purpose Exchange this node with it's next sibling.}
  }
  {method protected open {execute}:void
    {if-non-null cr = self.current-record then
        set self.grid.filter = null
        def ocri = {self.map-cri-to-ori self.record-display.current-index}
        def orecs = self.ordered-records
        def crid = cr[self.model.id-field] asa int ||""
        def nd = {self.count-node-and-children ocri}
        {with self.model.source.batch-events? = true do
            {self.commit-current-cell}
            || Move sibling & child nodes up
            let nu:int = {self.count-node-and-children ocri + nd}
            {for i = 0 below nu do
                def ni = ocri + nd + i
                set orecs[ni][self.pos-field] =
                    orecs[ni][self.pos-field] asa int - nd
            }
            {for i = 0 below nd do
                set orecs[ocri + i][self.pos-field] =
                    orecs[ocri + i][self.pos-field] asa int + nu
            }
            {self.refocus-current-cell crid}
        }
    }
  }
}

{doc-next
    {purpose Command for moving nodes using drag and drop.}
}
{define-class public open MoveNodeCommand 
  {inherits TreeGridCommand, MoveRecordParams}

  ||FIXME: should be Tree.dragdrop?
  {doc-next
    {purpose Construct a {ctext MoveNodeCommand} with the name
        {ctext "dragdrop"}.
    }
  }
  {constructor public {default grid:TreeGrid}
    {construct-super.TreeGridCommand "dragdrop", grid} ||""
  }
  
  {doc-next
    {purpose
        The command is enabled if a node is about to be dropped
        onto another.
    }
  }
  ||FIXME: You can drop onto a different treegrid! At least make sure the
  || fields are the same.
  {getter public open {enabled?}:bool
    {return self.from-rec != null and self.to-rec != null}
  }
 
  ||DEBUG
  {method private {show-recs name:String, recs:{Array-of Record}}:void
    def ords:StringBuf = {StringBuf}
    {for r key ri in recs do
        {if ri > 0 then {ords.concat ", "}} ||""
        {ords.concat {format "%d", r[RecordSetTreeModel.pos-field]}} ||""
    }
    {dump name, ords}
  }

  {doc-next
    {purpose Move a node.}
  }
  {method protected open {execute}:void

    || Find the primary RecordSet to suppress events
    let rs:#RecordSet = null
    {if-non-null r = self.to-rec then
        set rs = r.record-set
        {while rs isa RecordView do
            set rs = (rs asa RecordView).source
        }
    }

    {if-non-null 
        rs, to-rec = self.to-rec, from-rec = self.from-rec,
        cr = self.current-record
     then
        def crid = cr[self.model.id-field] asa int ||""
        def orecs = self.ordered-records
        {with rs.batch-events? = true do
            {self.commit-current-cell}

            || Select the records to be moved
            let target:#Record = to-rec
            let tid:int = to-rec[self.model.id-field] asa int ||""
            let pid:int = target[RecordSetTreeModel.parent-id-field] asa int
||--            {dump tid, pid, self.before?}
            {if not self.before? then
                {if to-rec["_expand?"] == false then ||""
                    def targets = {self.model.node-and-children to-rec}
                    set target = targets[targets.size - 1]
||--                    {self.show-recs "targets", targets} ||""
                }
                {for r:Record key ri in orecs do
                    {if r[self.model.id-field] == target[self.model.id-field] then ||""
                        {if ri < orecs.size - 1 then
                            set target = orecs[ri + 1]
                            set tid = target[self.model.id-field] asa int ||""
                            set pid =
                                target[RecordSetTreeModel.parent-id-field] asa int
                            || When dropped after last sibling, use sib's pid
                            {if ri >= 0
                                and orecs[ri]["_depth"] asa int ||""
                                > target["_depth"] asa int ||""
                             then
                                set pid =
                                    orecs[ri][RecordSetTreeModel.parent-id-field] asa int
                            }
                         else
                            set target = null
                            set tid = 0
                            set pid =
                                orecs[orecs.size - 1][RecordSetTreeModel.parent-id-field] asa int
                        }
                        {break}
                    }
                }
            }

            def moving = {self.model.node-and-children from-rec}
            def from-ln = from-rec["_ln"] asa int ||""
            def from-rn = from-rec["_rn"] asa int ||""
            def fixed =
                {if target != null and
                    target[self.model.id-field] == from-rec[self.model.id-field]
                 then
                    {new {Array-of Record}}
                 else
                    {orecs.select
                        filter =
                            {proc {r:Record}:bool
                                {return r["_ln"] asa int < from-ln ||""
                                    or r["_ln"] asa int > from-rn  ||""
                                }
                            }
                    }
                }
||--            {self.show-recs "fixed", fixed} ||""

            let nord:int = 1
            let fri:int = 0
            {while fri < fixed.size do
                {if fixed[fri][self.model.id-field] == tid then
                    {break}
                }
                set fixed[fri][self.pos-field] = nord
                {inc nord}
                {inc fri}
            }
            {for r:Record key ri in moving do
                {if ri == 0 then
                    set r[RecordSetTreeModel.parent-id-field] = pid
                }
                {if fixed.size > 0 then
                    set r[self.pos-field] = nord
                    {inc nord}
                }
            }
            {while fri < fixed.size do
                set fixed[fri][self.pos-field] = nord
                {inc nord}
                {inc fri}
            }

||--            {after 0s do
||--                {self.cell.grid.ui.set-grid-focus self.cell}
||--            }
            {self.refocus-current-cell crid}
        } || with batch-events? = true
    }
  }

}

{doc-next
    {purpose Command for saving the state of the tree.}
}
{define-class public open TreeSaveCommand {inherits TreeGridCommand}

  {doc-next
    {purpose Construct a {ctext TreeSaveCommand} with the name
        {ctext "Tree.save"}.
    }
  }
  {constructor public {default grid:TreeGrid}
    {construct-super "Tree.save", grid} ||""
  }
  
  {doc-next
    {purpose
        Return true if there has been a change to the model since it
        was last saved.
    }
  }
  {getter public open {enabled?}:bool
    {return
        super.enabled? and
        (self.record-display.records.pending-update?
         or
         self.grid.model.source.file-changed?
        )
    }
  }
 
  {doc-next
    {purpose Save the model.}
  }
  {method protected open {execute}:void
    {if-non-null cr = self.current-record then
        def crid = cr[self.model.id-field] asa int
        {self.commit-current-cell}
        {self.record-display.records.commit}
        {self.refocus-current-cell crid}
    }
  }
}

{doc-next
    {purpose
        Return an array of standard menu items for manipulating a
        {docref TreeGrid}.
    }
}
{define-proc public {get-treegrid-menu-items tree-grid:TreeGrid}:{Array-of any}
    {return 
        {new {Array-of any},
            {MenuAction
                key-accel-string = "ctrl-n", ||""
                label = {lmessage Add &Item},
                bound-command = {tree-grid.get-command "Tree.add-node"} ||""
            },
            {MenuAction
                key-accel-string = "ctrl-j", ||""
                label = {lmessage Add &Child},
                bound-command = 
                    {tree-grid.get-command "Tree.add-child-node"} ||""
            },
            {MenuAction
                key-accel-string = "delete", ||""
                label = {lmessage &Delete},
                bound-command = {tree-grid.get-command "Tree.delete-node"} ||""
            },
            {menu-separator},
            {MenuAction
                key-accel-string = "ctrl-up", ||""
                label = {lmessage Move &Up},
                bound-command = {tree-grid.get-command "Tree.move-node-up"} ||""
            },
            {MenuAction
                key-accel-string = "ctrl-down", ||""
                label = {lmessage Move &Down},
                bound-command = 
                    {tree-grid.get-command "Tree.move-node-down"} ||""
            },
            {MenuAction
                key-accel-string = "ctrl-right", ||""
                label = {lmessage &Indent},
                bound-command = {tree-grid.get-command "Tree.indent-node"} ||""
            },
            {MenuAction
                key-accel-string = "ctrl-left", ||""
                label = {lmessage &Unindent},
                bound-command = {tree-grid.get-command "Tree.unindent-node"} ||""
            }
        }
    }
}


{doc-next
    {purpose
        Display data in a {docref RecordSet} as a tree with many columns.
    }
}
{define-class public open TreeGrid {inherits RecordGrid}

  ||FIXME: The sort-spec should sort records grouped by parent node.
  || You can set the column.sort-spec = null to disable sorting, or
  || set it to a specialized proc to do a tree-sensitive sort
  
  {doc-next
    {purpose The {docref RecordSetTreeModel} associated with 
        this {docref TreeGrid}.
    }
  }
  field protected _model:RecordSetTreeModel

  {doc-next
    {purpose Supply the data to be displayed in this {docref TreeGrid}.}
  }
  {setter public open {model v:RecordSetTreeModel}:void
    set self._model = v
    set self.record-source = v.display-records
  }

  {doc-next
    {purpose
        Return the {docref RecordSetTreeModel} associated with this
        {docref TreeGrid}.
    }
  }
  {getter public open {model}:RecordSetTreeModel
    {return self._model}
  }

  {doc-next
    {purpose
        The procedure that should be called to create an icon for a cell.
    }
  }
  field protected icon-proc:#{proc-type 
                               {cell:RecordGridCell,
                                state:DisclosureState
                               }:Pixmap
                             }
  {doc-next
    {purpose
        The procedure that should be called to create the label for a cell.
    }
  }
  field protected item-proc:#{proc-type
                               {cell:RecordGridCell}:Graphic
                             }

  {doc-next
    {purpose
        Indicates whether or not the tree can be rearranged using
        drag and drop.
    }
  }
  field public-get protected-set draggable-items?:bool = true

  field protected _base-filter:#RecordFilter = null

  {setter public open {filter value:#RecordFilter}:void
    set self._base-filter = value
    {if-non-null value then
        set super.filter = {TreeRecordFilter self, value}
     else
        set super.filter = null
    }
  }

  {doc-next
    {purpose
        Create a {docref TreeGrid}.
    }
    {parameter model, The data model. Provides the tree structure and
        information to be displayed in the {docref TreeGrid}.
    }
    {parameter filter, Provides the initial value for {docref TreeGrid.filter}.
    }
    {parameter header-options,
        Options for the header row. See {docref-abbr
        RecordGrid.header-options}.
    }
    {parameter ui-object, An alternative
        The UI delegate that handles drawing and events.
    }
    {parameter icon-proc,
        Provides the initial value for {docref TreeGrid.icon-proc}.
    }
    {parameter item-proc,
        Provides the initial value for {docref TreeGrid.item-proc}.
    }
  }
  {constructor public {default
                          model:RecordSetTreeModel,
                          filter:#RecordFilter = null,
                          header-options:RecordGridRowOptions =
                              {RecordGridRowOptions},
                          ui-object:#RecordGridUI = null,
                          draggable-items?:bool = true,
                          icon-proc:#{proc-type 
                                         {cell:RecordGridCell,
                                          state:DisclosureState
                                         }:Pixmap
                                     } = null,
                          item-proc:#{proc-type
                                         {cell:RecordGridCell}:Graphic
                                     } = null,
                          ...
                      }
    set self._model = model
    set self.draggable-items? = draggable-items?
    set self.icon-proc = icon-proc
    set self.item-proc = item-proc
    {construct-super
        record-source = model.display-records,
        filter = filter,
        header-options = header-options,
        ui-object = ui-object,
        display-navigation-panel? = false,
        display-filler-column? = true,
        {splice ...},
        sort = RecordSetTreeModel.pos-field,
        key-spec = RecordSetTreeModel.pos-field
    }
  }

  {method public open {create-command name:String}:#Command
    || Create one of the tree commands if requested
    {return
        {switch name
         case "Tree.indent-node" do
            {IndentNodeCommand self}
         case "Tree.unindent-node" do
            {UndentNodeCommand self}
         case "Tree.move-node-down" do
            {MoveNodeDownCommand self}
         case "Tree.move-node-up" do
            {MoveNodeUpCommand self}
         case "Tree.add-node" do
            {AddNodeCommand self}
         case "Tree.add-child-node" do
            {AddChildNodeCommand self}
         case "Tree.delete-node" do
            {DeleteNodeCommand self}
         case "dragdrop" do || Command name used by RecordMover
            {MoveNodeCommand self}
         case "Tree.save" do
            {TreeSaveCommand self}
         else
            {super.create-command name}
        }
    }
  }

}

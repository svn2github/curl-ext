||| Copyright 1998-2010, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.
|||
||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.
||| ----------------------------------------------------------------------------

{curl 7.0 package}

{doc type = package, COM.CURL.EXT.DATA-ACCESS
    {purpose
        Extensions for data access, including domains, {docref
        RecordGridCell}s, {docref RecordSet}s, etc.
    }
}


{package COM.CURL.EXT.DATA-ACCESS,
    resource-directory = "curl://install/curl-resources", ||""
    translations-file = "translations.ctd", ||""
    default-locale = "en", ||""
    version = "1.0", ||""
    {compiler-directives stringent? = true}
}

{import * from CURL.LANGUAGE.FORMAT}
{import * from CURL.GUI.STANDARD}
{import * from CURL.DATA-ACCESS.BASE}
{import * from CURL.DATA-ACCESS.CONNECTED} || for TransientAnyDomain
{import * from CURL.LANGUAGE.SOURCE}
{import * from CURL.LANGUAGE.REGEXP}
{import * from CURL.GUI.CONTROL-HELPERS}
{import * from CURL.UTIL.OBSERVER}
{import * from CURL.IO.JSON}

{import * from COM.CURL.EXT.GUI}

{include "treegrid.scurl"} ||""
{include "recordset-ext.scurl"} ||""

|| ------------------------------------------------------------------------

|| --------
|| Domains
|| --------

{doc-next
    {purpose {docref Domain} for double values with fixed precision and
        commas separators for large values.
    }
}
{define-class public open NumberDomain
  {inherits {StandardDomain-of double}}
  
  field public comma-formatter:NumberFormatter =
      {NumberFormatter locale = {get-host-locale}, use-grouping? = true}

  {doc-next
    {purpose The number of decimal places to be used when formatting
        a value as a string.  If negative, it specifies the number of
        places after the decimal point. If positive, it specifies the
        number of significant digits.
    }
  }
  field public constant precision:int

  {doc-next 
    {purpose Construct this object.}
    {parameter default-value, provides the initial value for
        {docref-abbr DoubleDomain.default-value}
    }
    {parameter min-allowable, provides the initial value for
        {docref-abbr Domain.min-allowable}
    }
    {parameter max-allowable, provides the initial value for
        {docref-abbr Domain.max-allowable}
    }
    {parameter precision, provides the initial value for
        {docref-abbr DoubleDomain.precision}
    }
    {parameter allowable-values, provides the initial value for
            {docref-abbr Domain.allowable-values}
    }
  }
  {constructor public {default
                          default-value:any = 0.0,
                          min-allowable:any = null,
                          max-allowable:any = null,
                          precision:int = -5,
                          use-grouping?:bool = true,
                          allowable-values:#{Array-of double} = null
                      }
    {construct-super 
        default-value, 
        min-allowable, 
        max-allowable, 
        allowable-values
    }
    set self.precision = precision
    {if precision < 0 then
        set self.comma-formatter.min-fraction-digits = -precision
     else
        set self.comma-formatter.min-precision = precision
    }
  }


  {method public open {parse x:String}:any
    let str:String = {x.trim-clone}
    let (val:double, n:int) = 
        {try
            {str.to-double}
         catch e:Exception do
            {throw {ValidationException e.message}}
        }
    {if not str.empty? and n == str.size then
        {return val}
    }
    {return {super.parse x}}
  } 
  
  {method public open {format x:any}:String
    def fs = {self.comma-formatter.format x asa double}
    {return fs}
  }

  {method public open {compare x:any, y:any}:int
    {if {nan? x asa double} then
        {if {nan? y asa double} then
            {return 0}
         else
            {return 1}
        }
     elseif {nan? y asa double} then
        {return -1}
    }
    {return {signum (x asa double) - (y asa double)} asa int}
  }
}


{doc-next
    {purpose A domain that can be used on a {docref RecordField}
        that is type any and not persisted with the record.
    }
}
{def public transient-domain = {TransientAnyDomain}}

{doc-next
    {purpose A domain that can be used on a {docref RecordField}
        that represents a date.
    }
}
{def public date-domain = {StandardDateDomain}}


{doc-next 
    {purpose A {docref Domain} for time duration values.}  
    {details This {docref Domain} is suitable for time durations, such
        as the difference between two dates or times. Unlike
        {docref StandardTimeDomain}, it supports time amounts
        longer than 24 hours.
    }
}
{define-class public open DurationDomain
  {inherits {StandardDomain-of Time}}

  {doc-next 
    {purpose Return a domain suitable for representing a time
        duration measured in seconds.
    }
  }
  {constructor public {default
                          default-value:any = 0s,
                          min-allowable:any = null,
                          max-allowable:any = null,
                          allowable-values:#{Array-of Time} = null
                      }
    {construct-super 
        default-value, 
        min-allowable, 
        max-allowable, 
        allowable-values
    }
  }

  {method public open {parse x:String}:any
    let str:String = {x.trim-clone}
    {if str.empty? then
        {return self.default-value}
    }
    let r:any = null
    let ok?:bool = true
    {try
        {syntax-switch {CurlSource.from-string str}, must-match?=false
         case {pattern ?t:{literal Time}} do
            set r = t.value asa Time
         else
            set r = {DateTime str, zone=DateTimeZone.utc} -
            {DateTime hour=0, zone=DateTimeZone.utc}
        }
     catch e:Exception do
        {throw
            {ValidationException 
                {hlformat
                    "Unable to parse '%1!s!' as a time value.", x
                }
            }
        }
    }
    {return r}
  }  

  {method public open {format x:any}:String 
    let t:Time = x asa Time
    def days?:bool = (t mod 1d) == 0.0s
    {if t < 1min then
        {return {format "%ss", t/1s}} ||""
     elseif t < 1h then
        {return {format "%smin", t/1min}} ||""
     elseif t < 1d then
        {return {format "%sh", t/1h}} ||""
     elseif t < 32d and days? then
        {return {format "%sd", t/1d}} ||""
     else
        {return {format "%sd", t/1d}} ||""
    }
  }
  
  {method public open {compare x:any, y:any}:int
    {return {signum (((x asa Time) - (y asa Time))/1s)} asa int}
  }
  
  {method public open {hash x:any}:int
    {return ((x asa Time)/1s) asa int}
  }  
}

{doc-next
    {purpose
        An instance of {docref DurationDomain} usually used for defining
        a {docref RecordField}.
    }
}
{def public duration-domain = {DurationDomain}}

|| ------------------------------------------------------------------------

{define-class public open LocaleDateDomain
  {inherits {StandardDomain-of #DateTime}}

||--  {doc-next
||--    {purpose
||--        A place to store the default value, since the {docref
||--        StandardDomain} cannot have a null default value,
||--    }
||--  }
||--  field protected _local-default-value:any = null

||--  {getter public open {default-value}:any
||--    {return self._local-default-value}
||--  }

  {doc-next
    {purpose Construct this object.}
    {parameter
        default-value, A default value for this domain, which can be null.
    }
    {parameter
        allowable-values, See {docref Domain.allowable-values}.
    } 
  }
  {constructor public {default
                          default-value:any = null,
                          min-allowable:any = null,
                          max-allowable:any = null,
                          allowable-values:#{Array-of #DateTime} = null
                      }
    {construct-super 
        default-value,
        min-allowable,
        max-allowable,
        allowable-values
    }
||--    set self._local-default-value = default-value
  }
  
  {method package {_wrong-type-exception x:any}:ValidationException
    {return
        {ValidationException 
            {hlformat
                "Wrong type '%1!s!' for '%2!s!'",
                {type-of x},
                {type-of self}
            }
        }
    }
  }

  || Override to normalize the converted value
  {method public open {convert val:any}:any
    let ret:any = null
    {if-non-null val then
        {type-switch val 
         case str:String do
            set ret = {self.parse str}
         case v:Object do
            {try 
                set ret = {DateTime.date v}
             catch ce:CastException do
                {throw {self._wrong-type-exception val}}
            }
         else
            {throw {self._wrong-type-exception val}}
        }
    }
    {return ret}
  }

  
  {method public open {parse x:String}:any
    
    {if x == "" then
        {return null}
    }
    let dt:#DateTime = null
    {if not x.empty? then
        {try
            set dt = {DateTime.date x}
         catch e:Exception do
        }
    }
    {if dt == null then
        {throw
            {ValidationException
                {hlmessage 
                    {value {type-of self}} failed to parse String:
                    '{value x}'.
                }
            }
        }
    }
    {return {unchecked-non-null dt}}
  }
  
  {method public open {format x:any}:String 
    {if-non-null x then
        {return (x asa DateTime).info.locale-date}
     else
        {return ""}
    }
  }
  
  
  {method public open {compare x:any, y:any}:int
    let xdt:DateTime = x asa DateTime
    let ydt:DateTime = y asa DateTime
    
    {return
        {if xdt.info.year == ydt.info.year and
            xdt.info.day-of-year == ydt.info.day-of-year
         then
            0
         else
            {xdt.compare ydt}
        }
    }
  }


  {method public open {hash x:any}:int
    let xdt:DateTime = x asa DateTime
    {return xdt.info.year + xdt.info.day-of-year}
  }

}

{let public constant locale-date-domain:LocaleDateDomain = {LocaleDateDomain}}

|| ------------------------------------------------------------------------

{doc-next
    {purpose A domain for {ctext double} values where the precision used
        to format the value as a String can be specified.
    }
    {details
        This domain is designed for use with {docref RecordSet}s where
        numeric values are to be displayed and possibly edited in a
        {docref RecordGrid}. There are several predefined constants
        for commonly used precisions. {docref double-domain} uses the
        default precision of {ctext -5}, which displays 5 digits after
        the decmial point. Constants {docref d2-domain}, {docref
        d3-domain}, and {docref d4-domain} provide 2, 3, and 4 digits
        respectively.
    }
}
{define-class public open DoubleDomain
  {inherits {StandardDomain-of double}}
  
  {doc-next
    {purpose The number of decimal places to be used when formatting
        a value as a string.  If negative, it specifies the number of
        places after the decimal point. If positive, it specifies the
        number of significant digits.
    }
  }
  field public constant precision:int

  {doc-next 
    {purpose Construct this object.}
    {parameter default-value, provides the initial value for
        {docref-abbr DoubleDomain.default-value}
    }
    {parameter min-allowable, provides the initial value for
        {docref-abbr Domain.min-allowable}
    }
    {parameter max-allowable, provides the initial value for
        {docref-abbr Domain.max-allowable}
    }
    {parameter precision, provides the initial value for
        {docref-abbr DoubleDomain.precision}
    }
    {parameter allowable-values, provides the initial value for
            {docref-abbr Domain.allowable-values}
    }
  }
  {constructor public {default
                          default-value:any = 0.0,
                          min-allowable:any = null,
                          max-allowable:any = null,
                          precision:int = -5,
                          allowable-values:#{Array-of double} = null
                      }
    {construct-super 
        default-value, 
        min-allowable, 
        max-allowable, 
        allowable-values
    }
    set self.precision = precision
  }


  {method public open {parse x:String}:any
    let str:String = {x.trim-clone}
    let (val:double, n:int) = 
        {try
            {str.to-double}
         catch e:Exception do
            {throw {ValidationException e.message}}
        }
    {if not str.empty? and n == str.size then
        {return val}
    }
    {return {super.parse x}}
  } 
  
  {method public open {format x:any}:String
    def fs = 
        {if self.precision < 0 then
            {format "%%-%s.0%sf", -self.precision,  -self.precision} ||""
         else
            {format "%%.%sg", self.precision} ||""
        }
    {return {format fs, x asa double}}
  }

  {method public open {compare x:any, y:any}:int
    {if {nan? x asa double} then
        {if {nan? y asa double} then
            {return 0}
         else
            {return 1}
        }
     elseif {nan? y asa double} then
        {return -1}
    }
    {return {signum (x asa double) - (y asa double)} asa int}
  }
}

{doc-next
    {purpose
        A domain for double values that formats numbers as strings
        with 5 digits after the decimal point. Useful for specifying
        the domain for a {docref RecordField}.
    }
}
{let public constant double-domain:DoubleDomain = {DoubleDomain}}

{doc-next
    {purpose A domain for double values that formats numbers as strings 
        with 2 digits after the decimal point. Useful for specifying
        the domain for a {docref RecordField}.
    }
}
{let public constant d2-domain:DoubleDomain = {DoubleDomain precision = -2}}

{doc-next
    {purpose A domain for double values that formats numbers as strings 
        with 3 digits after the decimal point. Useful for specifying
        the domain for a {docref RecordField}.
    }
}
{let public constant d3-domain:DoubleDomain = {DoubleDomain precision = -3}}

{doc-next
    {purpose A domain for double values that formats numbers as strings 
        with 4 digits after the decimal point. Useful for specifying
        the domain for a {docref RecordField}.
    }
}
{let public constant d4-domain:DoubleDomain = {DoubleDomain precision = -4}}


|| Note
|| Is it ever useful to change the RecordSet? If so, some code like
|| the following is needed to make sure that any RecordGridCells that
|| reference a ForeignFieldDomain are updated:
||--
||--    {CommandButton
||--        label = "New Foreign Table",
||--        {on Action do
||--            def rs = {make-sample-record-set}
||--            {for r:Record in rs do
||--                set r["name"] = {(r["name"] asa String).to-upper-clone}
||--            }
||--            def fdrs = foreign-domain.rs
||--            set foreign-domain.rs = rs
||--            set rg.record-source = rs
||--            {for r:Record in {non-null fdrs} do
||--                {fdrs.handle-event {RecordModified r}}
||--                {break}
||--            }
||--        }
||--    }

{doc-next
    {purpose
        Domain that scales, formats, and parses currency values.
    }
    {details
        This domain assumes that the value it is used with is an int
        scaled by a factor of 100 so that "penny" amounts are not
        rounded. It uses a {docref NumberFormatter} and 
        {docref NumberParser} for the working locale for parsing
        and formatting values.
    }
}
{define-class public open CurrencyDomain
  {inherits {StandardDomain-of int}}
  
  let public constant formatter:NumberFormatter =
      {NumberFormatter.create-currency-formatter
        locale = {get-working-locale}
      }

  let public constant parser:NumberParser =
      {NumberParser
        allow-grouping? = true,
        allow-exponent? = false,
        whitespace-char-class = {CharClass " $\\\t"}
      }


  {doc-next 
    {purpose Construct this object.}
    {parameter default-value, provides the initial value for
        {docref-abbr DoubleDomain.default-value}
    }
    {parameter min-allowable, provides the initial value for
        {docref-abbr Domain.min-allowable}
    }
    {parameter max-allowable, provides the initial value for
        {docref-abbr Domain.max-allowable}
    }
    {parameter precision, provides the initial value for
        {docref-abbr DoubleDomain.precision}
    }
    {parameter allowable-values, provides the initial value for
            {docref-abbr Domain.allowable-values}
    }
  }
  {constructor public {default
                          default-value:any = 0,
                          min-allowable:any = null,
                          max-allowable:any = null,
                          allowable-values:#{Array-of int} = null
                      }
    {construct-super 
        default-value,
        min-allowable,
        max-allowable,
        allowable-values
    }
  }


  {method public open {parse x:String}:any
    let (val:double, n:int) =
        {try
            {CurrencyDomain.parser.parse-double x}
         catch e:Exception do
            {throw {ValidationException e.message}}
        }
    {if not x.empty? and n == x.size then
        {return {round val * 100}}
    }
    {return {super.parse x}}
  } 
  
  {method public open {format x:any}:String
    {if-non-null x then
        {return {CurrencyDomain.formatter.format (x asa int)/100.0}}
    }
    {return ""}
  }

  {method public open {compare x:any, y:any}:int
    {return {signum (x asa int) - (y asa int)} asa int}
  }
}


{doc-next 
    {purpose A {docref Domain} for a foreign key field.}
    {details 
        This {docref Domain} refers to another {docref RecordSet}
        (or {docref RecordView}) for parsing and formatting the
        values. The value stored in a field is the integer key into
        the foreign table.

        This domain formats the field value as a string of the form
        "name#number" so that if saved to a file, the number can be
        recovered and used. The name is included to make the file
        understandable in case you open it in a spreadsheet or text
        editor. However, if the name is present but the key is
        missing, the key will be recovered from the foreign RecordSet,
        provided that the name is unique.

        When this domain is used, you should also use a {docref
        ForeignKeyCell-for} cell to display the field values in a
        {docref RecordGrid} because it will display the name and
        provide a {docref DropdownList} to choose one of the available
        values (as defined by the foreign table or view).

        FIXME: explain how to use parse/format with a form
    }
}
{define-class public open ForeignFieldDomain
  {inherits {StandardDomain-of int}}

  {doc-next
    {purpose
        The foreign {docref RecordSet} to which this field refers.
    }
  }
  field public-get protected-set rs:#RecordSet

  {doc-next
    {purpose
        The key field in the foreign {docref RecordSet} to which this
        field refers.
    }
  }
  field public key-field:String = "id" ||""

  {doc-next
    {purpose
        The field in the foreign {docref RecordSet} that provides a label
        to use when displaying the foreign field value.
    }
  }
  field public label-field:String = "name" ||""

  {doc-next 
    {purpose Initialize the {docref ForeignFieldDomain} with
        the information it needs to parse and format values.
    }
    {parameter rs, Initial value of {docref ForeignFieldDomain.rs},
        the foreign record set referenced by this object.
    }
    {parameter key-field,
        Initial value of {docref ForeignFieldDomain.key-field},
        the key field in the foreign {docref RecordSet}.
    }
    {parameter label-field,
        Initial value of {docref ForeignFieldDomain.label-field}, the
        field in the foreign {docref RecordSet} that provides a label.
    }
    {parameter default-value,
        Initial value of {docref ForeignFieldDomain.default-value}.
    }
    {parameter allowable-values,
        Initial value of {docref ForeignFieldDomain.allowable-values}.
    }
  }
  {constructor public {default
                          rs:RecordSet,
                          key-field:String,
                          label-field:String,
                          default-value:any = 0,
                          allowable-values:#{Array-of int} = null
                      }
    {construct-super
        default-value,
        null, || min-allowable
        null, || max-allowable
        allowable-values
    }
    set self.rs = rs
    set self.key-field = key-field
    set self.label-field = label-field
  }

  {getter public open {default-value}:any
    {return 0}
  }

  {method public open {parse x:String}:any
    let str:String = {x.trim-clone}
    {if str.empty? then
        {return 0}
    }
    let v:any = null
    let key:String = x
    {if {str.find '#'} > -1 then
        let parts:StringArray = {x.split split-chars = "#"} ||""
        set str = parts[0]
        set key = parts[1]
    }

    let key-len:int
    set (v, key-len) = {key.to-int}

    {if-non-null rs = self.rs then

        || Use the numeric key if available
        {if key-len > 0 then
            def filter = {RecordData}
            set filter[self.key-field] = key
            {if-non-null rec = {rs.select-one filter = filter} then
                set v = rec[self.key-field]
                {return v}
            }
        }

        || If the name is valid and unique, use it
        def filter = {RecordData}
        set filter[self.label-field] = {url-decode-string str}
        let recs:{Array-of Record} = {rs.select filter = filter}
        {if recs.size == 1 then
            def rec = recs[0]
            set v = rec[self.key-field]
            {return v}
        }
    }

    {if key-len > 0 then
        || Return the number even though we can't validate it
        {return v}
     else
        || Otherwise there is an error
        {throw
            {ValidationException 
                {hlformat
                    "Unknown name '%1!s!'", x
                }
            }
        }
    }  
  }

  {method public open {format x:any}:String 
    {type-switch x
     case n:int do
        def filter = {RecordData}
        set filter[self.key-field] = n
        {if-non-null rs = self.rs then
            {if-non-null rec = {rs.select-one filter = filter} then
                {return 
                    {format "%s#%s",  ||""
                        {url-encode-string rec[self.label-field] asa String},
                        rec[self.key-field]
                    }
                }
            }
        }                                            
    }
    {return ""}
  }

  || FIXME: maybe should sort by name?
  {method public open {compare x:any, y:any}:int
    {return {signum (x asa int) - (y asa int)}}
  }
}


|| -----------------
|| RecordGrid Cells
|| -----------------

{doc-next
    {purpose Remove the margins and borders on a UI object.}
    {details
        When a control is used as an editor in a {docref
        RecordGridCell} it is often necessary to reduce the margins
        and borders of the UI object so that it fits within a
        cell. For example, this helper procedure can be called from
        the constructor of a subclass of a {docref
        StandardTextFieldUI} to remove the borders and margins
        introduced by the superclass constructor, reducing the size of
        the UI object to the minimum.
    }
}
{define-proc public {remove-margins-in-ui-object g:Graphic}:void
    {visit-subtree
        g,
        {proc {g:Graphic}:void
            set g.border-width = 0pt
            set g.margin = 0pt
        }
    }
}

|| Helper function for remove-margins-in-ui-object to traverse the GUI hierarchy
{define-proc package {visit-subtree 
                         g:Graphic, 
                         action-proc:{proc-type {Graphic}:void}
                     }:void
    {action-proc g}
    {type-switch g
     case b:Box do
        {for child:Graphic in b.graphical-children do
            {visit-subtree child, action-proc}
        }
    }
}


{doc-next
    {purpose The information needed to move a record using drag and drop.}
}
{define-class public open MoveRecordParams
  {doc-next
    {purpose The record being moved.}
  }
  field public from-rec:#Record

  {doc-next
    {purpose The record being displaced.}
  }
  field public to-rec:#Record

  {doc-next
    {purpose
        Indicates that the moved record is to be inserted before (above)
        the destination record. If false, it is inserted below.
    }
  }
  field public before?:bool

  {doc-next
    {purpose Initialize a new {docref MoveRecordParams}.}
  }
  {constructor public {default}
  }
}

{doc-next
    {purpose A Graphic that can be inserted into a custom {docref 
        RecordGridCell} to support rearranging records via drag and drop.
    }
    {details
        This class was designed for use in {docref TreeGrid}.  It
        requires that the records being moved have an integer field
        that determines the order in which the records appear in
        the {docref RecordGrid} or {docref TreeGrid}.
    }
}
{define-class public open RecordMover {inherits Frame}

  {doc-next
    {purpose
        The {docref RecordGridCell} that contains this {docref RecordMover}.
    }
  }
  field public constant cell:RecordGridCell

  {doc-next
    {purpose A small graphic displayed to the left of the item title.}
  }
  field public-get protected-set marker:Graphic

  {doc-next
    {purpose Specify if the items can be rearranged using drag and drop.}
  }
  field public-get protected-set draggable?:bool = true

  {doc-next
    {purpose
        The name of the field where the ordinal position of the tree
        items is stored.
    }
    {details The value of this field is the {docref RecordGrid.key-spec}
        form the associated {docref RecordGrid} (or  {docref Treerid}).
    }
  }
  field protected pos-field:String

  field protected drag-graphic:Graphic

  {nonlocal-option public font-size:any
    set self.drag-graphic.font-size = font-size
  }

  {doc-next
    {purpose
        Initialize a {docref RecordMover}.
    }
    {parameter cell,
        The initial value for {docref RecordMover.cell}.
    }
    {parameter draggable?,
        The initial value for {docref RecordMover.draggable?}.
    }
    {parameter drag-graphic,
        The initial value for {docref RecordMover.drag-graphic}
    }
    {parameter marker,
        The initial value for {docref RecordMover.marker}
    }
    {parameter pos-field,
        The initial value for {docref RecordMover.pos-field}
    }
    {parameter ...,
        Option settings and event handlers.
    }
  }
  {constructor public {default 
                          cell:RecordGridCell,
                          draggable?:bool = true,
                          drag-graphic:#Graphic = null,
                          marker:#Graphic = null,
                          pos-field:String = "",
                          ...
                      }

    set self.cell = cell
    set self.draggable? = draggable?
    {if pos-field == "" then
        {type-switch self.cell.grid.key-spec
         case ks:String do
            set pos-field = ks
        }
    }
    set self.pos-field = pos-field

    {if-non-null drag-graphic then
        set self.drag-graphic = drag-graphic
     else
        set self.drag-graphic = 
            {Frame
                border-color = "black", border-width = 1px, ||""
                margin = 1px, background = "beige", ||""
                {self.cell.get-data}
            }
    }

    || In some cases we want the graphic but drag/drop is not allowed
    {if self.draggable? then
        set self.dragee = {ImageDragee drag-graphic = self.drag-graphic}
    }

    {if-non-null marker then
        set self.marker = marker
     else
        set self.marker = {self.make-marker}
    }

    {construct-super
        valign = "center", ||""
        halign = "center", ||""
        margin = 2px,
        opaque-to-events? = true,
        self.marker,
        {splice ...}
    }
  }

  {method protected open {make-marker}:Graphic
    ||FIXME: Need a font-size handler to keep this up to date.
    let d:Distance = {self.any-to-Distance self.font-size,
                         convert-font-relative-values? = true,
                         for-font-size? = true
                     }
    {return
        {SkinnableFill
            _style-element = "RecordMover/marker", ||""
            vorigin = "center", ||""
            horigin = "center", ||""
            opaque-to-events? = true,
            width = d * 0.8,
            height = d * 0.8,
            skin = 
                {ShadedSkinSpec
                    "lightblue", "cornflowerblue", ||""
                    border-color = "gray", ||""
                    rollover-border-color = "orange", ||""
                    draw-content-background? = false,
                    gradient-angle = -45deg,
                    highlight-alpha-1 = 0.0,
                    highlight-alpha-2 = 0.0,
                    highlight-boundary = .5,
                    corner-radius = d,
                    margin-spec = {OffsetSpec 1px}
                },
            {on e:PointerPress do
                {if not e.consumed? then
                    {self.cell.grid.ui.set-grid-focus null}
                }
            }
        }
    }
  }

  {method protected open {above? y:Distance}:bool
    {type-switch self
     case g:Graphic do
        {if-non-null gl = g.layout then
            let bounds:GRect = {gl.get-bounds}
            {inc y, bounds.ascent} || 0 is top
            def above? = y < bounds.height/2

        ||DEBUG
||--        let pxs:Distance = {any-to-Distance 1px}
||--        {output
||--            {format "y=%spx h=%spx ascent=%spx descent=%spx above?:%s",
||--                y/pxs, bounds.height/pxs, bounds.ascent/pxs, bounds.descent/pxs,
||--                above?
||--            }
||--        }    

            {return above?}
        }
    }
    {return false}
  }

  {method private {move-impl 
                      from-rec:#Record, to-rec:#Record, before?:bool
                  }:void

    let rs:#RecordSet = null
    {if-non-null r = self.cell.record then
        set rs = r.record-set
            {while rs isa RecordView do
                set rs = (rs asa RecordView).source
            }
    }
    {if-non-null rs, to-rec, from-rec then
        {with rs.batch-events? = true do
            def from = from-rec[self.pos-field] asa int
            set from-rec[self.pos-field] = 0
            def to = to-rec[self.pos-field] asa int
||--                {dump from, to, to-rec["id"], from-rec, to-rec}
            def rv = self.cell.grid.record-source
            {for r:Record key ri in {rv.select} do
                def rpos = r[self.pos-field] asa int
                {if rpos == 0 then
                    || skip this one and do it later
                 elseif (rpos < to and rpos < from)
                    or (rpos > to and rpos > from)
                 then
                    || no change
                 else
                    {if (from > to) and (rpos < from) then
                        set r[self.pos-field] = rpos + 1
                     elseif rpos <= to then
                        set r[self.pos-field] = rpos - 1
                    }
                }
            }
            set from-rec[self.pos-field] = to
            {after 0s do
                {self.cell.grid.ui.set-grid-focus self.cell}
            }
        }
    }
  }

  {method protected open {move
                          dropped:RecordMover,
                          before?:bool
                      }:void

    {if-non-null rg = self.cell.grid then
        {if-non-null cmd = {rg.get-command "dragdrop"} then ||""
            {type-switch cmd
             case ddc:MoveRecordParams do
                set ddc.from-rec = dropped.cell.record
                set ddc.to-rec = self.cell.record
                set ddc.before? = before?
            }
            {if cmd.impl.enabled? then
                {cmd.impl.do-command}
            }
            {return}
        }
    }

    {if dropped != self then
        {self.move-impl dropped.cell.record, self.cell.record, before?}
    }
  }

  {method public open {on-drop e:Drop}:void
    {e.accept-drop
        {proc
            {a:any, x:Distance, y:Distance, effect:#DragEffect}:DropResult
            {e.consume}
            {return 
                {DropResultNone
                    action =
                        {proc {}:void
                            {type-switch a
                             case dropped:RecordMover do
                                {unset self.cell.background}
                                {unset dropped.cell.background}
                                {self.move dropped, {self.above? y}}
                            }
                        }
                }
            }
        }
    }
  }

  {method public open {on-drag-enter e:DragEnter}:void
    {e.consume}
    set self.cell.background = "azure" ||""
    {super.on-drag-enter e}
  }

  {method public open {on-drag-leave e:DragLeave}:void
    {unset self.cell.background}
    {super.on-drag-leave e}
  }

 
  {method public open {on-drag-over e:DragOver}:void
    {e.will-accept-drop?
        {proc
            {dragged-type:Type,
             x:Distance,
             y:Distance,
             effect:#DragEffect
            }:DragEffect
            {if {dragged-type.subtype-of? RecordMover} then
||--                {unset self.border-spec}
                {if {self.above? y} then 
                    set self.cell.background = "azure" ||""
                 else
                    set self.cell.background = "azure" ||""
                }
                {return drag-effect-move}
             else
                {return drag-effect-none}
            }
        }
    }
  }
}


{doc-next
    {purpose A {docref RecordGridCell} that includes an icon or
        graphic that can be dragged to move the record up or down in
        a {docref RecordGrid}.
    }
}
{define-class abstract public open MovableCell
  {inherits StandardBaseEditableStringCell}

  || Note: self.display-graphic is the non-editable string display

  field private _cell-box:HBox       || Holds the cell content
  field private _marker-frame:Frame  || for indentation and draggable marker
  field protected string-frame:Frame  || for string or editor
  field protected movable-editor:#TextField   || the editor, if any

  {doc-next
    {purpose
        The {docref RecordMover} provides a graphic that the user
        can click on and drag.
    }
  }
  field public-get protected-set mover:#RecordMover

  {nonlocal-option public control-color:FillPattern
    {if-non-null self.child then
        {self.refresh-data}
    }
  }
  
  {doc-next
    {purpose Initialize a {docref MovableCell}.}
  }
  {constructor public {default}
    {construct-super}
    set self.context-menu-for-text-field = null

    set self._marker-frame = {Frame}|| hstretch? = true, vstretch? = true}
    set self.string-frame = {clipper valign = "center", self.display-graphic}
    set self._cell-box =
        {HBox valign = "origin", ||""
            self._marker-frame, self.string-frame
        }
    {self.add-internal self._cell-box}
  }

  {doc-next
    {purpose Create the {docref RecordMover} for this cell.}
  }
  {method protected open {make-mover}:RecordMover
    {return
        {RecordMover
            self,
            border-color = "transparent" ||""
        }
    }
  }

  {setter public open {edit-active? value:bool}:void
    set super.edit-active? = value
    || Superclass may set heights to 0m, so unset them
    {if-non-null editor = self.current-editor then
        {unset editor.height}
    }
    {unset self.display-graphic.height}
  }

  {method public open {refresh-data}:void
    {super.refresh-data}

    set self.halign = "left" ||""
    {if self.mover == null then
        set self.mover = {self.make-mover}
        {self.mover.marker.add-event-handler
            {on e:Adjustment at t:DefaultDiscloser do
                let (val:any, valid?:bool) = {self.get-data}
                {if valid? then
                    {if-non-null r = self.record then
                        let parent?:bool =
                            r["_rn"] asa int > (r["_ln"] asa int) + 1 ||""
                        {if parent? then
                            set r["_expand?"] = t.state == DisclosureState.expanded
                        }
                    }
                }
            }
        }
        {self._marker-frame.add replace? = true, self.mover}
    }
  }

  {doc-next
    {purpose If the named command exists on the RecordGrid that contains 
        this cell, execute it and consume the event {param ev}.
    }
  }
  {method public open {do-command ev:KeyPress, command-name:String}:bool
    {if-non-null r = self.record, cc = self.grid then
        {if-non-null cmd = {cc.get-command command-name} then
            {if cmd.impl.enabled? then
                {cmd.impl.do-command}
                {ev.consume}
                {return true}
            }
        }
    }
    {return false}
  }

}

{doc-next
    {purpose
        A {docref DefaultDiscloser} designed to be used in a
        {docref RecordGridCell}.
    }
}
{define-class public open RecordDiscloser {inherits DefaultDiscloser}

  field protected cell:RecordGridCell

  {doc-next
    {purpose A procedure that can be called to obtain the image that
        reflects the current state of the discloser.
    }
  }
  field protected icon-proc:#{proc-type 
                               {cell:RecordGridCell,
                                state:DisclosureState
                               }:Pixmap}
  
  {doc-next
    {purpose Initialize this object. The rest args are any options
        that can be applied to a {docref Graphic}.
    }
    {parameter cell,
        The {docref RecordGridCell} that this discloer belongs to.
    }
    {parameter icon-proc,
        Invoked to create an icon when needed.
    }
  }
  {constructor public {default
                          cell:RecordGridCell,
                          icon-proc:#{proc-type
                                         {cell:RecordGridCell,
                                          state:DisclosureState
                                         }:Pixmap
                                     },
                          ...
                      }
    set self.icon-proc = icon-proc
    set self.cell = cell
    {construct-super animation-rate = 0Hz, {splice ...}}
  }

||--  {nonlocal-option public font-size:any
||--    {self.refresh-icon}
||--  }

  {doc-next
    {purpose
        Returns an image that reflects the current state of the discloser.
    }
  }
  {method protected open {get-pixmap 
                             state:DisclosureState
                         }:#Pixmap
    {if-non-null record = self.cell.record then
        {if-non-null icon-proc = self.icon-proc then
            {return {icon-proc self.cell, state}}
        }
    }
    {return {super.get-pixmap state}}
  }
}

{doc-next
    {purpose A {docref RecordGridCell} that indents a node according
        to its position in a tree hierarchy. It supports drag and drop,
        and expanding or contracting the node.
    }
    {details
        The {ctext ExpanderCell} displays an editable string
        indented according to it's position in a hierarchy with a
        graphic that can be used to drag the record to a new location.
        It requires three fields in each {ctext Record}.

        An {param id} field is a unique identifier for each record.
        This field is given by the key-spec value for the containing
        {docref RecordGrid}. An exception is thrown if this property
        is not present or not a String.

        A {param parent-id} field is required so that each Record
        can identify its parent in the hierarchy.
    }
}
{define-class public open ExpanderCell {inherits MovableCell}

  field protected discloser:#Discloser

  {nonlocal-option public control-color:FillPattern
    {if-non-null self asa #ExpanderCell then
        {self.refresh-data}
    }
  }
  
  {doc-next
    {purpose The name of the field used to store indentation depth.}
    {details 
        This method returns "depth" as the field name. If a different
        field must be used, create a subclass that overrides this
        getter and returns the desired field name.
    }
  }
  {getter public open {depth-field}:String
    {return "_depth"} ||""
  }

  {doc-next
    {purpose
        Construct this object.
    }
  }
  {constructor public {default}
    {construct-super}
  }
  
  {method protected open {make-mover}:RecordMover
    let draggable?:bool = true
    let pos-field:String = RecordSetTreeModel.pos-field
    {if-non-null grid = self.grid, record = self.record then
        {type-switch grid
         case tg:TreeGrid do
            set draggable? = tg.draggable-items?
            {if-non-null p = tg.icon-proc then
                set self.discloser =
                    {RecordDiscloser self, p}
            }
        }
    }
    {if self.discloser == null then
        set self.discloser = {RecordDiscloser self, null}
    }
    {return
        {RecordMover
            self,
            draggable? = draggable?,
            border-color = "transparent", ||""
            pos-field = pos-field,
            marker = self.discloser
        }
    }
  }
  
  {method protected open {create-editor}:TextField
    {return {SRGTextField}}
  }

  {method public open {refresh-data}:void
    {super.refresh-data}

    || Draw the outline if this cell has the focus
    {if self.has-grid-focus? then
        set self.border-color = "black" ||""
     else
        set self.border-color = "transparent" ||""
    }

    set self.halign = "left" ||""
    let (val:any, valid?:bool) = {self.get-data}
    {if-non-null editor = self.current-editor then
        set editor.halign = self.halign
        ||FIXME: Should there be a ValueChanged here?
        set editor.value = self.display-graphic.contents
     else
        {if valid? then
            {if-non-null grid = self.grid, record = self.record then
||--                set self.mover = {self.make-mover}
||--                {self._marker-frame.add self.mover, replace? = true}
                {type-switch grid
                 case tg:TreeGrid do
                    {if-non-null p = tg.item-proc then
                        {self.string-frame.add replace? = true,
                            {p self}
                        }
                    }
                }
            }
        }
    }

    {if-non-null discloser = self.discloser then
        set discloser.visible? = valid?
        {if-non-null r = self.record then
            set val = r["_expand?"] ||""
            {if valid? then
                {if r["_ln"] asa int + 1 == r["_rn"] asa int then ||""
                    set discloser.color = "silver" ||""
                    set discloser.state = DisclosureState.singleton
                 else
                    set discloser.state =
                        {if val asa bool then DisclosureState.expanded
                         else DisclosureState.collapsed}
                    set discloser.color = self.color
                }
            }
            {if self.depth-field != "" then
                let d:Distance = {self.any-to-Distance self.font-size,
                                     convert-font-relative-values? = true,
                                     for-font-size? = true
                                 }
                set self.mover.border-spec =
                    {BorderSpec
                        top-margin = d * .4,
                        left-margin = r[self.depth-field] asa int * d * 0.8
                    }
            }
        }
    }
  }

  {getter public open {current-editor}:#TextField
    {if self.string-frame.child.graphic == self.movable-editor then
        {return self.movable-editor}
    }
    {return null}
  }

  {method public open {note-grid-focus-in}:void
    {if self.current-editor == null then
        let col:RecordGridColumn = {non-null self.column}
        let (editor:#Graphic, exists?:bool) =
            {self.cached-editors.get-if-exists col}
        {if exists? then 
            {self.cached-editors.remove col}
         else   
            set editor = {self.create-editor}
        }
        set self.movable-editor = editor asa #TextField|| TextArea
        {if-non-null editor then
            {if self.edit-on-focus? then
                set self.edit-active? = true
            }

            {if self.edit-active? then
                {unset editor.height}
                {self.string-frame.add replace? = true, editor}
             else
                {unset self.display-graphic.height}
                {self.string-frame.add replace? = true, self.display-graphic}
            }
            {type-switch editor
             case sat:StandardActiveTraversor do
                {sat.become-active-from-traversal}
            }
        }
        {self.refresh-data}
    }
    {self.sync-editor}

    || Can't call super. because it will mess up the cell content.
    || Just clear the undo stack (from StandardStringCell.method
    || {super.note-grid-focus-in}
    {if-non-null current-editor = self.current-editor then
        {current-editor.clear-undo-stack}
    }
  }

  {method public open {note-grid-focus-out}:void
    {if-non-null editor = self.current-editor then
        {if editor.pending-value? then
            || force pending change to happen immediately.
            {editor.handle-event {ValueChanged}}
            {editor.handle-event {ValueFinished}}
            set editor.pending-value? = false
        }
    }
    {if-non-null editor = self.current-editor then
        set self.edit-active? = false
        {unset self.display-graphic.height}
        {self.string-frame.add
            self.display-graphic,
            replace? = true
        }
        {self.cached-editors.set {non-null self.column}, editor}
    }

    || Don't call superclass method. It messes up the cell
    || {super.note-grid-focus-out}
  }

||--  ||FIXME: perhaps this belongs on a subclass?
||--  {method public open {on-key-press ev:KeyPress}:void
||--    {dump ev, ev.ctrl?}
||--    {if not ev.consumed? then
||--        {if-non-null r = self.record, cc = self.grid
||--         then
||--            {if ev.value == KeyPressValue.space then
||--                set r["_expand?"] = not r["_expand?"] asa bool ||""
||--                {ev.consume}
||--                {return}
||--             elseif ev.value == KeyPressValue.delete then
||--                {if {self.do-command ev, "Tree.delete-node"} then ||""
||--                    {return}
||--                }
||--             elseif ev.value == KeyPressValue.enter then
||--                {if ev.ctrl? then
||--                    {if {self.do-command ev, "Tree.add-child-node"} then ||""
||--                        {return}
||--                    }
||--                 else
||--                    {if {self.do-command ev, "Tree.add-node"} then ||""
||--                        {return}
||--                    }
||--                }
||--            }
||--            {if ev.ctrl? then
||--                {if ev.value == KeyPressValue.up then
||--                    {if {self.do-command ev, "Tree.move-node-up"} then ||""
||--                        {return}
||--                    }
||--                 elseif ev.value == KeyPressValue.down then
||--                    {if {self.do-command ev, "Tree.move-node-down"} then ||""
||--                        {return}
||--                    }
||--                 elseif ev.value == KeyPressValue.left then
||--                    {if {self.do-command ev, "Tree.undent-node"} then ||""
||--                        {return}
||--                    }
||--                 elseif ev.value == KeyPressValue.right then
||--                    {if {self.do-command ev, "Tree.indent-node"} then ||""
||--                        {return}
||--                    }
||--                }
||--            }
||--        }
||--    }
||--    {super.on-key-press ev}
||--    {type-switch ev
||--     case rgkp:RecordGridKeyPress do
||--        {dump rgkp}
||--||--        {if true or not rgkp.upwards? then
||--     else
||--        {forward-to-grid-cell self, ev}
||--    }
||--  }
  
  {method public open {test-run action:String, args:FastArray}:any
    {switch action
     case "SetCellData" do ||""
        {type-switch args[0]
         case s:String do
            let parsed?:bool = false
            let parsed-value:bool = false
            {if {regexp-match? |"^(?i:t|true|1)$"|, s} then ||""
                set parsed-value = true
                set parsed? = true
             elseif {regexp-match? |"^(?i:f|false|0)$"|, s} then ||""
                set parsed-value = false
                set parsed? = true
            }
            {if parsed? then
                {self.attempt-update parsed-value}
            }
         case b:bool do
            {self.attempt-update b}
        }
        {return null}
     else
        {return {super.test-run action, args}}
    }
  }

  {getter public open {test-value}:#String
    let constant (data:any, valid?:bool) = {self.get-data}
    {if valid? then
        {type-switch value
         case b:bool do
            {return {String b}}
        }
    }
    {return null}
  }

  {method protected open {sync-editor}:void
    {super.sync-editor}
    {if-non-null editor = self.current-editor then
        {editor.request-update-commands}
    }
  }  
}

|| ------------------------------------------------------------------------

|#

To Do
  o Would it be better to edit on a popup window? As it is, if a
    single cell gets too tall (taller than the RG itself), there is no
    way to scroll to see it all. 

How this evolved:
  o Copy SRGTextField as SRGTextArea, modify as appropriate
  o SRGTextFieldUI as SRGTextAreaUI, modify as appropriate
  o Create MultilineStringCell from StandardStringCell and it's
    subclasses.
  o Change Field to Area all over the place

#|

{define-class package SRGTextArea {inherits TextArea}

  {getter private {cell}:#StandardRecordGridCell
    {if-non-null parent = self.parent then
        {return parent.parent asa #StandardRecordGridCell}
    }
    {return null}
  }

  {constructor package {default}
     {construct-super
         active-traversal-container = null,
         vorigin = 0.0,
         horigin = 0.0,
         margin = 0px,
         ui-object = {SRGTextAreaUI},
         value = "",
         test-visible? = false,
         {on ValueFinished at tf:SRGTextArea do
             {if-non-null cell = tf.cell then
                 {if cell.can-update? then
                     {cell.attempt-update tf.value}
                 }
             }
         }
     }
  }
    
  {getter public open {writable?}:bool
    {return 
        super.writable? and
        {if-non-null cell = self.cell then 
            cell.can-update?
         else 
            false
        }
    }
  }
  
  {method public open {get-command name:String}:#Command
    || Intercept the paste command if we are not currently in edit mode.
    {switch name
     case "paste" do ||""
        {if-non-null cell = self.cell then
            {if not cell.edit-active? then
                {if-non-null grid = cell.grid then
                    {return {grid.get-command name}}
                }
            }
        }
    }
    {return {super.get-command name}}
  }
  
}


|| Define keypresses that should generally not be handled by uis
{define-proc package {reserve-for-grid? ev:KeyPress}:bool
    {if ev.ctrl? then {return false}}
    {return
        {switch ev.value
         case 
            KeyPressValue.right, KeyPressValue.left, KeyPressValue.home,
            KeyPressValue.end, KeyPressValue.pgdn, KeyPressValue.pgup,
            KeyPressValue.up, KeyPressValue.down, KeyPressValue.tab
         do 
            true
         else
            false
        }
    }
}

{define-class package SRGTextAreaUI {inherits StandardTextAreaUI}
  
  {constructor package {default ...}
    {construct-super {splice ...}}
    set self.control-content-background = FillPattern.transparent
  }
  
  {method protected open {create-contents}:Visual
    || Not good because it shrinks to two lines
||--    {return
||--        {ScrollBox 
||--            hstretch?=true,
||--            vstretch?=true,
||--            hscroll?=false,
||--            vscroll?=true,
||--            accept-focus?=false,
||--            shrink-vscroll?=true,
||--            margin=0pixels,
||--            self.string-graphic
||--        }
||--    }
    {return self.string-graphic}
  }

||FIXME: should be protected for copy/modify?
||--  {method public open {on-start-composition-event
||--                          e:StartCompositionEvent
||--                      }:void
||--    || Commit a prepared recording; don't call
||--    || commit-prepared-recording-due-to-edit because we want this to
||--    || affect all pending recordings.
||--    {if-non-null recording = self.prepared-test-recording then
||--        {recording.commit}
||--        set self.prepared-test-recording = null
||--    }
||--    {if not e.consumed? then
||--        {if-non-null srgc = {get-grid-cell self} then
||--            {if not srgc.edit-active? then
||--                {self.control.become-active-from-traversal}
||--                set srgc.edit-active? = true
||--            }
||--        }
||--    }
||--  }
  
  {method public open {on-key-press ev:KeyPress}:void
    let rng:StringDataModelWritableRange =
         (self.control asa TextArea).selected-range
    
    || First see if we need to enter edit mode
    let cell:StandardRecordGridCell = {non-null {get-grid-cell self}}
    {if not cell.edit-active? and
        (ev.insertable? or
         ev.value == KeyPressValue.backspace or
         ev.value == KeyPressValue.delete or
         ev.value == KeyPressValue.enter or
         ev.value == KeyPressValue.f2)
     then
        set cell.edit-active? = true
        {self.control.become-active-from-traversal}
    }
    
    || Squelch grid keys, except right/left/home/end when not fully selected
    {if cell.edit-active? and
        (not {reserve-for-grid? ev} or
         ((ev.value == KeyPressValue.right or
           ev.value == KeyPressValue.left or
           ev.value == KeyPressValue.home or
           ev.value == KeyPressValue.end) and
          rng.size != rng.data-model.size))
     then
        {switch ev.value
         case KeyPressValue.esc do
            || Escape reverts cell
            {cell.refresh-data}
            {ev.consume}
         case KeyPressValue.f2 do
            || Key used by windows to collapse selection for editing 
            {if rng.size == rng.data-model.size then
                set rng.point = rng.max-index
                {rng.collapse-to-point}
                {ev.consume}
            }
        }
        
        || suppress editing keys when non-editable
        {if ev.insertable? or
            ev.value == KeyPressValue.delete or
            ev.value == KeyPressValue.backspace
         then
            {if {grid-cell-can-update? self} then 
                {super.on-key-press ev}
            }
         else
            {super.on-key-press ev}
        }
        
    }

    {forward-to-grid-cell self, ev}
    set ev.test-recorded? = true
  }
   
  || Do not draw any bevels.; squelch context menu
  {method protected open {overdraw-control renderer2d:Renderer2d}:void}
  {method open public {on-context-menu-event e:ContextMenuEvent}:void}
  
}


{doc-next
    {purpose A {docref RecordGridCell} for values that are currency
        amounts stored as pennies.
    }
}
{define-class public open CurrencyCell 
  {inherits StandardStringCell}
  
  let public constant formatter:NumberFormatter =
      {NumberFormatter.create-currency-formatter
        locale = {get-working-locale}
      }

  let public constant parser:NumberParser =
      {NumberParser 
        allow-grouping? = true,
        allow-exponent? = false,
        whitespace-char-class = {CharClass " $\\\t"}
      }

  {define-proc public {format-value v:int}:String
    {return {CurrencyCell.formatter.format v / 100.0}}
  }

  {doc-next
    {purpose Construct this a {docref CurrencyCell}.}
  }
  {constructor public {default}
    {construct-super}
    set self._style-element = "CurrencyCell"
    set self.halign = "right"
  }

  {method public open {parse val:String}:any
   
    let ret:any = null
    let field:RecordField = {unchecked-non-null self.field}
    {if val.empty? and field.nullable? then
        let (data:any, valid?:bool) = {self.get-data}
        {if valid? and data == null then
            set ret = null
         else
            {try
                set ret = 
                    {round ({CurrencyCell.parser.parse-double val} * 100.0)}
             catch e:Exception do
                set ret = null
            }
        }
     else
        {try
            set ret = 
                {round ({CurrencyCell.parser.parse-double val} * 100.0)}
         catch e:Exception do
            set ret = e
        }   
    }
    {return ret}
  }

  {method public open {format data:any}:String
    {if-non-null field = self.field then
        {if-non-null data then
            {return {CurrencyCell.format-value data asa int}}
        }
    }
    {return ""}
  }

}

{doc-next
    {purpose 
        {ctext RecordGridCell} for displaying and editing 
        data using its standard string representation.
    }
}
{define-class public open MultilineStringCell
  {inherits StandardBaseEditableStringCell}
  
  {doc-next {purpose Construct this {docref MultilineStringCell}.}}
  {constructor public {default}
    {construct-super}
    set self.display-graphic = 
        {MultiLineStringGraphic 
            "",
            width = {add-stretch},
            vorigin = 0.0,
            horigin = 0.0,
            halign = self.halign,
||--            margin = 2px
            border-spec = 
                {BorderSpec 
                    left-margin = 2px, right-margin = 2px,
                    top-margin = 2px, bottom-margin = 2px
                }
        }

    || FIXME: Unfortunately a StringGraphic has already been created
    || by StandardFixedStringCell (super.super). Maybe not such a big
    || deal, but fix is some kind of overridable create-content method
    || NOTE: is it possible to use LookAndFeel.get-string-graphic
    || somehow?  What's that all about? (also see
    || StandardFixedStringCell.create-display-graphic)
    {self.add-internal replace? = true, self.display-graphic}
  }
  
  {method protected open {create-editor}:TextArea      
    {return {SRGTextArea}}
  }

  {getter public open {current-editor}:#TextArea 
    {return super.current-editor asa #TextArea}
  }
 
  {method public open {refresh-data}:void
    {super.refresh-data}
    {if-non-null editor = self.current-editor then 
        set editor.value = self.display-graphic.contents
    }
  }
  
  {method public open {become-active forward?:bool = true}:bool
    let ret:bool = {super.become-active forward? = forward?} 
    {if ret then
        {if-non-null editor = self.current-editor then 
            {editor.become-active forward? = forward?}
        }
    }
    {return ret}
  }  

  {method public open {become-active-from-traversal forward?:bool = true}:bool
    let ret:bool = {super.become-active-from-traversal forward? = forward?}
    {if ret then
        {if-non-null editor = self.current-editor then
            {editor.become-active-from-traversal forward? = forward?}
            {editor.select-all}
            {editor.selected-range.swap-anchor-and-point}
        }
    }
    {return ret}
  }  

  
  {method public open {on-key-press ev:KeyPress}:void
    {super.on-key-press ev}
    {if-non-null editor = self.current-editor then 
        {type-switch ev
         case rgkp:RecordGridKeyPress do
            {if not rgkp.upwards? then
                {editor.select-all}
                {editor.selected-range.swap-anchor-and-point}
                {editor.ui-object.handle-event ev}
            }
            set rgkp.test-recorded? = true
        }
    }    
  }

  {method public open {note-grid-focus-out}:void
    {if-non-null editor = self.current-editor then 
        {if editor.pending-value? then
            || force pending change to happen immediately.
            {editor.handle-event {ValueFinished}}
            set editor.pending-value? = false
        }
    }
    {super.note-grid-focus-out}
  } 


  {method protected open {sync-editor}:void
    {super.sync-editor}
    {if-non-null editor = self.current-editor then
        {editor.request-update-commands}
    }
  }  
  
}

|| ---------------------------------------------------------------------------

{doc-next
    {purpose A {docref RecordGridCell} with a dynamic list of choices.}
    {override
        Override create-list-value-array to compute the choices.
    }
}
{define-class abstract public open ChooseValueCell
  {inherits StandardBaseEditableStringCell}

  {doc-next
    {purpose
        Construct this {docref ChooseValueCell}.
    }
  }
  {constructor public {default}
    {construct-super}
  }

  || Create the default array of ListValueItems for this cell.
  {method abstract protected open {create-list-value-array
                                  }:{Array-of ListValueItem}
  }

  {method protected open {create-editor}:DropdownList
    let lm:{Array-of ListValueItem} = {self.create-list-value-array}
    {return {SRGDropdownList {splice lm}}}
  }

  {getter public open {current-editor}:#DropdownList
    {return super.current-editor asa #DropdownList}
  }
  
  || Methods to implement RecordGridCell
  {method public open {refresh-data}:void
    {super.refresh-data}
    {if-non-null editor = self.current-editor then
        let (val:any, valid?:bool) = {self.get-data}
        {if valid? then
            set editor.value = val
            {self.refresh-list}
         else
            set editor.prompt =  "" 
            {editor.unset-value}
        }
     else
        let (str:String, valid?:bool) = {self.get-formatted-data}
        set self.display-graphic.contents = {if valid? then str else ""}
    }
  }

  {doc-next
    {purpose Rebuild the list of choices.}
  }
  {method public open {refresh-list}:void
    {if-non-null editor = self.current-editor then
        def v = editor.value
        let list:{Array-of ListValueItem} = {self.create-list-value-array}
        def lm = editor.data-model
        {lm.clear}
        {for lva in list do
            {editor.append lva}
        }
        set editor.value = v
     else
        {self.refresh-data}
    }
  }

  {method public open {become-active forward?:bool = true}:bool
    let ret:bool = {super.become-active forward? = forward?}
    {if ret then
        {if-non-null editor = self.current-editor then
            {self.refresh-list}
            {editor.become-active forward? = forward?}
        }
    }
    {return ret}
  }

  {method public open {note-grid-focus-in}:void
    {super.note-grid-focus-in}
    {if-non-null editor = self.current-editor then
        {self.refresh-list}
        {type-switch editor
         case ddl:DropdownList do
            set ddl.halign = self.halign
        }
    }
  }

  {method public open {note-grid-focus-out}:void
    {if-non-null editor = self.current-editor then
        || force pending change to happen immediately.
        {if editor.pending-value? then
            {editor.handle-event {ValueFinished}}
            set editor.pending-value? = false
        }
    } 
    {super.note-grid-focus-out}
  }
  
  {local-option public halign:any
    {if-non-null editor = self.current-editor then
        {type-switch editor
         case ddl:DropdownList do
            set ddl.halign = self.halign
        }
    }
  }
   
  || When a KeyPress is delivered to this cell,
  || toss it directly to the editor's UI instead.
  {method public open {on-key-press ev:KeyPress}:void
    {super.on-key-press ev}
    {if-non-null editor = self.current-editor then
        {type-switch ev
         case rgkp:RecordGridKeyPress do
            {if not rgkp.upwards? then
                {editor.ui-object.handle-event ev}
                set ev.test-recorded? = true
            }
        }
    }
  }
  
  || Attempts to locate the index of a value among the list used for
  || this cell's control. Returns -1 on failure.
  || FIXME: only works when this cell is active and has an editor.
  {method package {find-index-for-list-item val:any}:(int, any)
    let tmp-idx:int
    let index:int = -1
    let data:any
    let constant list-items:{Iterator-of ListItem} =
        {if-non-null editor = self.current-editor then
            editor.list-items
         else
            {return -1, null}
        }
    {type-switch val
     case s:String do
        let main:#String = null
        {if {regexp-match? |"#(\d+)"|, s, main} then
            {try 
                set index = {main.to-int}
                set tmp-idx = -1
                {for item in list-items do
                    {inc tmp-idx}
                    {if index == tmp-idx then
                        set data = item.value
                        {break}
                    }
                }
                
                {if index != tmp-idx then
                    {throw
                        {KeyNotFoundException
                            {hlmessage 
                                Key '{value index}' not found in
                                '{value list-items}'.
                            }
                        }
                    }
                }
             catch ce:CastException do
            }
            
         else
            set tmp-idx = -1
            {for item in list-items do
                {inc tmp-idx}
                {if {item.get-text} == s then
                    set index = tmp-idx
                    set data = item.value
                }
            }
        }
     else
        set tmp-idx = -1
        {for item in list-items do
            {inc tmp-idx}
            {if item.value == val then
                set index = tmp-idx
                set data = val
            }
        }
    }
    {if index >= 0 then
        {return index, data}
     else
        {return index, null}
    }
  }
  
  {method public open {test-run action:String, args:FastArray}:any
    {switch action
     case "SetCellData" do ||""
        let constant (index:int, new-value:any) = 
            {self.find-index-for-list-item args[0]}
        {if-non-null new-value then
            {self.attempt-update new-value}
        }
        {return null}
     else
        {return {super.test-run action, args}}
    }
  }

  || FIXME: this only works for the current index at present, and
  || only when the current editor is active (cell is active).
  {getter public open {test-value}:#String
    let constant (data:any, valid?:bool) = {self.get-data}
    {if valid? then
        {if-non-null editor = self.current-editor then
            {if value == editor.value then
                {return "#" & editor.selected-index} ||""
            }
        }
    }
    {return null}
  }

}

|| ----------------------------------------------------------------------

||--{doc-next
||--    {purpose
||--        A {docref RecordGridCell} designed to be used to display (and
||--        change) a foreign key field specified by a
||--        {docref ForeignFieldDomain}.
||--    }
||--}
||--{define-class public open {ForeignKeyCell-for
||--                            rs:any, id-field:String, label-field:String
||--                          }
||--  {inherits ChooseValueCell}
||--
||--  {doc-next
||--    {purpose
||--        Return the {docref RecordSet} provided when this generic class
||--        was instantiated.
||--    }
||--  }
||--  {getter public open {rs}:RecordSet
||--    {type-switch rs
||--     case rs:RecordSet do
||--        {return rs}
||--     case rsp:{proc-type {}:RecordSet} do
||--        {return {rsp}}
||--     else
||--        {error 
||--            {hlmessage 
||--                Parameter rs must be a RecordSet or a proc that 
||--                returns a RecordSet.
||--            }
||--        }
||--    }
||--  }
||--
||--  {doc-next
||--    {purpose
||--        Construct this object.
||--    }
||--  }
||--  {constructor public {default}
||--    {construct-super}
||--  }
||--
||--  {doc-next
||--    {purpose
||--        This override will create the list of choices from values in the
||--        foreign table.
||--    }
||--    {details
||--        The chioces consist of all of the values from the foreign table.
||--    }
||--  }
||--  {method protected open {create-list-value-array}:{Array-of ListValueItem}
||--    let constant lm:{Array-of ListValueItem} = {{Array-of ListValueItem}}
||--    {for r:Record in {self.rs.select} do
||--        {lm.append
||--            {ListValueItem 
||--                r[id-field],
||--                label = {url-decode-string r[label-field] asa String}
||--            }
||--        }
||--    }
||--    {if self.field.nullable? then
||--        {lm.append {ListValueItem null, label = " "}}
||--     else
||--        {lm.append {ListValueItem 0, label = " "}}
||--    }
||--    {return lm}
||--  }
||--  
||--  {method public open {format data:any}:String
||--    let (data:any, valid?:bool) = {self.get-data}
||--
||--    let s:String = {super.format data}
||--    {if {s.find '#'} > -1 then
||--        let parts:StringArray = {s.split split-chars = "#"} ||""
||--        set s = parts[0]
||--    }
||--    {return {url-decode-string s}}
||--  }
||--
||--}

{doc-next
    {purpose
        A {docref RecordGridCell} designed to be used to display and
        edit a foreign key field specified by a {docref ForeignFieldDomain}.
    }
}
{define-class public open ForeignKeyCell {inherits ChooseValueCell}

  field private updater:#EventHandler = null
  field private updater-rs:#RecordSet = null

  {doc-next
    {purpose
        Construct this object.
    }
  }
  {constructor public {default}
    {construct-super}
  }

  {method public open {get-data}:(data:any, valid?:bool)
    {type-switch self.field.domain
     case ffd:ForeignFieldDomain do
        def rs = ffd.rs
        {if self.updater-rs != rs then
            {if-non-null updater = self.updater, urs = self.updater-rs then
                {if {urs.event-handler-present? updater} then
                    {dump "removing", updater, urs}
                    {urs.remove-event-handler updater}
                    set self.updater = null
                    set self.updater-rs = null
                }
            }
        }
        {if self.updater == null then
            set self.updater-rs = rs
            set self.updater =
                {on e:RecordsChanged at frs:RecordSet do
                    {self.refresh-list}
                }
            {rs.add-event-handler {non-null self.updater}}
        }
    }
    {return {super.get-data}}
  }

  {doc-next
    {purpose
        This override will create the list of choices from values in the
        foreign table.
    }
    {details
        The chioces consist of all of the values from the foreign table.
    }
  }
  {method protected open {create-list-value-array}:{Array-of ListValueItem}
    {type-switch self.field.domain
     case ffd:ForeignFieldDomain do
        def rs = ffd.rs
        def key-field = ffd.key-field
        def label-field = ffd.label-field

        let constant lm:{Array-of ListValueItem} = {{Array-of ListValueItem}}
        {for r:Record in {rs.select} do
            {lm.append
                {ListValueItem 
                    r[key-field],
                    label = {url-decode-string r[label-field] asa String}
                }
            }
        }
        {if self.field.nullable? then
            {lm.append {ListValueItem null, label = " "}}
         else
            {lm.append {ListValueItem 0, label = " "}}
        }
        {return lm}
     else
        {error 
            {hlmessage 
                The domain for the column where ForeignFieldCell is used
                must be a ForeignFieldDomain.
            }
        }
    }
  }
  
  {method public open {format data:any}:String
    let (data:any, valid?:bool) = {self.get-data}

    let s:String = {super.format data}
    {if {s.find '#'} > -1 then
        let parts:StringArray = {s.split split-chars = "#"} ||""
        set s = parts[0]
    }
    {return {url-decode-string s}}
  }

}

|| ----------------------------------------------------------------------

{doc-next 
    {purpose A proc that formats a {docref DateTime} value into a
        string appropriate for the current locale.
    }
    {details
        This procedure is designed to be used as a {ctext format-spec}
        parameter on a {docref RecordGridColumn}.
    }
}
{define-proc public {locale-date-format v:any}:String
    {type-switch v
     case dt:DateTime do
        {return dt.info.locale-date}
     else
        || Isn't this an error?
        {return {format "%s", v}} ||""
    }
}

|| ---------------------------------------------------------------------------

{doc-next
    {purpose A DateField for use with a StandardDateCell.}
}
{define-class public open SRGDateField {inherits DateField}
  
  {getter private {cell}:#StandardDateCell
    {if-non-null parent = self.parent then
        {return parent.parent asa #StandardDateCell}
    }
    {return null}
  }
  
  {doc-next
    {purpose
        Construct a {docref SRGDateField}.
    }
  }
  {constructor public {default}
    {construct-super
        active-traversal-container = null,
        ui-object = {SRGDateFieldUI},
        value = {DateTime},
        test-visible? = false,
||--        date-format-spec = DateFieldFormatSpec.iso,
        {on vf:ValueFinished at df:SRGDateField do
||--            {dump df, vf, df.value}
            {if-non-null cell = df.cell then
                {if cell.can-update? then
                    {cell.attempt-update df.value}
                }
            }
        }
    }
  }
  
}


{doc-next
    {purpose
        A {docref DateFieldUI} for use with a {docref SRGDateField}
        (and thus a {docref StandardDateCell}).
    }
}
{define-class public open SRGDateFieldUI {inherits StandardDateFieldUI}
  
  {doc-next
    {purpose Initialize a new {docref SRGDateFieldUI}.}
  }
  {constructor public {default ...}
    {construct-super {splice ...}}
  }
  
  {method public open {on-key-press ev:KeyPress}:void
    
    || First see if we need to enter edit mode
    let constant cell:StandardRecordGridCell = {non-null {get-grid-cell self}}
    {if not cell.edit-active? and
        (ev.insertable? or
         ev.value == KeyPressValue.backspace or
         ev.value == KeyPressValue.delete or
         ev.value == KeyPressValue.enter or
         ev.value == KeyPressValue.f2)
     then
        set cell.edit-active? = true
        {self.control.become-active-from-traversal}
    }

    || Allow the super UI to do its normal work.
    {if cell.edit-active? then
        {super.on-key-press ev}
    }
    
    || TODO: only arrow-left / arrow-right when at the edge of data.
    || Is this possible without major hackage? Probably not.
    
    {forward-to-grid-cell self, ev}

    set ev.test-recorded? = true
  }
  
  
  || Do not overdraw the control -- we're using it raw, inline.
  {method protected open {overdraw-control renderer2d:Renderer2d}:void}

  
  || Remove the extra margin.
  {method protected open {create-main-panel}:Graphic
    let constant g:Graphic = {super.create-main-panel}
    set g.margin = 0px
    {return g}
  }
  
  
}

{doc-next
    {purpose
        An editable {docref RecordGridCell} for a field that uses a
        {docref DateTime} to represent a date.
    }
    {details
        The editor for this cell is a {docref DateField}. If the
        domain for the column containing this cell is a {docref
        LocaleDateDomain} then the {docref DateField.date-format-spec}
        is {docref DateFieldFormatSpec}.local. Otherwise it is
        {docref DateFieldFormatSpec.iso}, which matches the formatting
        used by {docref StandardDateDomain}.
    }        
}
{define-class public open StandardDateCell
  {inherits StandardBaseEditableStringCell}

  {doc-next
    {purpose Create a new {docref StandardDateCell}.}
  }
  {constructor public {default}
    {construct-super}
  }
  
  
  {method protected open {create-editor}:Graphic
    {return {SRGDateField}}
  }
  
  
  {getter public open {current-editor}:#SRGDateField 
    {return super.current-editor asa #SRGDateField}
  }
  
  
  {method public open {refresh-data}:void
    || DateField fires ValueFinished when you set its value.
    {super.refresh-data}
    let constant (data:any, valid?:bool) = {self.get-data}
    let data-set?:bool = false
    {if valid? then
        {type-switch data
         case dt:DateTime do
            {if-non-null editor = self.current-editor then 
                set editor.value = dt
                set data-set? = true
                {if self.field.domain isa LocaleDateDomain then
                    set editor.date-format-spec = DateFieldFormatSpec.local
                 else
                    set editor.date-format-spec = DateFieldFormatSpec.iso
                }
            }
        }
    }
    {if not data-set? then
        {if-non-null editor = self.current-editor then
            {editor.unset-value}
        }
    }
  }
  
  
  {method public open {become-active forward?:bool = true}:bool
    let ret:bool = {super.become-active forward? = forward?}   
    {if ret then
        {if-non-null editor = self.current-editor then 
            {editor.become-active forward? = forward?}
        }
    }
    {return ret}
  }  
  

}

|| ---------------------------------------------------------------------------

{doc-next
    {purpose
        Perform a depth first treewalk on the tree nodes stored
        in {param rs}, applying {param pre} before visiting each node,
        and {param post} afterwards.
    }
    {parameter id-field, The name of the field that uniquely identifies each
        record.
    }
    {parameter rs, A {docref RecordSet} containing a tree where each
        child points to its parent via the field given by {param
        pid-field}, as described for {docref TreeGrid}.
    }
    {parameter pre, A procedure that is called on a record before visiting
        it's children. The procedure is passed the record and it's
        children in an array.
    }
    {parameter post, A procedure that is called on a record immediately after
        visiting all of it's children. The procedure is passed the
        record and it's children in an array.
    }
}
{define-proc public {walk-record-tree
                        rs:RecordSet,
                        id-field:String = "_id", ||""
                        pid-field:String = "_pid", ||""
                        pre:#{proc-type {
                                         parent:Record,
                                         child-records:{Array-of Record}
                                        }:void
                             } = null,
                        post:#{proc-type {
                                          parent:Record,
                                          child-records:{Array-of Record}
                                         }:void
                              } = null,
                        parent-id:int = 0
                    }:void
    {with rs.batch-events? = true do
        let parents:{Array-of Record} =
            {if parent-id == 0 then
                || Find all the roots (records with no parent)
                {rs.select filter = 
                    {proc {fr:Record}:bool
                        {return fr[pid-field] == 0
                            and fr.state != RecordState.deleted
                            and fr.state != RecordState.new
                            and fr.state != RecordState.detached
                        }
                    }
                }
             else
                || Find the one record for parent-id and compute from there
                def a = {new {Array-of Record}}
                {if-non-null r =
                    {rs.select-one
                        filter = 
                            {proc {fr:Record}:bool
                                {return fr[id-field] == parent-id
                                    and fr.state != RecordState.deleted
                                    and fr.state != RecordState.new
                                    and fr.state != RecordState.detached
                                }
                            }
                    }
                 then
                    {a.append r}
                }
                a
            }

        {for parent in parents do
           def children = 
                {rs.select filter =
                    {proc {fr:Record}:bool
                        {return fr[pid-field] == parent[id-field]
                            and fr.state != RecordState.deleted
                            and fr.state != RecordState.new
                            and fr.state != RecordState.detached
                        }
                    }
                }
            {if-non-null pre then
                {pre parent, children}
            }
            {for cr:Record in children do
                {walk-record-tree
                    rs, id-field = id-field, pid-field = pid-field,
                    pre = pre, post = post,
                    parent-id = cr[id-field] asa int
                }
            }
            {if-non-null post then
                {post parent, children}
            }
        }
    }
}

|| ---------------------------------------------------------------------------

{doc-next
    {purpose An enhanced version of {docref CsvRecordSet}.}
    {details
        A {ctext CsvRecordSetB} implements the following enhancements
        {itemize
            {item
                A csv file is automatically created if no file exists
            }
            {item
                Automatically re-reads the disk file if it is
                modified.  If there are unsaved changes, a dialog is
                presented to the user. The modifications on the disk
                file can be ignored (and possibly overwritten later),
                or the changes that have not yet been committed can be
                discarded.
            }
            {item
                Optionally maintains a unique id column and provides a
                new unique upon request and when a new record is
                created ({docref CsvRecordSetB.new-record}).
            }
        }
    }
}
{define-class public open CsvRecordSetB {inherits CsvRecordSet}

  field protected when-last-modified:#DateTime
  field protected timer:Timer


  {doc-next
    {purpose The field that uniquely identifies each record, if any.}
    {details
        If this field is non blank, the method {docref
        CsvRecordSetB.new-id} will return an id value that is higher
        than any other among the records contained in this recordset.
    }
  }
  field public-get protected-set id-field:String = "" ||""

  field private id-filter:RecordData = {RecordData}

  {method protected open {update-last-modified}:void
    {try
        set self.when-last-modified =
            ({self.url.instantiate-File} asa File).when-last-modified
     catch e:IOException do
        set self.when-last-modified = null
        || ignore
    }
  }

  {setter public open {modifiable? v:bool}:void
    set super.modifiable? = v
  }

  {getter public open {mod-count}:int
    {return self.change-count}
  }

  {doc-next
    {purpose
        Return true if this recordset was created with a null {param
        url} and consequently is not stored on disk.
    }
  }
  {getter public open {temporary?}:bool
    {return self.url == {get-base-url}}
  }

  {doc-next
    {purpose Initialize a new {docref CsvRecordSetB}.}
    {parameter url,
        The location where this recordset is stored, of null if it
        is intended to be temporary.
    }
    {parameter fields,
        The {docref RecordFields} that define the structure of this
        recordset.
    }
    {parameter modifiable?, If true, modification of the data will be
        allowed, provided that it is legal to write to the {param url}.        
    }
    {parameter character-encoding, The encoding to be used when reading
        and writing the data.
    }
    {parameter backup?, Provides the initial value for {docref
        CsvRecordSet.backup?}.
    }
    {parameter autoupdate-interval, The
    }
    {parameter ..., Event handlers for {docref RecordSetEvent}s.
    }
  }
  {constructor public {default
                          url:#Url,
                          fields:RecordFields,
                          id-field:String = "", ||""
                          modifiable?:bool = true,
                          character-encoding:CharEncoding = "utf8", ||""
                          backup?:bool = false,
                          autoupdate-interval:Time = 5s,
                          ...:EventHandler
                      }
    set self.id-field = id-field
    ||FIXME: support http in read-only mode
      
    set self.url = {if-non-null url then url else {get-base-url}}
    {self.update-last-modified}
    {if self.when-last-modified == null then
        let header:StringArray = 
            {StringArray 
                {format "Created %s", {DateTime}.info.iso-full} ||""
            }
        let fbuf:StringBuf = {StringBuf}
        {for f:RecordField in fields do
            {if fbuf.size > 0 then
                {fbuf.append ','}
            }
            {fbuf.concat f.name}
        }
        {header.append {fbuf.to-String}}
        {construct-super.create
            self.url,
            fields,
            header = header,
            modifiable? = modifiable?,
            character-encoding = character-encoding,
            backup? = backup?,
            {splice ...}
        }
     else
        {construct-super
            self.url,
            fields = fields,
            header-line-count = 2,
            modifiable? = modifiable?,
            character-encoding = character-encoding,
            backup? = backup?,
            {splice ...}
        }
        {self.update-last-modified}
    }
    set self.timer = 
        {Timer
            enabled? = true,
            interval = autoupdate-interval,
            {on TimerEvent do
                {self.refresh-from-file}
            }
        }
    {if autoupdate-interval <= 0s then
        set self.timer.enabled? = false
    }
  }

  ||FIXME: This is not very efficient but maybe it doesn't matter
  || since it is only called when a new record is added, which is
  || relatively rare.
  {doc-next
    {purpose Return a new unique id value.}
  }
  {method public open {new-id}:int

    || Find the highest ID currently in use
    let last-id:int = 0
    {for r:Record in self do
        let recid:int = r[self.id-field] asa int
        {if recid > last-id then
            set last-id = recid
        }
    }
    || Return the next unused id
    {return last-id + 1}
  }

  {doc-next
    {purpose Return the {docref Record} identified by {param id}.}
  }
  {method public open {get-by-id id:int}:#Record
    {self.id-filter.clear}
    set self.id-filter[self.id-field] = id
    {return {self.select-one filter = self.id-filter}}
  }
  || Allocate a new record with a unique id
  {method public open {new-record}:BasicRecord
    let nr:BasicRecord = {super.new-record}
    {if self.id-field != "" then
        set nr[self.id-field] = {self.new-id}
    }
    {return nr}
  }

  {doc-next
    {purpose
        Return true if the disk file has been changed since last read
        or written.
    }
  }
  {getter public open {file-changed?}:bool

    let last-modified:#DateTime = null
    {if {self.url.name.prefix? "file:"} then ||""
        {try
            set last-modified =
                ({self.url.instantiate-File} asa File).when-last-modified
         catch e:IOException do
            || ignore
        }
    }

    {if-non-null last-modified then
        {if self.when-last-modified == null then
            {return true}
         else
            def diff = {self.when-last-modified.compare last-modified}
||--            {dump diff, self.url.basename}
            {return {self.when-last-modified.compare last-modified} != 0}
        }
     else
        || If both are null or the same then it is not changed.
        {return last-modified != self.when-last-modified}
    }
  }

  {doc-next
    {purpose Return true if there have been changes sinde the data file was
        last read or written.
    }
    {details
        This is always true for a temporary recordset, that is,
        if {docref CsvRecordSet.temporary} is true.
    }
  }
  {getter public open {records-changed?}:bool
    {return self.temporary? or self.change-count != self.change-count-at-commit}
  }

  {method public open {load}:void
    {if not self.temporary? then
        {super.load}
        {self.update-last-modified}
    }
  }

  {method public open {commit}:void

    {if self.temporary? then
        {return}
    }

    {if self.file-changed? then
        {if self.records-changed? then

            def dt = {DateTime}
            def ext = self.url.extension
            def cfn = self.url.name
            def tfn = {cfn.substr 0, cfn.size - ext.size}
            & {format "-%s-%02d%02d-%02d%02d%02d", ||""
                  dt.info.year, dt.info.month, dt.info.day, 
                  dt.info.hour, dt.info.minute, dt.info.second}
            & ext & "~" ||""
            def tfu = {url tfn}                    

            || Ask if you want to ignore, move to backup, or clobber
            {if {popup-question 
                    title = "File Changed: " & self.url.local-filename, ||""
                    {VBox spacing = 9pt,
                        {hlmessage The file {value self.url.filename}
                            was changed on disk. Do you want to save
                            anyway?
                        },

                        {hlmessage If you answer yes, the disk file
                            will be renamed to {value tfu.filename}
                        },

                        {hlmessage If you answer no, your pending
                            changes will be replaced with data
                            from the file.
                        }
                    }
                } == Dialog.yes
             then
                {try
                    {rename self.url, tfu}
                 catch e:IOException do
                    {popup-message "Rename failed"} ||""
                    {return}
                }
             else
                {self.load}
                {return}
            }
        }
    }

    {if {self.url.name.find-string "http:"} != 0 then
        {super.commit}
        {self.update-last-modified}
    }
  }

  {doc-next
    {purpose
        Reload the data from the associated file ({docref CsvRecordSetB.url}).
    }
  }
  {method public open {refresh-from-file}:void
    || Refresh if file has changed but not if there are unsaved changes
    {if not self.records-changed? then
        {if self.file-changed? then
            {self.load}
        }
    }
  }

  {doc-next
    {purpose Write the records to a new location.} 
  }
  {method public open {save-as location:Url}:void
    || Switch to the new location
    set self.url = location
    {self.update-last-modified}
    set self.backup-done? = true
    {inc self.change-count} || Required or commit might do nothing
    {self.commit}
  }


  {doc-next
    {purpose Return the unique values in one or more columns.}
    {for-example
        {curl-code
            def choices = {rs.unique-values-in-columns "first", "last"}
        }
    }
    {details
        In this example, choices will be a sorted array of all values
        found in the "first" and "last" columns, with duplicates
        removed and no blank values.
    }
    {parameter sort?, If true, the result will be sorted.}
    {parameter remove-blank?,
        If true, an empty string in a column is ignored.
    }
    {parameter ..., Names of the fields (columns) to be examined.}
  }
  {method public open {unique-values-in-columns
                          sort?:bool = true,
                          remove-blank?:bool = true,
                          ...:String || field names
                      }:StringArray
    let records:{Array-of Record} = {self.select}

    let values:Set = {Set}            || Set of unique values
    let value-list:StringArray = {StringArray} || Values in order seen
    {for field in ... do
        let fd:Domain = self.fields[field].domain
        {for r:Record in records do
            let fv:String = {fd.format r[field]}
            {if fv == "" and remove-blank? then
                {continue}
            }
            {if not {values.member? fv} then
                {value-list.append fv}
                {values.insert fv}
            }
        }
    }
    {if sort? then
        {value-list.sort}
    }
    {return value-list}
  }

  {doc-next
    {purpose
        Return a {docref DefaultListModel} for the values in a column.
    }
    {details
        The returned list model will contain the values in the column
        identified by {param field} in alphabetical order (reversed if
        {param reverse?} is true), with duplicates removed.

        An event handler is added to this recordset so that if a
        record is added or changed, the list model will be updated.

        The values in the model will be values from the column. If
        you need to convert the value to a string for display in a
        {docref ListBox} or other control that uses the result, you
        can supply a {ctext list-item-creation-proc} when you create
        the {ctext ListBox}.
    }
  }
  {method public open {get-list-model
                          field:String,
                          include-blank?:bool = false,
                          reverse?:bool = false
          }:DefaultListModel

    let dlm:DefaultListModel = {DefaultListModel}
    let rf:RecordField = self.fields[field]

    let update-proc:{proc-type {}:void} =
        {proc {}:void 
            let values:Set = {Set}
            {dlm.clear}
            {for r:Record in self do
                def fval = {rf.domain.format r[field]}
                let include?:bool = fval != "" or include-blank?
                let fv:any = r[field]
                {if include? and not {values.member? fv} then
                    {dlm.append-quietly fv}
                    {values.insert fv}
                }
            }
            {dlm.sort comparison-proc = 
                {proc {a:any, b:any}:bool
                    {return
                        {if reverse? then
                            {rf.domain.compare a, b} > 0
                         else
                            {rf.domain.compare a, b} <= 0
                        }
                    }
                }
            }
        }

    {self.add-event-handler
        {on e:RecordModified at rs:RecordSet do
            {update-proc}
        }
    }
    {update-proc}
    {return dlm}
  }
}

{define-class public open JsonRecordSet {inherits LocalRecordSet}

  {doc-next
    {purpose The field that uniquely identifies each record, if any.}
    {details
        If this field is non blank, the method {docref
        CsvRecordSetB.new-id} will return an id value that is higher
        than any other among the records contained in this recordset.
    }
  }
  field public-get protected-set id-field:String = "" ||""

  field private id-filter:RecordData = {RecordData}


  {constructor public {default
                          fields:RecordFields,
                          modifiable?:bool = true,
                          id-field:String = "", ||""
                          ...:Object
                      }
    {construct-super.LocalRecordSet fields, modifiable? = modifiable?, ...}
    set self.id-field = id-field
  }

  ||FIXME: This is not very efficient but maybe it doesn't matter
  || since it is only called when a new record is added, which is
  || relatively rare.
  {doc-next
    {purpose Return a new unique id value.}
  }
  {method public open {new-id}:int

    || Find the highest ID currently in use
    let last-id:int = 0
    {for r:Record in self do
        let recid:int = r[self.id-field] asa int
        {if recid > last-id then
            set last-id = recid
        }
    }
    || Return the next unused id
    {return last-id + 1}
  }

  {doc-next
    {purpose Return the {docref Record} identified by {param id}.}
  }
  {method public open {get-by-id id:int}:#Record
    {self.id-filter.clear}
    set self.id-filter[self.id-field] = id
    {return {self.select-one filter = self.id-filter}}
  }

  || Allocate a new record with a unique id
  {method public open {new-record}:BasicRecord
    let nr:BasicRecord = {super.new-record}
    {if self.id-field != "" then
        set nr[self.id-field] = {self.new-id}
    }
    {return nr}
  }

  field private buf:StringBuf = {StringBuf}

  {method public open {escape-quotes s:String}:String
    {if {s.find '\"'} == -1 then
        {return s}
    }
    {self.buf.clear}
    {for c in s do
        {if c == '\"' then
            {self.buf.append '\\'}
        }
        {self.buf.append c}
    }
    {return {self.buf.to-String}}
  }

  || From worksheet.scurl, should be in EXT.DATA-ACCESS
  {method public open {to-Json}:JsonObject
    def data = {JsonObject}
    def records = {JsonArray}
    set data["records"] = records
    {for r in self do
        def rdata = {JsonObject}
        {for f in self.fields do
            set rdata[f.name] =
                {self.escape-quotes {f.domain.format r[f.name]}}
        }
        {records.append rdata}
    }
    {return data}
  }

  {method public open {load-from-Json records:JsonArray}:void
    {with self.batch-events? = true do
        {self.delete-all}
        {self.commit}
        {for rd in records do
            def rdo = rd asa JsonObject
            def r = {self.new-record}
            {for f in self.fields do
                set r[f.name] = {f.domain.parse rdo[f.name] asa String}
            }
            {self.append r}
        }
        {self.commit}
    }
  }
}


|| ---------------------------------------------------------------------------

||FIXME: Need to find a way to localize these... hlmessage isn't const
{doc-next
    {purpose Describes how often an event repeats.}
}
{define-enum public RepeatPeriod
    none = "None",
    day = "Daily",
    weekday = "Weekdays",
    m-w-f = "M/W/F",
    t-th = "Tues/Thur",
    week = "Weekly",
    month = "Monthly, same date",
    month-day = "Monthly, same day and week",
    year = "Yearly",
    year-month-day = "Yearly, same day and week"
}

{doc-next
    {purpose
        An instance of a domain to be used for defining a {docref
        RecordField} for {docref RepeatPeriod}.
    }
}
{def public RepeatPeriod-domain =
    {new {EnumDomain-of RepeatPeriod}}
}

{doc-next
    {purpose An interface used to model recurring events.}
}
{define-class abstract public open BaseEventSpec
  
  field protected sample-date:DateTime = {DateTime}

  ||FIXME: maybe this should only be in the RecordSet based versions
  {setter abstract public open {id i:int}}
  {getter abstract public open {id}:int}

  {setter abstract public open {descr v:String}}
  {getter abstract public open {descr}:String}

  {setter abstract public open {first v:DateTime}}
  {getter abstract public open {first}:DateTime}

  {setter abstract public open {final v:#DateTime}}
  {getter abstract public open {final}:#DateTime}

  {setter abstract public open {who v:int}}
  {getter abstract public open {who}:int}

  {setter abstract public open {start v:Time}}
  {getter abstract public open {start}:Time}

  {setter abstract public open {duration v:Time}}
  {getter abstract public open {duration}:Time}

  {setter abstract public open {repeat v:RepeatPeriod}}
  {getter abstract public open {repeat}:RepeatPeriod}


  || Adjust a date to the local time zone, so a time can be added
  {method protected open {event-date date:DateTime}:DateTime
    def date-only? = date.zone.mode == DateTimeZoneMode.utc
    {if date-only? then
        {return  date}
    }
    def dt = {DateTime date, zone = self.sample-date.zone}
    def zdt = 
        {DateTime
            dt,
            year = date.info.year,
            month = date.info.month,
            day = date.info.day
        }
    {return zdt}
  }

  {method protected open {get-week-of-month dt:DateTime}:int
    def day-of-week = dt.info.day
    def first-day-of-week = {DateTime dt, day = 1}.info.day-of-week
    def offset = day-of-week - first-day-of-week
    {return (first-day-of-week + offset) div 7}
  }

  {method public open {scheduled? d:DateTime}:bool
    def date-only? = d.zone.mode == DateTimeZoneMode.utc
    {if not date-only? then
        ||FIXME: look at both time and date
||--        set d = {DateTime.date d}
    }

    {if d < self.first then
        {return false}
    }
    {if-non-null final = self.final then
        {if d > final then
            {return false}
        }
    }

    {switch self.repeat
     case RepeatPeriod.none do
        {return d == self.first}
     case RepeatPeriod.day do
        {return true}
     case RepeatPeriod.weekday do
        {return d.info.day >= 1 and d.info.day <= 5}
     case RepeatPeriod.m-w-f do
        {return d.info.day == 1 or d.info.day == 3 or d.info.day == 5}
     case RepeatPeriod.t-th do
        {return d.info.day == 2 or d.info.day == 4}
     case RepeatPeriod.week do
        {return d.info.day-of-week == self.first.info.day-of-week}
     case RepeatPeriod.month do
        {return d.info.day == self.first.info.day}
     case RepeatPeriod.month-day do
        {if self.first.info.day-of-week == d.info.day-of-week then
            {return 
              {self.get-week-of-month d} == {self.get-week-of-month self.first}
            }
        }
     case RepeatPeriod.year do
        {return
            d.info.day == self.first.info.day 
            and d.info.month == self.first.info.month
        }
     case RepeatPeriod.year-month-day do
        {if self.first.info.day-of-week == d.info.day-of-week 
            and self.first.info.month == d.info.month
         then
            {return 
              {self.get-week-of-month d} == {self.get-week-of-month self.first}
            }
        }
    }
    {return false}
  }

  {getter public open {repeats?}:bool
    {return self.repeat != RepeatPeriod.none}
  }

  ||FIXME: only works with values from an iterator! At least give an error
  || if the date is not actually in the series
  {method public open {get-event-begin date:DateTime}:#DateTime
    {if {self.scheduled? date} then
        {return
            {DateTime
                {self.event-date date},
                second = (self.start/1s) asa int
            }
        }
     else
        {return null}
    }
  }
  
  {method public open {get-event-end date:DateTime}:#DateTime
    {if {self.scheduled? date} then
        {if-non-null nd = {self.get-event-begin date} then
            {return nd + self.duration}
        }
    }
    {return null}
  }

  {doc-next
    {purpose Return the date of the next occurrence of this event after
        {param d} or null if there is none.
    }
  }
  {method public open {next-occurrence d:DateTime}:#DateTime
    {if {self.scheduled? d} then
        let nd:#DateTime = null
        {switch self.repeat
         case RepeatPeriod.none do
            || nothing more to do
         case RepeatPeriod.day do
            set nd = d + 1d
         case RepeatPeriod.m-w-f do
            {switch d.info.day
             case 1, 3 do
                set nd = d + 2d
             case 5 do
                set nd = d + 3d
            }
         case RepeatPeriod.t-th do
            {switch d.info.day
             case 2 do
                set nd = d + 2d
             case 4 do
                set nd = d + 5d
            }
         case RepeatPeriod.week do
            set nd = d + 7d
         case RepeatPeriod.month do
            set nd = {DateTime d, month = d.info.month + 1}
         case RepeatPeriod.month-day do
            set nd =
                {DateTime d,
                    month = d.info.month + 1,
                    day = d.info.day
                }
            def day-of-week = nd.info.day-of-week
            def first-day-of-week = {DateTime self.first}.info.day-of-week
            let offset:int = day-of-week - first-day-of-week
            let nday:int = d.info.day - offset
            {if nday > 7 then
                {dec nday, 7}
            }
            set nd = {DateTime 
                         nd,
||--                     month = d.info.month + 1
                         day = nday
                     }
         case RepeatPeriod.year do
            set nd = {DateTime d, year = d.info.year + 1}
        }
        {if-non-null nd then
            {if-non-null final = self.final then
                {return {if nd <= final then nd else null}}
            }
            {return nd}
        }
    }
    {return null}
  }


  {method public open {get-Iterator
                          start:DateTime,
                          end:DateTime
                      }:{Iterator-of DateTime}
    {return {EventIterator self, start, end = end}}
  }

  {method public open {to-Iterator}:{Iterator-of DateTime}
    {return {EventIterator self, self.first}}
  }

}


{doc-next
    {purpose An implementation of {docref BaseEventSpec} that
        has a field for each event attribute.
    }
}
{define-class public open EventSpec {inherits BaseEventSpec}

  field protected _id:int
  field protected _descr:String
  field protected _first:DateTime
  field protected _final:#DateTime
  field protected _who:int
  field protected _start:Time
  field protected _duration:Time
  field protected _repeat:RepeatPeriod

  {constructor public {default
                          first:DateTime,
                          final:#DateTime,
                          id:int = 0,
                          descr:String = "",
                          who:int = 0,
                          start:Time = 0s,
                          duration:Time = 0s,
                          repeat:RepeatPeriod = RepeatPeriod.none
                      }
    || DateTime.date only
||--    {assert first.zone.mode == DateTimeZoneMode.utc}
||--    {assert final.zone.mode == DateTimeZoneMode.utc}

    set self._id = id
    set self._descr = descr
    set self._first = first
    set self._final = final
    set self._who = who
    set self._start = start
    set self._duration = duration
    set self._repeat = repeat
  }
  
  {setter public open {id v:int}
    set self._id = v
  }
  {getter public open {id}:int
    {return self._id}
  }

  {setter public open {descr v:String}
    set self._descr = v
  }
  {getter public open {descr}:String
    {return self._descr}
  }


  {setter public open {first v:DateTime}
    set self._first = v
  }
  {getter public open {first}:DateTime
    {return self._first}
  }


  {setter public open {final v:#DateTime}
    set self._final = v
  }
  {getter public open {final}:#DateTime
    {return self._final}
  }


  {setter public open {who v:int}
    set self._who = v
  }
  {getter public open {who}:int
    {return self._who}
  }


  {setter public open {start v:Time}
    set self._start = v
  }
  {getter public open {start}:Time
    {return self._start}
  }


  {setter public open {duration v:Time}
    set self._duration = v
  }
  {getter public open {duration}:Time
    {return self._duration}
  }


  {setter public open {repeat v:RepeatPeriod}
    set self._repeat = v
  }
  {getter public open {repeat}:RepeatPeriod
    {return self._repeat}
  }

}


{define-class public final EventIterator {inherits {Iterator-of DateTime}}

  field private constant es:BaseEventSpec
  field private current:DateTime
  field private start:DateTime
  field private end:#DateTime
  field private day:int = 0

  {constructor public {default
                          es:BaseEventSpec,
                          start:DateTime,
                          end:#DateTime = es.final
                      }
    set self.es = es
    set self.current = start || keep the compiler happy
    set self.start = start
    set self.end = end
    {self.reset}
  }

  {method public {reset}:void
    set self.current = self.start - 1d
  }

  {method public {read-one}:(event:DateTime, eof?:bool)

    || Have already reached the end?
    {if-non-null final = self.end then
        {if self.current >= final then
            {return {uninitialized-value-for-type DateTime}, true}
        }
    }

    || First time?
    {if self.current < self.es.first then
        set self.current = self.es.first
        {return (self.current, false)}
    }

    || Return the next date in the sequence, if any
    let nd:#DateTime = {self.es.next-occurrence self.current}
    {if-non-null nd then
        {if self.end == null or nd <= {non-null self.end} then
            set self.current = nd
            {return (self.current, false)}
        }
    }
    {return {uninitialized-value-for-type DateTime}, true}
  }
}

||FIXME: this is an experiment... not used yet
{doc-next
    {purpose  
        An implementation of the {docref Record} class 
        for use by {docref DefaultRecordView}.
    }
    {details
        After a check on the modifiability of the
        containing {docref RecordView}, all method calls 
        and properties are simply redirected to the corresponding
        methods and properties on the {docref DelegatingRecord.source-record}. 
    }
}
{define-class public open TreeRecord {inherits Record}

  {doc-next
    {purpose 
        The {docref DefaultRecordView} which contains this record.
    }
  }
  field public-get protected-set record-view:DefaultRecordView 

  {doc-next
    {purpose 
        The record in the containing view's {ctext source}
        which this record delegates to.
    }
  }
  field public-get protected-set source-record:Record 
 

  {doc-next 
    {purpose 
        Construct a new {ctext DelegatingRecord}.
    }
  }
  {constructor public {default 
                          record-view:DefaultRecordView,
                          source-record:Record
                      }
    
    set self.record-view = record-view
    set self.source-record = source-record
  }

  ||--------------------------------
  || Methods to implement Record
  ||--------------------------------
  {getter public open {record-set}:#RecordSet
    {return self.record-view}
  }
   
  {getter public open {state}:RecordState
    {return self.source-record.state}
  }
 
    
  {method public open {get
                          name:String,
                          pending?:bool=true
                      }:any
    {return {self.source-record.get name, pending?=pending?}}
  }
  
  {method public open {get-by-index
                          field-index:int, 
                          pending?:bool = true
                      }:any
    {return {self.source-record.get-by-index field-index, pending? = pending?}}
  }

  {method public open {set 
                          name:String, 
                          val:any
                      }:void  
||--    {self.record-view.ensure-modifiable}
    {self.source-record.set name, val}
  }

  {method public open {validate-value
                          name:String, 
                          val:any
                      }:#ValidationException
    {return
        {self.source-record.validate-value name, val}
    }
  }
  
  {method public open {commit}:void
||--    {self.record-view.ensure-modifiable}
    {self.source-record.commit}
  }
 
  {method public open {revert}:void
||--    {self.record-view.ensure-modifiable}
    {self.source-record.revert}
  }
  
  {method public open {delete}:void
||--    {self.record-view.ensure-modifiable}
    {self.source-record.delete}
  }
}

|| -----------------------------------------------------------------------------

{doc-next
    {purpose
        A collection that can be used as both an array and a set.
    }
}
{define-class public open {OrderedSet-of
                            t:Type,
                            key-hash-proc:any = value-hash,
                            key-equality-proc:any = equal?
                          }
 
  field private constant _set:{Set-of t,
                                key-hash-proc = key-hash-proc,
                                key-equality-proc = key-equality-proc
                              } = {new {Set-of
                                           t,
                                           key-hash-proc = key-hash-proc,
                                           key-equality-proc = key-equality-proc
                                       }
                                  }

  field private constant _array:{Array-of t} = {{Array-of t}}
  
  {constructor public {default}}
  
  {getter public open {size}:int
    {return self._set.size}
  }

  {getter public open {efficient-size}:int
    {return self._array.efficient-size}
  }
  {setter public open {efficient-size i:int}:void
    set self._array.efficient-size = i
    set self._set.efficient-size = i
  }
  
  {method public open {member? v:t}:bool
    {return {self._set.member? v}}
  }

  {method public open {insert v:t, error-if-present?:bool=true}:void
    let place-in-array?:bool = error-if-present? or not {self._set.member? v}
    {self._set.insert v, error-if-present? = error-if-present?}
    {if place-in-array? then
        {self._array.append v}
    }
  }

  {method public open {remove v:t, error-if-missing?:bool=true}:void
    {self._set.remove v, error-if-missing? = error-if-missing?}
    {if self._array.size > 2 * self._set.size then
        {self.cull-stale-members}
    }
  }

  {method public open {clear}:void
    {self._set.clear}
    {self._array.clear}
  }

  {method public open {to-Iterator}:{Iterator-of t}
    {self.cull-stale-members}
    {return {self._array.to-Iterator}}
  }
  
  {method private {cull-stale-members}:void
    {if self._set.size != self._array.size then
        {self._array.filter
            {proc {v:t}:bool {return {self._set.member? v}}}
        }
    }
  }

  {doc-next
    {purpose Return this collection as a {docref Set-of} t.}
  }
  {method public open {as-Set}:{Set-of t,
                                   key-hash-proc = key-hash-proc,
                                   key-equality-proc = key-equality-proc
                               }
    {return self._set}
  }

  {doc-next
    {purpose Return this collection as an {docref Array-of} t.}
  }
  {method public open {as-Array}:{Array-of t}
    {return self._array}
  }
}

|| -----------------------------------------------------------------------------

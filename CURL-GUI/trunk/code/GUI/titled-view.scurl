||| Copyright 1998-2010, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.
|||
||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.
||| ----------------------------------------------------------------------------


{doc-next
    {purpose Represents a customized stylable Curl window on the screen,
        containing Curl graphical content.
    }
    {details
        A standard {docref View} in Curl uses the platform title bar
        and border. If you are building a highly customized user
        interface, you might want to style the title bar to match the
        rest of the applet. The {ctext TitledView} allows you to do
        this because it obtains a borderless window from the host
        operating system and constructs the title bar and borders using
        Curl graphical components.

        To customize the appearance, you can use the following
        {docref-abbr Visual.style-element} values in your style rules.

        {Table
            columns = 3,
            border-width = 1in/300,
            border-color = "black",
            horizontal-line-width = 1in/300,
            vertical-line-width = 1in/300,
            cell-border-width = 0pt,
            cell-margin = 2pt,
            {header-cell style-element},
            {header-cell Type},
            {header-cell Description},

            {ctext TitledView}, {docref TitledView},
            {text The {ctext TitledView} itself. You can use style rules
                to set local and nonlocal options.
            },

            {ctext TitledView/content}, {docref ClipFrame},
            {text The innermost component of the {ctext TitledView}.
                When the {docref TitledView.add} method is called,
                the {docref Graphic} you add is actually added to this
                {ctext ClipFrame}. The default style rule simply gives
                this Frame a border-width of 1 pixel.
            },

            {ctext TitledView/min-button}, {docref CommandButton},
            {text This is the minimize button in the title bar. It can be
                skinned as you would skin any other {ctext CommandButton}.
            },

            {ctext TitledView/max-button}, {docref CommandButton},
            {text This is the maximize button in the title bar.
            },

            {ctext TitledView/close-button}, {docref CommandButton},
            {text This is the close button in the title bar.
            },

            {ctext TitledView/resizer}, {docref SkinnableFill},
            {text This is a {ctext SkinnableFill} that is stretched
                across the entire window.  Normally just the four
                edges of this {ctext Fill} are visible.
||FIXME
||--                , in an amount
||--                specified by {docref TitledView.resizer-width.  
                When
                the mouse is over one of the four edges, it will show
                a resize cursor.  You can use a {docref
                ShadedSkinSpec} for a solid color or gradient, or you
                can use an {docref ImageSkinSpec} for more complete
                control of the appearance of the edges.
            },

            {ctext TitledView/titlebar}, {docref SkinnableFrame},
            {text This is the {ctext SkinnableFrame} that contains
                the elements of the title bar (the title and buttons).
            }
        }

        Here is a small example of a {ctext TitledView}. Note that the
        Close and OK buttons do not actually do anything. Use the
        close box in the upper right corner to close the window that
        is displayed when you click the button.
        {example
            title = {lmessage A TitledView},
            {import * from COM.CURL.EXT.GUI}
            {CommandButton
                label = "Display a TitledView",
                {on Action do
                    def tv =
                        {TitledView
                            title = "Sample TitledView",
                            margin = 6pt,
                            font-size = 10pt,
                            {Table columns = 2, valign = "top",
                                {text Notes:},
                                {TextArea width = 2in, height = 1in},
                                {skip},
                                {HBox spacing = 6pt, 
                                    {Fill}, {ok-button}, {cancel-button}
                                }
                            }
                        }
                    {tv.show}
                }
            }
        }
    }
}
{define-class public open TitledView {inherits View}

  || Decorations
  field private grid:#Grid
  field private title-hbox:#HBox || incon and title-frame
  field private buttons-hbox:#HBox
  field private icon-frame:#Frame
  field private title-frame:#ClipFrame || ClipFrame containing title text
  field private title-bar-frame:#SkinnableFrame
  field private content-frame:#Frame
  field private outer-fill:#SkinnableFill

  || Resizing borders
  field private left-fill:#Fill
  field private right-fill:#Fill
  field private bottom-fill:#Fill
  field private top-fill:#Fill
  field private bottom-right-vfill:#Fill
  field private bottom-right-hfill:#Fill
  field private bottom-left-vfill:#Fill
  field private bottom-left-hfill:#Fill
  field private top-left-vfill:#Fill
  field private top-left-hfill:#Fill
  field private top-right-vfill:#Fill

  || TitleBar buttons
  field private cmd-min:#CommandButton
  field private cmd-max:#CommandButton
  field private cmd-close:#CommandButton

  || Inactive window look and feel
  {doc-next
    {purpose A {docref SkinSpec} for the title-bar of {docref TitledView} when
        {docref TitledView} does not have a focus. Default value is set to the
        {docref SkinSpec} specifying the {ctext gray} shade.
    }
  }
  field protected inactive-titlebar-skin:#SkinSpec

  {doc-next
    {purpose A {docref SkinSpec} for the border of {docref TitledView} when
        {docref TitledView} does not have a focus. Default value is set to the
        {docref SkinSpec} specifying the {ctext gray} shade.
    }
  }
  field protected inactive-border-skin:#SkinSpec

  {doc-next
    {purpose A {docref SkinSpec} for the {ctext Minimize} button of
        {docref TitledView} when {docref TitledView} does not have a focus.
        Default value is set to the {docref SkinSpec} specifying the
        {ctext gray} shade.
    }
  }
  field protected inactive-min-skin:#SkinSpec

  {doc-next
    {purpose A {docref SkinSpec} for the {ctext Maximize} button of
        {docref TitledView} when {docref TitledView} does not have a focus.
        Default value is set to the {docref SkinSpec} specifying the
        {ctext gray} shade.
    }
  }
  field protected inactive-max-skin:#SkinSpec

  {doc-next
    {purpose A {docref SkinSpec} for the {ctext Close} button of
        {docref TitledView} when {docref TitledView} does not have a focus.
        Default value is set to the {docref SkinSpec} specifying the
        {ctext gray} shade.
    }
  }
  field protected inactive-close-skin:#SkinSpec

||FIXME: implement this
||--  {doc-next
||--    {purpose The width of the edges of the window used for resizing.}
||--  }
||--  {local-option public resizer-width:any = 4px
||--  }

  {local-option public disabled-color:FillPattern = FillPattern.gray
    set self.inactive-titlebar-skin = null
    set self.inactive-border-skin = null
    set self.inactive-min-skin = null
    set self.inactive-max-skin = null
    set self.inactive-close-skin = null
  }

||--  || width and height of various decorations
||--  {doc-next
||--    {purpose The width of border of {docref TitledView}.}
||--  }
||--  let public-get private-set border-size:PixelDistance = 4px
        ||FIXME: would be nice if this were a local option
        let package border-size:PixelDistance = 4px

  {doc-next
    {purpose A length of corner borders of {docref TitledView}.}
    {notes Corner borders are used to resize the {docref TitledView}
        diagonally.
    }
  }
  let public-get private-set corner-size:PixelDistance = 12px

  || Resizing constraints, derived class can have its own specified
  || minimum values.  Ideally for correct functionality these values
  || should not be 0
  {doc-next
    {purpose Minimum width for the {docref TitledView}.}
  }
  field protected minimum-width:Distance = 5cm

  {doc-next
    {purpose Minimum height for the {docref TitledView}.}
  }
  field protected minimum-height:Distance = 2cm

  || For moving the View when dragged from title bar
  field private drag-started?:bool
  field private motion-alarm:Alarm

  {doc-next
    {purpose Used to remember if dragging was started with the left button.}
  }
  field protected left-button?:bool

  || These are in display coordinates.  drag-start-view-* represent the
  || bounds of the view at the time the drag started.  These
  || are all captured in handle-pointer-press.
  field private drag-start-x:Distance
  field private drag-start-y:Distance
  field private drag-start-view-x:Distance
  field private drag-start-view-y:Distance
  field private drag-start-view-w:Distance
  field private drag-start-view-h:Distance
  field private current-pointer-x:Distance = 0m
  field private current-pointer-y:Distance = 0m

  || Computed on drag start:
  field private in-size-top?:bool
  field private in-size-bottom?:bool
  field private in-size-left?:bool
  field private in-size-right?:bool
  field private in-move?:bool

  {doc-next
    {purpose
        If {ctext false} then the resulting {docref TitledView} cannot be
        resized by user actions. By default this value is set to true.
    }
  }
  {local-option public resizable?:bool = true
    {self.on-resizable-change}
  }
  || FIXME: Does not allow to change the background of content-frame through
  || its skin
  {local-option public background:Background
    set self.content-frame.background = self.background
  }

  field private initializing?:bool = true

  {method private {handle-pointer-press
                      graphic:Graphic,
                      event:PointerEvent
                  }:void
    || Only call on relevant (i.e. left-button) presses.
    set (self.drag-start-x, self.drag-start-y) =
        {graphic.transform-to-display-coordinates event.x, event.y}
    set self.current-pointer-x = self.drag-start-x
    set self.current-pointer-y = self.drag-start-y
    set (self.drag-start-view-x, self.drag-start-view-y,
         self.drag-start-view-w, self.drag-start-view-h) =
             {self.get-window-position-and-size}

    def cursor = graphic.cursor
    set self.in-size-top? = (cursor == cursor-size-top or
                             cursor == cursor-size-top-right or
                             cursor == cursor-size-top-left)
    set self.in-size-bottom? = (cursor == cursor-size-bottom or
                                cursor == cursor-size-bottom-right or
                                cursor == cursor-size-bottom-left)
    set self.in-size-left? = (cursor == cursor-size-left or
                              cursor == cursor-size-top-left or
                              cursor == cursor-size-bottom-left)
    set self.in-size-right? = (cursor == cursor-size-right or
                               cursor == cursor-size-top-right or
                               cursor == cursor-size-bottom-right)

    || HACK: Treat motion as sizing ALL of them.
    {if not self.in-size-top? and not self.in-size-bottom? and
        not self.in-size-left? and not self.in-size-right?
     then
        set self.in-move? = true
        set self.in-size-top? = true
        set self.in-size-bottom? = true
        set self.in-size-left? = true
        set self.in-size-right? = true
     else
        set self.in-move? = false
    }
  }

  {method private {handle-drag-start
                      graphic:Graphic,
                      event:DragStarted
                  }:void
    || At this point the mouse will have already moved several pixels
    || away from the starting position, so really it's no different
    || from drag-continue.  We capture initial state in pointer-press.
    {self.handle-drag-continue graphic, event}
  }

  {method private {handle-drag-continue
                      graphic:Graphic,
                      event:PointerEvent
                  }:void

    set (self.current-pointer-x, self.current-pointer-y) =
        {graphic.transform-to-display-coordinates event.x, event.y}
    || Don't process immediately; wait until we have gone through the
    || event loop, thus coalescing any other pointer events that are
    || pending or will be very soon.
    {if not self.motion-alarm.scheduled? then
        {self.motion-alarm.schedule delay = 0s}
    }
  }

  {method private {handle-motion-alarm}:void
    || Compute changes from start of operation:
    def delta-x = self.current-pointer-x - self.drag-start-x
    def delta-y = self.current-pointer-y - self.drag-start-y

    let view-x:Distance = self.drag-start-view-x
    let view-y:Distance = self.drag-start-view-y
    let view-w:Distance = self.drag-start-view-w
    let view-h:Distance = self.drag-start-view-h

    || Constrain resizing to the usable area.  This mimics the OS/window
    || managers' general refusal to allow windows to grow outside
    || the usable area, e.g. over or under task bars.
    def (usable-x, usable-y, usable-w, usable-h) =
        {TitledView.get-usable-area view-x, view-y, view-w, view-h}

    {if self.in-size-top? then
        {inc view-y, delta-y}
        {dec view-h, delta-y}

        {if not self.in-move? then
            || Constrain against usable area.
            def overflow = usable-y - view-y
            {if overflow > 0m then
                set view-y = usable-y
                {dec view-h, overflow}
            }

            || Constrain against minimum.
            def underflow = self.minimum-height - view-h
            {if underflow > 0m then
                set view-h = self.minimum-height
                {dec view-y, underflow}
            }
        }
    }

    {if self.in-size-left? then
        {inc view-x, delta-x}
        {dec view-w, delta-x}

        {if not self.in-move? then
            || Constrain against usable area.
            def overflow = usable-x - view-x
            {if overflow > 0m then
                set view-x = usable-x
                {dec view-w, overflow}
            }

            || Constrain against minimum.
            def underflow = self.minimum-width - view-w
            {if underflow > 0m then
                set view-w = self.minimum-width
                {dec view-x, underflow}
            }
        }
    }

    {if self.in-size-bottom? then
        {inc view-h, delta-y}

        {if not self.in-move? then
            || Constrain against usable area.
            def overflow = (view-y + view-h) - (usable-y + usable-h)
            {if overflow > 0m then
                {dec view-h, overflow}
            }

            || Constrain against minimum.
            def underflow = self.minimum-height - view-h
            {if underflow > 0m then
                set view-h = self.minimum-height
            }
        }
    }

    {if self.in-size-right? then
        {inc view-w, delta-x}

        {if not self.in-move? then
            || Constrain against usable area.
            def overflow = (view-x + view-w) - (usable-x + usable-w)
            {if overflow > 0m then
                {dec view-w, overflow}
            }

            || Constrain against minimum.
            def underflow = self.minimum-width - view-w
            {if underflow > 0m then
                set view-w = self.minimum-width
            }
        }
    }

    {self.set-window-position-and-size view-x, view-y, view-w, view-h}
  }

  {define-proc private {get-usable-area
                           win-x:Distance,
                           win-y:Distance,
                           win-w:Distance,
                           win-h:Distance
                       }:(x:Distance, y:Distance, w:Distance, h:Distance)
    || FIXME: No public way to find the right Display, so we guess.
    def display =
        {{DISPLAY.Display.get-primary}.get-nearest
            win-x + 0.5 * win-w,
            win-y + 0.5 * win-h
        }
    {return {display.get-usable-area}}
  }

  || Create a Fill for resizing and attach it to the grid as
  || specified.
  {method private {make-resizer
                      top:GridFiducial,
                      right:GridFiducial,
                      bottom:GridFiducial,
                      left:GridFiducial,
                      cursor:Cursor,
                      ...
                  }:Fill
    def fill =
        {Fill
            {on e:PointerPress do
                {if e.button == left-button then
                    set self.left-button? = true
                    {self.handle-pointer-press fill, e}
                }
            },
            {on e:DragStarted do
                {if self.left-button? then
                    {e.continue-implicit-pointer-grab fill}
                    {self.handle-drag-start fill, e}
                    set self.drag-started? = true
                    {e.consume}
                }
            },
            {on e:GrabRelease do
                set self.drag-started? = false
            },
            {on e:PointerMotion at fill:Fill do
                {if self.left-button? and self.drag-started? then
                    {self.handle-drag-continue fill, e}
                    {e.consume}
                }
            },
            {on e:PointerRelease at fill:Fill do
                {if self.left-button? and self.drag-started? then
                    {e.consume}
                }
                {if e.button == left-button then
                    set self.left-button? = false
                }
            },

            opaque-to-events? = true,
            {splice ...}
        }

    {self.grid.add
        fill,
        left = left,
        right = right,
        bottom = bottom,
        top = top
    }
    set fill.cursor = cursor

    {return fill}
  }

  {doc-next
    {purpose Create a {ctext TitledView}.}
    {parameter owner,
        Specifies the owner {docref View} of the newly
        created {ctext TitledView}.
    }
    {parameter center?,
        Specifies whether this {ctext TitledView} should be positioned so that
        it is centered over its owner {ctext View}, if any.  The default value
        does not cause centering.

        If {italic owner} is {ctext null}, the {docref TitledView} is
        centered in the upper two-thirds of the screen.}
    {parameter takes-focus?,
        Specifies if the {docref TitledView} should take focus or not.
    }
    {parameter standard-accelerators?,
        If true, the standard accelerators are added to this
        {ctext TitledView}'s accelerator table.  The standard accelerators
        include cut (Ctrl+X), copy (Ctrl+C), paste (Ctrl+V), select all
        (Ctrl+A), and find (Ctrl+F).  On the Mac, Ctrl is replaced by
        Command (see {docref StateMask}).
    }
    {parameter range-selection-ui-enabled?,
        Provides the initial value for {docref
        GuiRangeSelectionContext.range-selection-ui-enabled?}.
    }
    {parameter title,
        Title of the {docref TitledView}.
    }
    {parameter visibility,
        The {docref WindowVisibility} of the {docref TitledView}.
    }
  }
  {constructor public {default
                          owner:#View = null,
                          center?:bool = false,
                          takes-focus?:bool = true,
                          standard-accelerators?:bool = true,
                          range-selection-ui-enabled?:bool = true,
                          title:StringInterface = "TitledView", ||""
                          visibility:WindowVisibility = WindowVisibility.hidden,
                          ...
                      }

    set self.motion-alarm =
        {Alarm
            {proc {}:void
                {self.handle-motion-alarm}
            }
        }

    let args:Arguments = {new Arguments}
    let graphic:#Graphic = null
    {for (a, k) in ... do
        {if k == null then
            {if a isa DataBinding or a isa EventHandler then
                {args.append a}
             else
                set graphic = a
            }
         else
            {args.append keyword=k, a}
        }
    }

    set self.content-frame =
        {ClipFrame
            valign = "top", halign = "left", ||""
            width = {make-compressible},
            height = {make-compressible},
            _style-element = "TitledView/content" ||""
        }

    || Set title
    set self.title-frame =
        {ClipFrame
            width = {make-compressible},
            || Similarly if height is set, content-frame overlaps title-bar in
            || case of 'adding contents to TitledView after creating it'
            || avoid multiline title
            text-breakable? = false,
            || Dummy char to calculate ClipFrame's height to get correct
            || initial-size of TitledView window
            || If not passed we don't get correct initial-size
            "T", ||""
            selection-context = null
        }


    || Decorate view
    {self.decorate-view}

    || Get the initial-size according to contents passed
    {if-non-null graphic then
        {self.content-frame.add graphic}
    }

    {construct-super
        owner = owner,
        center? = center?,
        decorations? = false,
        takes-focus? = takes-focus?,
        standard-accelerators? = standard-accelerators?,
        range-selection-ui-enabled? = range-selection-ui-enabled?,
        title = title,
        hstretch? = true,
        vstretch? = true,
        visibility = visibility,
        _style-element = "TitledView", ||""

        {on va:ViewDeactivateEvent do
            {self.apply-inactive-skin}
        },

        {on va:ViewActivateEvent do
            {self.title-bar-frame.unset-option-by-name "skin"} ||""
            {self.outer-fill.unset-option-by-name "skin"} ||""
            {self.cmd-min.unset-option-by-name "skin"} ||""
            {self.cmd-max.unset-option-by-name "skin"} ||""
            {self.cmd-close.unset-option-by-name "skin"} ||""
        },

        {on e:ViewVisibilityEvent do
            def visibility = e.visibility

            {if visibility == WindowVisibility.normal then
                {after 0s do
                    || FIXME:
                    || Not getting expected width and height visually (even if
                    || self.width/height is equal to self.minimum-width/height)
                    || so trying to resize the window again by calling
                    || set-window-size
                    || Example:
                    || 1) Create TitledView without specifying the size and
                    || with  visibility="minimized"
                    || 2) Restore the window manually or by changing its
                    || visibility="normal"
                    || 3) We get incorrect window size even if self.width=0.05m
                    || and self.height=0.02m
                    def w = {any-to-Distance self.width}
                    def h = {any-to-Distance self.height}
                    {if w <= self.minimum-width or h <= self.minimum-height then
                        {self.set-window-size w, h}
                    }
                }
            }

            let border-size:any = TitledView.border-size

            {if visibility == WindowVisibility.maximized then
                let display:DISPLAY.Display =
                    {DISPLAY.Display.get-primary}
                def (sx, sy, sw, sh) = {display.get-usable-area}
                {self.set-window-position-and-size sx, sy, sw, sh}

                || To hide borders when maximized
                set border-size = 0m
            }

            def border-height =
                {make-elastic
                    minimum-size = border-size,
                    preferred-size = border-size,
                    compress-order = min-size-stretch-order,
                    stretch-order = min-size-stretch-order
                }
            def border-width =
                {make-elastic
                    minimum-size = border-size,
                    preferred-size = border-size,
                    compress-order = min-size-stretch-order,
                    stretch-order = min-size-stretch-order
                }
            set self.left-fill.width = border-width
            set self.right-fill.width = border-width
            set self.bottom-fill.height = border-height
            set self.top-fill.height = border-height

        },
        self.grid,
        {splice args}
    }
    set self.title = title
    set self.initializing? = false
  }

  || Validate width and height updated by user, also reset them if needed
  {method public open {option-changed key:String, value:any}:void
    {super.option-changed key, value}
    {if not {unbound-option? key} then
        {switch key
         case "width" do ||""
            {if {any-to-Distance value} < self.minimum-width then
                set self.width = self.minimum-width
            }
         case "height" do ||""
            {if {any-to-Distance value} < self.minimum-height then
                set self.height = self.minimum-height
            }
        }
    }
  }

  {doc-next
    {purpose Validate width and height for {docref TitledView}.}
    {details Width and height of {docref TitledView} cannot be less than
        {ctext minimum-width} and {ctext minimum-height} respectively.
    }
  }
  {method private {validate-width-and-height
                      width:Distance, height:Distance
                  }:(width:Distance, height:Distance)

    {if width < self.minimum-width then
        set width = self.minimum-width
    }
    {if height < self.minimum-height then
        set height = self.minimum-height
    }
    {return width, height}
  }

  {doc-next
    {purpose Decorate the {docref TitledView}.}
    {details
        This method decorates the {docref View} ({docref View} with
        decorations? = false) with title bar, Minimize, Maximize and Close
        command buttons, border around the {docref View}.
        |#
        Decorates View as follow,
        View
           Grid
              SkinnableFill (outer-fill for border)
              Fill (Fill with white background)
              Fill (Top border)
              Fill (Top-Left Horizontal border)
              SkinnableFrame (title-bar-frame)
                       VBox
                          HBox (icon-frame and title-frame)
                             Frame (icon-frame)
                             Fill
                             ClipFrame (title-frame)
                          Fill
              Fill (Right-Border)
              Fill (Bottom-Border)
              Fill (Left-Border)
              Fill (Bottom-Left-Vertical Border)
              Fill (Bottom-Left-Horizontal Border)
              Fill (Bottom-Right-Vertical Border)
              Fill (Bottom-Right-Horizontal Border)
              Fill (Top-Left-Vertical Border)
              Fill (Top-Right-Vertical Border)
              HBox (buttons-hbox)
              ClipFrame (content-frame)
        #|
    }
  }
  {method private {decorate-view}:void

    def grid-border-color =
        {FillPattern.from-color
            {Color.from-rgb-uint8 89, 89, 89}
        }

    || Create the decorations
    set self.grid =
        {Grid
            vorigin = "top", horigin = "left", ||""
            border-width = 1px,
            border-color = grid-border-color
        }

    set self.title-hbox =
        {HBox
            valign = "top" ||""
        }
    set self.buttons-hbox =
        {HBox
            valign = "top", ||""
            vstretch? = true,
            selection-context = null
        }

    set self.icon-frame = {Frame}

    set self.cmd-min =
        {CommandButton
            label =
                {Label
                    {Frame
                        {RectangleGraphic
                            width = 12px, height = 5px,
                            color = "white", ||""
                            border-color = grid-border-color,
                            border-width = 1px
                        }
                    }
                },
            takes-focus? = false,
            _style-element = "TitledView/min-button", ||""

            {on Action do
                set self.visibility = WindowVisibility.minimized
            }
        }

    set self.cmd-max =
        {CommandButton
            label =
                {Label
                    {Frame
                        width = 13px, height = 11px,
                        vstretch? = true, hstretch? = true,
                        border-color = grid-border-color, border-width = 1px,
                        background = "transparent", ||""
                        {Frame
                            vstretch? = true, hstretch? = true,
                            border-color = "white", border-width = 2px, ||""
                            background = "transparent", ||""
                            {Frame
                                vstretch? = true, hstretch? = true,
                                border-color = grid-border-color,
                                border-width = 1px,
                                background = "transparent" ||""
                            }
                        }
                    }
                },
            takes-focus? = false,
            _style-element = "TitledView/max-button", ||""

            {on Action do
                {self.handle-maximize-button}
            }
        }

    set self.cmd-close =
        {CommandButton
            label =
                {Label
                    font-size = 12pt,
                    {bold x}
                },
            takes-focus? = false,
            _style-element = "TitledView/close-button", ||""

            {on Action do
                {self.close}
            }
        }

    || Add all required objects to Grid for TitleBar

    || Cannot add icon-frame when required as it has to be at the first place
    || so need to have icon-frame always
    {self.title-hbox.add self.icon-frame}
    || Little margin between icon and title
    {self.title-hbox.add
        {Fill width = TitledView.border-size}
    }
    {self.title-hbox.add self.title-frame}
    {self.title-hbox.add {Fill}}
    {if self.resizable? then
        {self.buttons-hbox.add self.cmd-min}
        {self.buttons-hbox.add self.cmd-max}
    }
    {self.buttons-hbox.add self.cmd-close}

    || Define the fiducials needed for the grid layout
    def vfa = {self.grid.make-fiducial orientation = Orientation.vertical}
    def vfb = {self.grid.make-fiducial orientation = Orientation.vertical}
    def vfc = {self.grid.make-fiducial orientation = Orientation.vertical}
    def vfd = {self.grid.make-fiducial orientation = Orientation.vertical}
    def vfe = {self.grid.make-fiducial orientation = Orientation.vertical}

    def hfa = {self.grid.make-fiducial orientation = Orientation.horizontal}
    def hfb = {self.grid.make-fiducial orientation = Orientation.horizontal}
    def hfc = {self.grid.make-fiducial orientation = Orientation.horizontal}
    def hfd = {self.grid.make-fiducial orientation = Orientation.horizontal}
    def hfe = {self.grid.make-fiducial orientation = Orientation.horizontal}

    || Put a SkinnableFill at the very back, to show the borders
    set self.outer-fill =
        {SkinnableFill
            _style-element = "TitledView/resizer", ||""
            border-width = 0pt,
            opaque-to-events? = true
        }

    {self.grid.add
        top = {self.grid.top},
        right = {self.grid.right},
        bottom = {self.grid.bottom},
        left = {self.grid.left},
        self.outer-fill
    }

    || Next add a white backdrop
    {self.grid.add
        {Fill background = "white"}, ||""
        top = hfc, right = vfe, bottom = hfe, left = vfa
    }

    def border-height =
        {make-elastic
            minimum-size = TitledView.border-size,
            preferred-size = TitledView.border-size,
            compress-order = min-size-stretch-order,
            stretch-order = min-size-stretch-order
        }
    def border-width =
        {make-elastic
            minimum-size = TitledView.border-size,
            preferred-size = TitledView.border-size,
            compress-order = min-size-stretch-order,
            stretch-order = min-size-stretch-order
        }

    set self.top-fill =
        {self.make-resizer
            {self.grid.top}, vfe, hfa, vfb,
            cursor-size-top,
            height = border-height
        }

    set self.top-left-hfill =
        {self.make-resizer
            {self.grid.top}, vfb, hfb, vfa,
            cursor-size-top-left,
            width = TitledView.corner-size - TitledView.border-size
        }

    set self.title-bar-frame =
        {SkinnableFrame
            border-width = 0pt,
            _style-element = "TitledView/titlebar", ||""
            {VBox
                self.title-hbox,
                || Space below title and buttons-hbox,
                || need it especially when maximized
                {Fill height = TitledView.border-size}
            },

            {on e:DragStarted at g:Graphic do
                {if self.left-button? and
                    self.visibility != WindowVisibility.maximized
                 then
                    {e.continue-implicit-pointer-grab g}
                    {self.handle-drag-start g, e}
                    {e.consume}
                    set self.drag-started? = true
                }
            },

            {on e:PointerMotion at g:Graphic do
                {if self.left-button? and
                    self.visibility != WindowVisibility.maximized and
                    self.drag-started?
                 then
                    {self.handle-drag-continue g, e}
                    {e.consume}
                }
            },

            {on e:GrabRelease at g:Graphic do
                set self.drag-started? = false
            },

            {on e:PointerPress at g:Graphic do
                || Presence of min and max buttons confirms that the window
                || is resizable
                {if e.button == left-button and
                    e.click-count == 2 and
                    self.buttons-hbox.child-array.size > 2
                 then
                    {self.handle-maximize-button}
                 elseif e.button == left-button then
                    set self.left-button? = true
                    {self.handle-pointer-press g, e}
                }
            },
            {on e:PointerRelease at g:Graphic do
                {if e.button == left-button then
                    set self.left-button? = false
                }
            }
        }
    {self.grid.add
        top = hfa, right = vfe, bottom = hfc, left = vfa,
        self.title-bar-frame
    }

    set self.right-fill =
        {self.make-resizer
            hfb,
            {self.grid.right},
            hfd,
            vfe,
            cursor-size-right,
            width = border-width
        }

    set self.bottom-fill =
        {self.make-resizer
            hfe,
            vfd,
            {self.grid.bottom},
            vfb,
            cursor-size-bottom,
            height = border-height
        }

    set self.left-fill =
        {self.make-resizer
            hfb,
            vfa,
            hfd,
            {self.grid.left},
            cursor-size-left,
            width = border-width
        }

    set self.bottom-left-vfill =
        {self.make-resizer
            hfd,
            vfa,
            {self.grid.bottom},
            {self.grid.left},
            cursor-size-bottom-left,
            height = TitledView.corner-size
        }

    set self.bottom-left-hfill =
        {self.make-resizer
            hfe,
            vfb,
            {self.grid.bottom},
            vfa,
            cursor-size-bottom-left,
            width = TitledView.corner-size
        }

    set self.bottom-right-vfill =
        {self.make-resizer
            hfd,
            {self.grid.right},
            {self.grid.bottom},
            vfe,
            cursor-size-bottom-right,
            height = TitledView.corner-size
        }

    set self.bottom-right-hfill =
        {self.make-resizer
            hfe,
            vfe,
            {self.grid.bottom},
            vfd,
            cursor-size-bottom-right,
            width = TitledView.corner-size
        }

    set self.top-left-vfill =
        {self.make-resizer
            {self.grid.top},
            vfa,
            hfb,
            {self.grid.left},
            cursor-size-top-left,
            height = TitledView.corner-size
        }

    set self.top-right-vfill =
        {self.make-resizer
            {self.grid.top},
            {self.grid.right},
            hfb,
            vfe,
            cursor-size-top-right,
            height = TitledView.corner-size
        }

    {self.grid.add
        self.buttons-hbox,
        top = {self.grid.top}, right = vfe
    }

    || Add content frame to the Grid
    {self.grid.add
        self.content-frame,
        top = hfc, right = vfe, bottom = hfe, left = vfa
    }
  }

  {doc-next
    {purpose Switch to the skins appropriate for an inactive window.}
  }
  {method protected open {apply-inactive-skin}:void

    def titlebar-start-color = self.disabled-color
    def titlebar-end-color = {get-highlight-for self.disabled-color}
    def buttons-border-color = {get-shadow-for self.disabled-color}

    || Apply default inactive skins
    {if self.inactive-titlebar-skin == null then
        set self.inactive-titlebar-skin =
            {ShadedSkinSpec
                titlebar-start-color,
                titlebar-end-color,
                draw-top-edge? = false,
                draw-right-edge? = false,
                draw-bottom-edge? = false,
                draw-left-edge? = false
            }
    }
    {if self.inactive-border-skin == null then
        set self.inactive-border-skin =
            {ShadedSkinSpec
                titlebar-start-color,
                titlebar-start-color,
                draw-top-edge? = false,
                draw-right-edge? = false,
                draw-bottom-edge? = false,
                draw-left-edge? = false
            }
    }
    {if self.inactive-min-skin == null then
        set self.inactive-min-skin =
            {ShadedSkinSpec
                titlebar-start-color,
                titlebar-start-color,
                border-color = buttons-border-color,
                highlight-alpha-1 = 0.5,
                highlight-boundary = 1percent,
                corner-radius = 3px,
                upper-left-rounded? = false,
                upper-right-rounded? = false,
                lower-left-rounded? = true,
                lower-right-rounded? = false,
                draw-top-edge? = false,
                draw-right-edge? = false
            }
    }
    {if self.inactive-max-skin == null then
        set self.inactive-max-skin =
            {ShadedSkinSpec
                titlebar-start-color,
                titlebar-start-color,
                border-color = buttons-border-color,
                highlight-alpha-1 = 0.5,
                highlight-boundary = 1percent,
                corner-radius = 3px,
                upper-left-rounded? = false,
                upper-right-rounded? = false,
                lower-left-rounded? = false,
                lower-right-rounded? = false,
                draw-top-edge? = false,
                draw-right-edge? = false
            }
    }
    {if self.inactive-close-skin == null then
        set self.inactive-close-skin =
            {ShadedSkinSpec
                titlebar-start-color,
                titlebar-start-color,
                border-color = buttons-border-color,
                highlight-alpha-1 = 0.5,
                highlight-boundary = 1percent,
                corner-radius = 3px,
                upper-left-rounded? = false,
                upper-right-rounded? = false,
                lower-left-rounded? = false,
                lower-right-rounded? = true,
                draw-top-edge? = false
            }
    }

    {self.title-bar-frame.set-option-by-name
        "skin", self.inactive-titlebar-skin ||""
    }
    {self.outer-fill.set-option-by-name
        "skin", self.inactive-border-skin ||""
    }
    {self.cmd-min.set-option-by-name
        "skin", self.inactive-min-skin ||""
    }
    {self.cmd-max.set-option-by-name
        "skin", self.inactive-max-skin ||""
    }
    {self.cmd-close.set-option-by-name
        "skin", self.inactive-close-skin ||""
    }
  }

  {doc-next
    {purpose Add a graphical child to {docref TitledView}.}
    {details
        At a time only one graphical child can be added to {docref TitledView}.
    }
  }
  {method public open {add g:any, ...}:#Visual
    {return
        {if self.initializing? then
            {super.add g, ...}
        else
            {self.content-frame.add g, ...}
        }
    }
  }

  {doc-next
    {purpose Clear the contents of a {docref TitledView}.}
  }
  {method public open {clear}:void
    {self.content-frame.clear}
  }

  {method public open {remove-child}:void
    {self.content-frame.remove-child}
  }

  {doc-next
    {purpose Set a title to {docref TitledView}.}
  }
  {setter public open {title caption:StringInterface}:void
    set super.title = caption
    || Use the title from super (could be modified)
    {self.title-frame.add replace? = true, super.title}
  }

  {doc-next
    {purpose Set an icon to {docref TitledView}.}
    {parameter large-icon,
        The image to be used when a larger icon (32x32 pixels) is
        needed.
    }
    {parameter small-icon-if-used,
        If non-{ctext null}, this is the icon that may be displayed in the
        {docref TitledView} caption. If {ctext null} then this may remove the
        icon, if any, from the {ctext TitledView} caption.
    }
  }
  {method public open {set-icon
                          large-icon:Pixmap,
                          small-icon-if-used:#Pixmap
                      }:void
    {self.icon-frame.add large-icon, replace? = true}
    {super.set-icon large-icon, small-icon-if-used}
  }

  {doc-next
    {purpose
        Resize the {docref TitledView}.
    }
    {parameter width,
        The new width.
    }
    {parameter height,
        The new height.
    }
    {details
        It is not guaranteed that this {docref TitledView} will actually
        resize to this value.
    }
    {notes
        If new width is less than {ctext TitledView.minimum-width} then it will
        be ignored and {ctext TitledView.minimum-width} will be set as new
        width of {docref TitledView}.

        If new height is less than {ctext TitledView.minimum-height} then it
        will be ignored and {ctext TitledView.minimum-height} will be set as
        new height of {docref TitledView}.
    }
  }
  {method public open {set-window-size
                          width:Distance,
                          height:Distance
                      }:void
    || Validate the width and height if user provided values are less than
    || minimum width and height
    set (width, height) = {self.validate-width-and-height width, height}
    {super.set-window-size width, height}
  }

  {doc-next
    {purpose
        Set the width, height and the position of the {docref TitledView}.
    }
    {notes
        Use this when both the position and size are to be set.
        This may be faster than calling {docref View.set-window-position}
        and {docref TitledView.set-window-size} methods.

        If new width is less than {ctext TitledView.minimum-width} then it will
        be ignored and {ctext TitledView.minimum-width} will be set as new
        width of {docref TitledView}.

        If new height is less than {ctext TitledView.minimum-height} then it
        will be ignored and {ctext TitledView.minimum-height} will be set as
        new height of {ctext TitledView}.
    }
  }
  {method public open {set-window-position-and-size
                          x:Distance, y:Distance,
                          width:Distance, height:Distance
                      }:void
    set (width, height) = {self.validate-width-and-height width, height}
    {super.set-window-position-and-size x, y, width, height}
  }

  {method private {on-resizable-change}:void
    || If resizable?=true then set the appropriate cursors and
    || show minimize and maximize buttons
    {if self.resizable? then
        {if self.visibility != WindowVisibility.maximized then
            {self.show-resizing-cursors}
         else
            {self.show-resizing-cursors show-cursor? = false}
        }
        {self.buttons-hbox.clear}
        {self.buttons-hbox.add self.cmd-min}
        {self.buttons-hbox.add self.cmd-max}
        {self.buttons-hbox.add self.cmd-close}
     else
        {self.show-resizing-cursors show-cursor? = false}
        {self.buttons-hbox.clear}
        {self.buttons-hbox.add self.cmd-close}
    }
  }

  {doc-next
    {purpose Implements the maximize action. }
  }
  {method protected open {handle-maximize-button}:void
    {if self.visibility == WindowVisibility.normal then
        set self.visibility = WindowVisibility.maximized
        || Should not allow resizing when window is maximized
        {self.show-resizing-cursors show-cursor? = false}

     elseif self.visibility == WindowVisibility.maximized then
        set super.visibility = WindowVisibility.normal
        {self.show-resizing-cursors}
    }
  }

  {method private {show-resizing-cursors show-cursor?:bool = true}:void
    {if show-cursor? then
        set self.top-fill.cursor = cursor-size-top
        set self.right-fill.cursor = cursor-size-right
        set self.bottom-fill.cursor = cursor-size-bottom
        set self.left-fill.cursor = cursor-size-left

        set self.top-right-vfill.cursor = cursor-size-top-right
        set self.bottom-right-vfill.cursor = cursor-size-bottom-right
        set self.bottom-right-hfill.cursor = cursor-size-bottom-right
        set self.bottom-left-hfill.cursor = cursor-size-bottom-left
        set self.bottom-left-vfill.cursor = cursor-size-bottom-left
        set self.top-left-hfill.cursor = cursor-size-top-left
        set self.top-left-vfill.cursor = cursor-size-top-left
     else
        set self.top-fill.cursor = null
        set self.right-fill.cursor = null
        set self.bottom-fill.cursor = null
        set self.left-fill.cursor = null

        set self.top-right-vfill.cursor = null
        set self.bottom-right-vfill.cursor = null
        set self.bottom-right-hfill.cursor = null
        set self.bottom-left-hfill.cursor = null
        set self.bottom-left-vfill.cursor = null
        set self.top-left-vfill.cursor = null
        set self.top-left-hfill.cursor = null
    }
  }


}

{define-proc package {get-titled-view-rules}:{Array-of StyleRule}
    def decorations-start-color =
        {FillPattern.from-color
            {Color.from-rgb-uint8 109, 176, 255}
        }
    def decorations-end-color =
        {FillPattern.from-color
            {Color.from-rgb-uint8 79, 146, 228}
        }
    def button-rollover-color =
        {FillPattern.from-color
            {Color.from-rgb-uint8 166, 208, 258}
        }
    def close-button-rollover-color =
        {FillPattern.from-color
            {Color.from-rgb-uint8 220, 80, 80}
        }
    def button-border-color = {Color.from-rgb-uint8 49, 116, 198}

    def button-text-color = "#fffff0" ||""

    || Shadow-spec and shadow-color for buttons
    def button-shadow-spec =
        {ShadowSpec
            offset = 1px,
            angle = 120deg,
            corner-radius = 1px,
            falloff = 2,
            upper-left-rounded? = true,
            upper-right-rounded? = true,
            lower-right-rounded? = true,
            lower-left-rounded? = true
        }
    def button-shadow-color =
        {FillPattern.from-rgb
            255, 255, 255,
            opacity = 0.6
        }

    {return
        {new {Array-of StyleRule},
            {StyleRule "TitledView/titlebar", ||""
                color = button-text-color,
                font-size = {prefs}["caption-font-size"], ||""
                font-weight = {prefs}["caption-font-weight"], ||""
                font-style = {prefs}["caption-font-style"], ||""
                skin =
                    {ShadedSkinSpec
                        decorations-start-color,
                        decorations-end-color,
                        draw-top-edge? = false,
                        draw-right-edge? = false,
                        draw-bottom-edge? = false,
                        draw-left-edge? = false
                    }
            },
            {StyleRule "TitledView/resizer", ||""
                skin =
                    {ShadedSkinSpec
                        decorations-start-color,
                        decorations-end-color,
                        draw-top-edge? = false,
                        draw-right-edge? = false,
                        draw-bottom-edge? = false,
                        draw-left-edge? = false
                    }
            },
            {StyleRule "TitledView/content", ||""
                border-width = 1px
            },
            {StyleRule "TitledView/min-button", ||""
                width = 7mm,
                height = 4.5mm,
                color = button-text-color,
                shadow-spec = button-shadow-spec,
                shadow-color = button-shadow-color,
                skin =
                    {ShadedSkinSpec
                        decorations-start-color,
                        decorations-end-color,
                        rollover-start-color = button-rollover-color,
                        rollover-end-color = button-rollover-color,
                        border-color = button-border-color,
                        rollover-border-color = button-border-color,
                        pressed-overlay = button-rollover-color,
                        highlight-alpha-1 = 0.5,
                        highlight-boundary = 1percent,
                        corner-radius = 3px,
                        upper-left-rounded? = false,
                        upper-right-rounded? = false,
                        lower-left-rounded? = true,
                        lower-right-rounded? = false,
                        draw-top-edge? = false,
                        draw-right-edge? = false
                    }
            },
            {StyleRule "TitledView/max-button", ||""
                width = 7mm,
                height = 4.5mm,
                color = button-text-color,
                shadow-spec = button-shadow-spec,
                shadow-color = button-shadow-color,
                skin =
                    {ShadedSkinSpec
                        decorations-start-color,
                        decorations-end-color,
                        rollover-start-color = button-rollover-color,
                        rollover-end-color = button-rollover-color,
                        border-color = button-border-color,
                        rollover-border-color = button-border-color,
                        pressed-overlay = button-rollover-color,
                        highlight-alpha-1 = 0.5,
                        highlight-boundary = 1percent,
                        corner-radius = 3px,
                        upper-left-rounded? = false,
                        upper-right-rounded? = false,
                        lower-left-rounded? = false,
                        lower-right-rounded? = false,
                        draw-top-edge? = false,
                        draw-right-edge? = false
                    }
            },
            {StyleRule "TitledView/close-button", ||""
                width = 11mm,
                height = 4.5mm,
                color = button-text-color,
                shadow-spec = button-shadow-spec,
                shadow-color = button-shadow-color,
                skin =
                    {ShadedSkinSpec
                        decorations-start-color,
                        decorations-end-color,
                        rollover-start-color = close-button-rollover-color,
                        rollover-end-color = close-button-rollover-color,
                        border-color = button-border-color,
                        rollover-border-color = button-border-color,
                        pressed-overlay = close-button-rollover-color,
                        highlight-alpha-1 = 0.5,
                        highlight-boundary = 1percent,
                        corner-radius = 3px,
                        upper-left-rounded? = false,
                        upper-right-rounded? = false,
                        lower-left-rounded? = false,
                        lower-right-rounded? = true,
                        draw-top-edge? = false
                    }
            }
        }
    }
}

{do
    {StyleManager.append-base-style-rule {splice {get-titled-view-rules}}}
}

||| Copyright 1998-2010, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.
|||
||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.
||| ----------------------------------------------------------------------------

{import * from CURL.GRAPHICS.WINDOW}
{import * from CURL.GRAPHICS.DISPLAY}

{doc-next
    {purpose An enumeration to identify each side of a rectangular object.}
} 
{define-enum public RectangleSide
    left,
    top,
    right,
    bottom
}

{define-class package BalloonCanvas {inherits Canvas}

  field private-set public-get tail-orientation:RectangleSide
  field private-set public-get corner-radius:Distance
  field private-set public-get tail-x:Distance
  field private-set public-get tail-y:Distance
  field private-set public-get tail-w:Distance
  field private-set public-get tail-h:Distance

  {constructor package {default
                           corner-radius:Distance = 9pt,
                           ...
                       }
    {set self.corner-radius = corner-radius}
    {construct-super
        vorigin = "center", ||""
        horigin = "center", ||""
        {splice ...}
    }
  }

  || Combined setter for all the field, calls generate-path and set-path
  || Can be overridden.
  {method package {configure
                      tail-orientation:RectangleSide,
                      tail-x:Distance,
                      tail-y:Distance,
                      tail-w:Distance,
                      tail-h:Distance
                  }:void

    set self.tail-orientation = tail-orientation
    set self.tail-x = tail-x
    set self.tail-y = tail-y
    set self.tail-w = tail-w
    set self.tail-h = tail-h

    || Redraw everything as some fields may have changed.
    {if self.layout-valid? then
        def border-shape = {self.generate-path}
        {self.set-path border-shape}
    }
  }

  || Generate and return path based on all the private fields
  || Can be overridden.
  {method protected open {generate-path}:PathShape

    let (width:Distance, height:Distance) = (0m, 0m)
    || This method will not be called if layout is not valid
    {if self.layout-valid? then
        {if-non-null layout = self.layout then
            def bounds = {layout.get-bounds}
            set width = bounds.width
            set height = bounds.height
        }
    }

    def (tail-x, tail-y, tail-w, tail-h) =
        (self.tail-x, self.tail-y, self.tail-w, self.tail-h)

    || We have to shift borders with the amount equal the tail height.
    {if self.tail-orientation == RectangleSide.bottom or
        self.tail-orientation == RectangleSide.top
     then
        set height = height - self.tail-h
     else
        set width = width - self.tail-h
    }

    || Starting position of path
    || We have to change this when we create tail in top or left side.
    || We have to shift borders with the amount equal the tail height.
    let path-x:Distance =
        {if self.tail-orientation == RectangleSide.left then
            tail-h
         else
            0pt
        }
    let path-y:Distance =
        {if self.tail-orientation == RectangleSide.top then
            tail-h
         else
            0pt
        }

    || We will need this amount many times further ahead.
    def half-tw = tail-w / 2.0

    || Rounding radius of popup
    def radius = self.corner-radius
    let balloon-path:Path = {Path}

    || Starting point
    {if (self.tail-orientation == RectangleSide.left and
         (tail-y - half-tw) < radius) or
        (self.tail-orientation == RectangleSide.top and
         (tail-x - half-tw) < radius)
     then
        {balloon-path.move-to {Distance2d path-x, path-y}}
     else
        {balloon-path.move-to {Distance2d path-x + radius, path-y}}
    }

    || Draw Upper Line
    {if self.tail-orientation == RectangleSide.top then
        {if tail-x < half-tw then
         else
            {balloon-path.line-to
                {Distance2d path-x + tail-x - half-tw, path-y}}
        }

        {balloon-path.line-to
            {Distance2d path-x + tail-x, path-y - tail-h}}

        {if (tail-x + half-tw) > width then
         else
            {balloon-path.line-to
                {Distance2d path-x + tail-x + half-tw, path-y}}
        }
    }
    || If we are close enough to corners then we should plot till ends.
    {if (self.tail-orientation == RectangleSide.top and
         (tail-x + half-tw) > (width - self.corner-radius))
     then
        {balloon-path.line-to {Distance2d path-x + width, path-y}}
     else
        {balloon-path.line-to {Distance2d path-x + width - radius, path-y}}
    }

    || Draw Top-Right Corner
    || Right corner is overlapped by right side pointer
    {if (self.tail-orientation == RectangleSide.right and
         (tail-y - half-tw) < self.corner-radius) or
        (self.tail-orientation == RectangleSide.top and
         (tail-x + half-tw) > (width - self.corner-radius))
     then
        || Right corner is overlapped by right side pointer
        || so convert the radius in square corner
        {balloon-path.line-to
            {Distance2d path-x + width, path-y}}
     else
        {balloon-path.curve-to
            {Distance2d path-x + width - radius, path-y},
            {Distance2d path-x + width, path-y},
            {Distance2d path-x + width, path-y + radius}
        }
    }

    || Draw Right Side Line
    {if self.tail-orientation == RectangleSide.right then
        || Pointer width should not exceed the top edge
        {if tail-y < half-tw then
         else
            {balloon-path.line-to
                {Distance2d path-x + width,
                    path-y + tail-y - half-tw}}
        }

        {balloon-path.line-to
            {Distance2d path-x + width + tail-h, path-y + tail-y}}
        || Pointer width should not exceed the bottom edge
        {if (tail-y + half-tw) > height then
         else
            {balloon-path.line-to
                {Distance2d path-x + width,
                    path-y + tail-y + half-tw}}
        }
    }
    || We will not plot the Bottom-Right corner so we should plot till the
    || end of corner
    {if self.tail-orientation == RectangleSide.right and
        (tail-y + half-tw) > (height - radius)
     then
        {balloon-path.line-to
            {Distance2d path-x + width, path-y + height}}
     else
        {balloon-path.line-to
            {Distance2d path-x + width, path-y + height - radius}}
    }

    || Draw Bottom-Right Corner
    {if (self.tail-orientation == RectangleSide.right and
         (tail-y + half-tw) > (height - radius))
        or
        (self.tail-orientation == RectangleSide.bottom and
         (tail-x + half-tw) > (width - self.corner-radius))
     then
        {balloon-path.line-to
            {Distance2d path-x + width, path-y + height}}
     else
        {balloon-path.curve-to
            {Distance2d path-x + width, path-y + height - radius},
            {Distance2d path-x + width, path-y + height},
            {Distance2d path-x + width - radius, path-y + height}}
    }

    || Draw Part of the Bottom Lines
    {if self.tail-orientation == RectangleSide.bottom then
        {if (tail-x + half-tw) > width then
         else
            {balloon-path.line-to
                {Distance2d path-x + tail-x + half-tw,
                    path-y + height}}
        }

        {balloon-path.line-to
            {Distance2d path-x + tail-x, path-y + height + tail-h}}

        {if tail-x < half-tw then
         else
            {balloon-path.line-to
                {Distance2d path-x + tail-x - half-tw,
                    path-y + height}}
        }
    }
    {if self.tail-orientation == RectangleSide.bottom and
        (tail-x - half-tw) < radius
     then
        {balloon-path.line-to
            {Distance2d path-x, path-y + height}}
     else
        {balloon-path.line-to
            {Distance2d path-x + radius, path-y + height}}
    }

    || Draw Bottom-Left Corner
    {if (self.tail-orientation == RectangleSide.left and
         (tail-y + half-tw) > (height - radius)) or
        (self.tail-orientation == RectangleSide.bottom and
         (tail-x - half-tw) < radius)
     then
        {balloon-path.line-to
            {Distance2d path-x, path-y + height}}
     else
        {balloon-path.curve-to
            {Distance2d path-x + radius, path-y + height},
            {Distance2d path-x, path-y + height},
            {Distance2d path-x, path-y + height - radius}}
    }

    || Draw Left Line
    {if self.tail-orientation == RectangleSide.left then
        {if (tail-y + half-tw) > height then
         else
            {balloon-path.line-to
                {Distance2d path-x, path-y + tail-y + half-tw}}
        }

        {balloon-path.line-to
            {Distance2d path-x - tail-h, path-y + tail-y}}

        {if tail-y < half-tw then
         else
            {balloon-path.line-to
                {Distance2d path-x, path-y + tail-y - half-tw}}
        }
    }
    {if self.tail-orientation == RectangleSide.left and
        (tail-y - half-tw) < radius
     then
        {balloon-path.line-to
            {Distance2d path-x, path-y}}
     else
        {balloon-path.line-to
            {Distance2d path-x, path-y + radius}}
    }

    || Finish with Draw Top-Left Corner
    {if (self.tail-orientation == RectangleSide.left and
         (tail-y - half-tw) < radius) or
        (self.tail-orientation == RectangleSide.top and
         (tail-x - half-tw) < radius)
     then
        {balloon-path.line-to
            {Distance2d path-x, path-y}}
     else
        {balloon-path.curve-to
            {Distance2d path-x, path-y + radius},
            {Distance2d path-x, path-y},
            {Distance2d path-x + radius, path-y}}
    }

    {return
        {PathShape
            balloon-path,
            color = "darkgray", ||""
            stroke-thickness = 1.5pt
        }
    }
  }

  || Set the border-path and set the shape of the view containing this Canvas.
  || Need not override.
  {method protected open {set-path border-shape:PathShape}:void
    || Remove any other border, if any.
    {self.clear}
    {self.add border-shape}
    || Set the shape of the view containing the canvas
    {if-non-null view = {self.get-view} then
        {view.set-window-shape
            {Region.from-path border-shape.path}
        }
    }
  }

  || Reset border-path and shape of the view containing this Canvas.
  || Need not to override.
  {method public open {set-size lc:LayoutContext, bounds:GRect}:void
    {super.set-size lc, bounds}
    || Generate path
    {if self.layout-valid? then
        {if-non-null layout = self.layout then
            def border-shape = {self.generate-path}
            {self.set-path border-shape}
        }
    }
  }
}

||  Graphical layout of BalloonView:
||
||  {View
||      {OverlayBox
||          Canvas
||          {Frame
||              {HBox
||                  left-spacer
||                  {VBox
||                      top-spacer
||                      {LimitedWidthFrame
||                          {VBox
||                              {SkinnableFrame
||                                  {HBox
||                                      title,
||                                      Fill,
||                                      Fill, ||Seperator fill
||                                      close-button
||                                  },
||                              }
||                              {Dialog
||                                  {SkinnableFrame
||                                      content
||                                  }
||                              }
||                          }
||                      },
||                      bottom-spacer,
||                  },
||                  right-spacer,
||              }
||          }
||      }
||  }

{define-class package side-helper

  field package distance:Distance
  field package space:Distance
  field package side:RectangleSide
  field package feasible:bool

  {constructor package {default
                           distance:Distance,
                           space:Distance,
                           side:RectangleSide,
                           feasible:bool
                       }
    set self.distance = distance
    set self.space = space
    set self.side = side
    set self.feasible = feasible
  }
}

{doc-next
    {purpose A {docref View} used as a popup "balloon".}
}
{define-class public open BalloonView {inherits View}

  || Each process has a timer to close popups if the AppletView doesn't
  || appear to be active.
  let package close-window-timer:Timer = 
      {Timer enabled? = false, frequency = 100Hz, {on e:TimerEvent do}}

  field private view-event-handler:#EventHandler
  field private timer-handler:#EventHandler

  field private owner:Graphic

  field private tail-x:Distance
  field private tail-y:Distance
  field private tail-size:Distance

  field private move-window-alarm:Alarm

  field private outer-frame:Frame
  field package balloon-canvas:BalloonCanvas
  field private content-frame:#SkinnableFrame
  field private title-frame:#Frame
  field private close-button:#CommandButton

  field private left-spacer:Fill = {Fill width = 0px}
  field private right-spacer:Fill = {Fill width = 0px}
  field private top-spacer:Fill = {Fill height = 0px}
  field private bottom-spacer:Fill = {Fill height = 0px}

  field private current-window-x:Distance = 0m
  field private current-window-y:Distance = 0m

  field private initializing?:bool = true
  field private internal-hidden?:bool

  {doc-next
    {purpose Create and show a specialized "balloon" {docref View} with 
        rounded corners and a small pointed tail.
    }
    {parameter content,
        A {docref Graphic} to be displayed within the {ctext BalloonView}.
    }
    {parameter owner,
        The {docref Graphic} that "owns" the popup. The popup will point
        into this object.
    }
    {parameter x, The x coordinate of the point of the balloon tail,
        relative to {param owner}.
    }
    {parameter y, The y coordinate of the point of the balloon tail,
        relative to {param owner}.
    }
    {parameter tail-size, The size of the balloon tail (length from
        the side of the balloon to the tip of the tail).
    }
    {parameter corner-radius, The radius of the corners of the balloon.
    }
    {parameter takes-focus?, By default the balloon will take focus when
        it is displayed. Use {ctext takes-focus? = false} if you do not
        want the balloon to take focus. 
    }
    {parameter close-button?, By default the balloon will have a button
        to close the popup. Use {ctext close-button? = false} if you
        do not want a close button. You can call {docref
        BalloonView.close-popup} if you want to provide an alternative
        UI for closing the balloon. Balloons are closed automatically when
        the {docref View} containing the {param owner} loses focus or
        is closed.
    }
    {parameter max-width, The maximum width of the popup balloon.
    }
    {parameter style-sheet, A {docref StyleSheet} to be applied
        to the {ctext BalloonView} and its contents.
    }
    {parameter ..., Event handlers and keyword arguments for the
        superclass, {docref View}.
    }
    {details
        This class is intended to be used for a "popup balloon", a
        small popup with a pointer to a graphical object. The popup
        typically contains some information about the thing that it
        points to.

        The balloon popup is shown when it is created. When
        the {docref View} containing {param owner} loses focus, the
        popup is closed. This type of {ctext View} cannot be minimized
        or maximized.
    }
  }
  {constructor public {default
                          content:Graphic,
                          owner:Graphic,
                          x:Distance,
                          y:Distance,
                          tail-size:Distance = 9pt,
                          corner-radius:Distance = 9pt,
                          takes-focus?:bool = true,
                          close-button?:bool = true,
                          max-width:Distance = 4in,
                          style-sheet:#StyleSheet = null,
                          ...
                      }

    set self.move-window-alarm =
        {Alarm
            {proc {}:void
                {self.handle-move-window-alarm}
            }
        }

    || Add a handler to close this balloon if the owner view is inactive,
    || and remember it so it can be removed.
    def bch =
        {on e:TimerEvent do
||--            {dump e}
            {self.close-popup}
        }
    set self.timer-handler = bch
    {BalloonView.close-window-timer.add-event-handler bch}

    def owner-view = {owner.get-view}

    {construct-super.default
        owner = owner-view,
        center? = false,
        decorations? = false,
        _style-element = "BalloonView",  ||""
        visibility = "normal", ||""
        takes-focus? = takes-focus?,
        {splice ...}
||--        ,
||--        {on e:GuiWindowEvent do
||--            {if not e isa PointerEvent then
||--                {dump e}
||--            }
||--        },
||--        {on e:ViewVisibilityEvent do
||--            {dump e.visibility}
||--        }
    }

    set self.owner = owner
    set self.tail-x = x
    set self.tail-y = y
    set self.tail-size = tail-size
    {if not takes-focus? then
        {self.set-topmost true}
    }
    {install-style-sheet-on-Graphic self, {make-style-sheet style-sheet}}

    set self.outer-frame = {LimitedWidthFrame
                               max-width = max-width
                           }

    set self.content-frame =
        {SkinnableFrame
            content,
            _style-element = "BalloonView/content" ||""
        }

    set self.title-frame =
        {SkinnableFrame
            _style-element = "BalloonView/title-frame", ||""
            self.title
        }

    def em = {content.any-to-Distance 1em,
                 convert-font-relative-values? = true
             }

    def tail-w = em * 1.5

    set self.balloon-canvas = {BalloonCanvas corner-radius}
    {self.balloon-canvas.configure
        RectangleSide.left, x, y, tail-w, tail-size
    }

    set self.close-button =
        {CommandButton
            label = {bold x},
            takes-focus? = false,
            searchable? = false,
            selection-context = null,
            _style-element = "BalloonView/close-button", ||""
            {on Action do
                {self.close-popup}
            }
        }

    def title-bar =
        {HBox
            self.title-frame,
            {Fill}, || Stretchable after the title
            {Fill width = 4px} || Minimum spacing to close button
        }
    {if close-button? then
        {title-bar.add self.close-button}
    }

    {self.outer-frame.add
        {VBox
            || It helps to avoid any cutting due to rounded sides.
            margin = self.corner-radius / 2.0,
            {SkinnableFrame
                _style-element = "BalloonView/titlebar", ||""
                title-bar
            },
            {Fill height = self.corner-radius / 4.0},
            {Dialog
                self.content-frame
            }
        }
    }
    {self.add
        {OverlayBox
            self.balloon-canvas,
            {Frame
                {HBox
                    self.left-spacer,
                    {VBox
                        self.top-spacer,
                        self.outer-frame,
                        self.bottom-spacer
                    },
                    self.right-spacer
                }
            }
        }
    }
    {self.set-view-position}

    {if-non-null owner-view then
        set self.view-event-handler =
            {on e:GuiWindowEvent at v:View do
                {type-switch e
                 case vme:ViewMoveEvent do
                    || For standalone views, including detached applets
                    {self.set-view-position}
                 case vre:ViewResizeEvent do
                    {dump vre, v}
                    {if v != self then
                        {self.check-owner-visible-area}
                    }
                    {self.set-view-position}
                 case de:ViewDeactivateEvent do
||--                    {dump de, v}
                    {BalloonView.close-window-timer.enable delay = 0.1s}
                 case ae:ViewActivateEvent do
||--                    {dump ae, v}
                    {BalloonView.close-window-timer.disable}
                }
            }

        || Get window position in case of AppletView or inside TitledView
        || to check against resizing
        set (self.current-window-x, self.current-window-y) =
            {owner-view.get-window-position}
        set (self.current-window-x, self.current-window-y) =
            {self.owner.transform-to-display-coordinates
                self.current-window-x, self.current-window-y
            }

        || Check for visible area
        {if {type-of owner-view}.name == "AppletView" then ||""
            || We do not get 'ViewMoveEvent' in case of AppletView so only
            || in this case need to schedule an alarm.
            {self.add-event-handler 
                {on e:ViewVisibilityEvent do
                    {self.start-alarm}
                }
            }
        }
    
        {owner-view.add-event-handler {non-null self.view-event-handler}}
        {self.add-event-handler {non-null self.view-event-handler}}

    ||DEBUG
||--    {owner-view.add-event-handler
||--        {on e:RepaintNotify at v:View do
||--            {dump e, v.active?}
||--        }
    }

    set self.initializing? = false
  }|| end of constructor

  {method public open {set-size lc:LayoutContext, bounds:GRect}:void
    {super.set-size lc, bounds}
    || It might be necessary to move the balloon into position now
    {if self.layout-valid? then
        {after 0s do
            {self.set-view-position}
        }
    }
  }

  {doc-next
    {purpose Close the popup balloon.}
  }
  {method public open {close-popup}:void
    {if not self.destroyed? then
        {self.move-window-alarm.cancel}
        {BalloonView.close-window-timer.disable}
        {self.destroy}
    }
    {if-non-null ov = {self.owner.get-view} then
        {if-non-null h = self.view-event-handler then
            {ov.remove-event-handler h}
            set self.view-event-handler = null
        }
        {if-non-null h = self.timer-handler then
            {BalloonView.close-window-timer.remove-event-handler h}
            set self.timer-handler = null
        }
    }
  }

  {doc-next
    {purpose Return the width of the tail of the balloon.}
  }
  {getter public open {tail-width}:Distance
    {return self.balloon-canvas.tail-w}
  }

  {doc-next
    {purpose Return the corner radius of the balloon.}
  }
  {getter public open {corner-radius}:Distance
    {return self.balloon-canvas.corner-radius}
  }

  {method private {start-alarm}:void
    {if not self.move-window-alarm.scheduled? then
        {self.move-window-alarm.schedule delay = 0.01s}
    }
  }

  || Decide the position of the View
  {method private {set-view-position}:void
    {if self.destroyed? then
        {return}
    }

    def (current-x, current-y) =
        {self.owner.transform-to-display-coordinates self.tail-x, self.tail-y}

    let display:Display = {Display.get-primary}
||--        {{Display.get-primary}.get-nearest current-x, current-y}
    def (screen-x, screen-y, screen-w, screen-h) = {display.get-usable-area}

    let outer-w:Distance = {self.outer-frame.get-bounds}.width
    let outer-h:Distance = {self.outer-frame.get-bounds}.height
    let owner-width:Distance = {self.owner.layout.get-bounds}.width
    let owner-height:Distance = {self.owner.layout.get-bounds}.height

    ||FIXME:Check found?
    let (owner-x:Distance, owner-y:Distance, found?:bool) =
        {self.owner.get-origin-in-graphical-ancestor {self.owner.get-view}}
    || Get top-left corner
    def (owner-ascent, owner-lextent) =
        ({self.owner.layout.get-bounds}.ascent,
         {self.owner.layout.get-bounds}.lextent
        )
    set (owner-x, owner-y) = (owner-x - owner-lextent, owner-y - owner-ascent)
    set (owner-x, owner-y) =
        {{self.owner.get-view}.transform-to-display-coordinates
            owner-x, owner-y
        }

    let tail-height:Distance = self.tail-size

    let list:{Array-of side-helper} = {{Array-of side-helper}}
    || Right side
    {list.append
        {side-helper
            owner-x + owner-width - current-x,
            screen-w - (owner-x + owner-width) - outer-w,
            RectangleSide.right,
            screen-w >= current-x + outer-w + tail-height
        }
    }
    || Left side
    {list.append
        {side-helper
            current-x - owner-x,
            owner-x - outer-w,
            RectangleSide.left,
            current-x >= outer-w + tail-height
        }
    }
    || Bottom side
    {list.append
        {side-helper
            owner-y + owner-height - current-y,
            screen-h - (owner-y + owner-height) - outer-h,
            RectangleSide.bottom,
            screen-h >= current-y + outer-h + tail-height
        }
    }
    || Top side
    {list.append
        {side-helper
            current-y - owner-y,
            owner-y - outer-h,
            RectangleSide.top,
            current-y >= outer-h + tail-height
        }
    }

    || Sorting logic
    || 1. Feasible side (Which can accommodate the popup-balloon with tail)
    ||    1.1 Then the popup-balloon will be place to side which is nearest to
    ||        the edge of the owner.
    ||        (Nearest side)
    ||    1.2 If two or more are nearest and equal the side with max
    ||        remaining space.
    || 2. Not Feasible
    ||    1.1 Then max remaining space (which is the space between owner's edge
    ||        and screen's edge minus outer-frame's width or height).
    {list.sort
        comparison-proc =
            {proc {e1:side-helper, e2:side-helper }:bool
                {if e1.feasible == e2.feasible then
                    {if e1.feasible then
                        || Feasible
                        {if e1.distance < e2.distance then
                            {return true}
                         elseif e1.distance == e2.distance then
                            {if e1.space > e2.space then
                                {return true}
                             else
                                {return false}
                            }
                         else
                            {return false}
                        }
                     else
                        || Not feasible
                        {if e1.space > e2.space then
                            {return true}
                         else
                            {return false}
                        }
                    }
                 else
                    || Feasible should be before.
                    {return e1.feasible}
                }
            }
    }

    let proposed-side:RectangleSide = list[0].side
    let feasible:bool = list[0].feasible

    || Set the margins
    set self.right-spacer.width = 0m
    set self.left-spacer.width = 0m
    set self.top-spacer.height = 0m
    set self.bottom-spacer.height = 0m

    || Do the tail adjustments
    let adjust-tail-x:Distance = 0m
    let adjust-tail-y:Distance = 0m

    || Position the View
    let bto:RectangleSide
    {switch proposed-side

     case RectangleSide.right do
        {if not feasible then
            set tail-height =
                {if (screen-w - current-x - outer-w) > 0m then
                    screen-w - current-x - outer-w
                 else
                    0m
                }
        }
        || Set margin
        set self.left-spacer.width = tail-height
        || Do the tail x,y adjustments
        {if screen-h - current-y <= outer-h then
            set adjust-tail-y = -(screen-h - current-y - outer-h)
            || We would like to avoid the overlapping of corner and tail
         elseif adjust-tail-y == 0m then
            set adjust-tail-y = self.corner-radius + self.tail-width / 2 + 1pt
        }
        || Position the View
        set bto = RectangleSide.left
        {self.set-window-position
            current-x, current-y - adjust-tail-y
        }

     case RectangleSide.left do
        {if not feasible then
            set tail-height =
                {if current-x - outer-w > 0m then
                    current-x - outer-w
                 else
                    0m
                }
        }
        || Set margin
        set self.right-spacer.width = tail-height
        || Do the tail x,y adjustments
        {if screen-h - current-y <= outer-h then
            set adjust-tail-y = -(screen-h - current-y - outer-h)
            || We would like to avoid the overlapping of corner and tail
         elseif adjust-tail-y == 0m then
            set adjust-tail-y = self.corner-radius + self.tail-width / 2 + 1pt
        }
        || Position the View
        set bto = RectangleSide.right
        {self.set-window-position
            current-x - outer-w - tail-height, current-y - adjust-tail-y
        }

     case RectangleSide.bottom do
        {if not feasible then
            set tail-height =
                {if screen-h - current-y - outer-h > 0m then
                    screen-h - current-y - outer-h
                 else
                    0m
                }
        }
        || Set margin
        set self.top-spacer.height = tail-height
        || Do the tail x,y adjustments
        {if screen-w - current-x <= outer-w then
            set adjust-tail-x = -(screen-w - current-x - outer-w)
         elseif adjust-tail-x == 0m then
            set adjust-tail-x = self.corner-radius + self.tail-width / 2 + 1pt
        }
        || Position the View
        set bto = RectangleSide.top
        {self.set-window-position
            current-x - adjust-tail-x, current-y}

     case RectangleSide.top do
        {if not feasible then
            set tail-height =
                {if current-y - outer-h > 0m then
                    current-y - outer-h
                 else
                    0m
                }
        }
        || Set margin
        set self.bottom-spacer.height = tail-height
        || Do the tail x,y adjustments
        {if screen-w - current-x <= outer-w then
            set adjust-tail-x = -(screen-w - current-x - outer-w)
         elseif adjust-tail-x == 0m then
            set adjust-tail-x = self.corner-radius + self.tail-width / 2 + 1pt
        }
        || Position the View
        set bto = RectangleSide.bottom
        {self.set-window-position
            current-x - adjust-tail-x, current-y - outer-h - tail-height
       }
    }
    || If user dose not provide x, y values in proc, then default values
    || for x = 0m and y = 0m, in this case we need to check for visible
    || area of owner.
    {self.check-owner-visible-area}
    || Configure the balloon-canvas
    {self.set-size-from-child}
    {self.balloon-canvas.configure
        bto,
        adjust-tail-x, adjust-tail-y,
        self.tail-width, tail-height
    }
  }

  || Get new position for View and handle move window when provided owner
  || is embedded into browser, AppletView. Also handle the condition in case
  || of ScrollBar appears then hide and show the View

  {method private {handle-move-window-alarm}:void
    {if self.destroyed? then
        {return}
    }

    || When parent window move OR up/down using scrollbar, we need following
    || since we do not get 'ViewMoveEvent' in case of AppletView.
    let (new-win-x:Distance, new-win-y:Distance) =
        {{self.owner.get-view}.get-window-position}
    set (new-win-x, new-win-y) =
        {self.owner.transform-to-display-coordinates new-win-x, new-win-y}

    {if {abs(new-win-x - self.current-window-x)} > 0.5mm  or
        {abs(self.current-window-y - new-win-y)} > 0.5mm
     then
        {if not self.destroyed? then
            {self.check-owner-visible-area}
            {self.set-view-position}
        }
        set self.current-window-x = new-win-x
        set self.current-window-y = new-win-y
    }
    {self.start-alarm}
  }

  || If tail-x and tail-y position of owner is not in visible area then hide
  || the balloon and if it's in visible area then show the balloon.
  {method private {check-owner-visible-area}:void
    {if not self.destroyed? then

        def owner-view = {self.owner.get-view}

        || When control not in visible area?
        def (current-x, current-y) =
            {self.owner.transform-to-display-coordinates
                self.tail-x,
                self.tail-y
            }
        def (n-x, n-y) =
            {owner-view.transform-from-display-coordinates
                current-x, current-y}
        {if not {{owner-view.get-bounds}.within? n-x, n-y} then
            {if self.visibility == WindowVisibility.normal then
||--                {dump "check-owner-visible-area hiding", self}
                {self.hide}
                set self.internal-hidden? = true
            }
         else
            {if self.visibility == WindowVisibility.hidden and
                self.internal-hidden? 
             then
                {self.show}
            }   
            set self.internal-hidden? = false                
        }
    }
  }

  || Overrides on BalloonView
  || To add the contents in Dialog's content-frame
  {method public open {add g:any, ...}:#Visual
    {return
        {if self.initializing? then
            {super.add g, ...}
         else
            {value
                def val = {self.content-frame.add g, ...}
                {self.set-view-position}
                val
            }
        }
    }
  }

  || To remove the contents from Dialog
  {method public open {clear}:void
    {if not self.initializing? then
        {self.content-frame.clear}
    }
  }

  || To remove the contents from Dialog
  {method public open {remove-child}:void
    {self.content-frame.remove-child}
  }

  || To set the title of popup-balloon
  {setter public open {title caption:StringInterface}:void
    {if not self.destroyed? then
        set super.title = caption
        {self.title-frame.add replace? = true, super.title}
        {self.set-size-from-child}
    }
  }


  {method public open {show
                          force-on-display?:bool = true,
                          center?:bool = false }:void
    {if not self.destroyed? then
        {super.show
            force-on-display? = force-on-display?,
            center? = center?
        }
    }
  }  

  {method public open {hide}:void
    {if not self.destroyed? then
        {super.hide}
    }
  }

  || we should not allow the user to set the visibility as well. if we allow
  || then popup-balloon changed its visibility.
  {setter public open {visibility popup-visibility:WindowVisibility}:void

    {if popup-visibility == WindowVisibility.maximized or
        popup-visibility == WindowVisibility.minimized then
        || Ignore the call.
    }
    set super.visibility = popup-visibility
  }

  || To support moving the balloon, we should provide a set-pointer-position
  || The use-case would be something like you are following a moving object
  || on a map, and showing details about it in a balloon.
  {doc-next
    {purpose Change the position of the balloon.}
    {parameter pointer-x, The x coordinate of the point of the balloon tail,
        relative to {param owner}.
    }
    {parameter pointer-y, The y coordinate of the point of the balloon tail,
        relative to {param owner}.
    }
  }
  {method public open {set-pointer-position
                     pointer-x:Distance,
                     pointer-y:Distance
                 }:void

    set self.tail-x = pointer-x
    set self.tail-y = pointer-y
    def bounds = {self.owner.layout.get-bounds}

    {if pointer-x < -bounds.lextent then
        set self.tail-x = -bounds.lextent
    }
    {if pointer-y < -bounds.ascent then
        set self.tail-y = -bounds.ascent
    }
    {if pointer-x > -bounds.lextent + bounds.width then
        set self.tail-x = -bounds.lextent + bounds.width
    }
    {if pointer-y > -bounds.ascent + bounds.height then
        set self.tail-y = -bounds.ascent + bounds.height
    }
    {self.check-owner-visible-area}
    {self.set-view-position}
  }

}|| End of class BalloonView

|| -------------------------------------------------------------------------

||--{doc-next
||--    {purpose Pop up a {docref View} with rounded corners 
||--        and a small pointed tail.
||--    }
||--    {parameter content,
||--        A {docref Graphic} to be displayed within the {ctext BalloonView}.
||--    }
||--    {parameter owner,
||--        The {docref Graphic} that "owns" the popup. The popup will point
||--        into this object.
||--    }
||--    {parameter x, The x coordinate of the point of the balloon tail,
||--        relative to {param owner}.
||--    }
||--    {parameter y, The y coordinate of the point of the balloon tail,
||--        relative to {param owner}.
||--    }
||--    {parameter tail-size, The size of the balloon tail.
||--    }
||--    {parameter corner-radius, The radius of the corners of the balloon.
||--    }
||--    {parameter takes-focus?, If true, the popup can get the keyboard focus
||--        from the applet. The default is false. Specify true if the
||--        popup contains text fields or other controls that the user
||--        might want to type into.
||--    }
||--    {parameter max-width, The maximum width of the popup.
||--    }
||--    {parameter ..., Event handlers and keyword arguments for the
||--        superclass, {docref View}.
||--    }
||--    {details
||--        This procedure displays a "popup balloon", a small popup with
||--        a pointer to a graphical object. The popup typically contains
||--        some information about the thing that it points to.
||--
||--        There can be only one popup balloon showing at a time.  When
||--        the {ctext View} containing {param owner} is deactivated,
||--        the balloon popup is closed.
||--    }
||--  }
||--{define-proc public {popup-balloon
||--                        content:Graphic,
||--                        owner:Graphic,
||--                        title:String = "",
||--                        x:Distance = 0m,
||--                        y:Distance = 0m,
||--                        tail-size:Distance = 9pt,
||--                        max-width:Distance = 4in,
||--                        corner-radius:Distance = 9pt,
||--                        close-button?:bool = true,
||--                        takes-focus?:bool = true
||--                    }:BalloonView
||--
||--    let popup-view:BalloonView =
||--        {BalloonView
||--            content,
||--            owner,
||--            title = title,
||--            x,
||--            y,
||--            takes-focus? = takes-focus?,
||--            close-button? = close-button?,
||--            tail-size = tail-size,
||--            max-width = max-width,
||--            corner-radius = corner-radius
||--        }
||--    {return popup-view}
||--}

|| -------------------------------------------------------------------------

{define-proc package {make-style-sheet ss:#StyleSheet}:StyleSheet
    def decorations-start-color = {FillPattern.from-color
                                      {Color.from-rgb-uint8 136, 188, 238}
                                  }
    def decorations-end-color = {get-shadow-for decorations-start-color}

    def button-border-color = {get-highlight-for decorations-end-color}

    def button-rollover-color = {get-shadow-for decorations-end-color}

    || Shadow-spec and shadow-color for buttons
    def button-shadow-spec =
        {ShadowSpec
            offset = 1px,
            angle = 120deg,
            corner-radius = 1px,
            falloff = 2,
            upper-left-rounded? = true,
            upper-right-rounded? = true,
            lower-right-rounded? = true,
            lower-left-rounded? = true
        }
    def button-shadow-color =
        {FillPattern.from-rgb
            255, 255, 255,
            opacity = 0.6
        }

    def bss =
    {StyleSheet
        {StyleRule "BalloonView", ||""
            background = "white", ||""
            color = "black" ||""
        },
        {StyleRule "BalloonView/title-frame", ||""
            text-breakable? = false,
||--            skin =
||--                {ShadedSkinSpec
||--                    "silver", ||""
||--                    "silver", ||""
||--                    highlight-boundary = 0.0,
||--                    border-color = "gray",
||--                    corner-radius = 3px
||--                },
            border-width = 0pt,
            border-spec =
                {BorderSpec bottom-margin = 3pt}
        },
        {StyleRule "BalloonView/titlebar", ||""
            color = "black", ||""
            border-color = "gray",
            border-spec = 
                {BorderSpec
                    bottom-border-width = 1px
                },                            
            font-size = {prefs}["caption-font-size"], ||""
            font-weight = {prefs}["caption-font-weight"], ||""
            font-style = {prefs}["caption-font-style"] ||""
        },
        {StyleRule "BalloonView/content", ||""
            border-width = 0pt,
            skin =
                {ShadedSkinSpec
                    "green", ||""
                    "white", ||""
                    draw-top-edge? = false,
                    draw-right-edge? = false,
                    draw-bottom-edge? = false,
                    draw-left-edge? = false
                }
        },
        {StyleRule "BalloonView/close-button", ||""
            vorigin = 0.85,
            height = 12pt,
            width = 12pt,
            color = "white", ||""
            font-size = {prefs}["caption-font-size"], ||""
            font-weight = {prefs}["caption-font-weight"], ||""
            font-style = {prefs}["caption-font-style"], ||""
            skin =
                {ShadedSkinSpec
                    decorations-start-color,
                    decorations-end-color,
                    rollover-start-color = decorations-end-color,
                    rollover-end-color = decorations-start-color,
                    border-color = button-border-color,
                    rollover-border-color = button-border-color,
                    pressed-overlay = button-rollover-color,
                    highlight-alpha-1 = 0.3,
                    highlight-boundary = 1percent,
                    corner-radius = 3px,
                    upper-left-rounded? = true,
                    upper-right-rounded? = true,
                    lower-left-rounded? = true,
                    lower-right-rounded? = true
                }
        },
        ss
    }
    {return bss}
}

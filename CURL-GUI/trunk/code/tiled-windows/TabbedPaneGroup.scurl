{define-class public open TabbedPaneGroup {inherits PaneGroup}
  field protected tc:TabContainer

  {constructor public {default
                          tab-placement:TabPlacement = TabPlacement.bottom,
                          percent:double = -1.0,
                          current:int = 0,
                          ...:BasePane
                      }
    {construct-super {splice ...}}
    set self.width = {add-stretch}
    set self.height = {add-stretch}

    set self.percent = percent
    set self.tc =
        {TabContainer
            tab-placement = tab-placement,
            takes-focus? = false,
            || - fills half when origin, bottom, 100%
            || - fills all when center, top, < 100%
            vorigin = "center",
            height = 
                {switch tab-placement
                 case TabPlacement.bottom do
                    || TODO: why is this needed ??
                    || - after? = true stretches the labels instead
                    {add-stretch after? = false, before? = true}
                 else {add-stretch}},
            width = {add-stretch}
        }
    {for base-pane in ... do
        set base-pane.pane-group = self
        {self.add-pane base-pane}
    }
    set self.tc.current-pane-index = current
    {self.add self.tc}
  }

  {getter public sealed {size}:int
    {return self.tc.tab-panes.size}
  }

  {getter package {drag-view-divisor}:int
    {return 3}
  }

  {method package {get-percent pane:BasePane}:double
    || TODO:?
    {return 1.0}
  }

  {method public {find child:any}:int
    {for i:int = 0 below self.tc.tab-panes.size do
        def bp = {self.get-pane i}
        {if child == bp then
            {return i}
        }
    }
    {return -1}
  }

|| TODO: Is returning only BasePanes too restrictive?
  {method public {get index:int}:#BasePane
    {return {self.get-pane index}}
  }

  {method public {get-pane index:int}:#BasePane
    let tp:#TabPane
    {if index >= 0 and index < self.tc.tab-panes.size then
        set tp = self.tc.tab-panes[index]
    }
    {if-non-null tp then
        def child = tp.child.graphic
        {type-switch child
         case bp:BasePane do
            {return bp}
        }
    }
    {return null}
  }

  {method protected {insert-pane
                        pane:SinglePane,
||--                        orientation:Orientation = Orientation.vertical,
                        at-top-or-left?:bool = false
                    }:void
    || TODO:
  }

  {method protected {insert-pane-in-target
                        pane:SinglePane,
                        target:SinglePane,
||--                        orientation:Orientation = Orientation.vertical,
                        at-top-or-left?:bool = false
                    }:void
    || TODO:
||--    def content = pane.content asa PaneContent
||--    let tab-dragger:TabDragger = {content.make-tab-dragger}
||--    let tab-pane:TabPane = {TabPane label = tab-dragger, content}
||--    set tab-dragger.tab-pane = tab-pane
||--    {if at-top-or-left? then
||--        {self.tc.add-pane-at-index tab-pane, 0, show? = true}
||--     else
||--        {self.tc.add-pane-at-index
||--            tab-pane,
||--            self.tc.tab-panes.size,
||--            show? = true
||--        }
||--    }
||--    set target.title-bar.title = content.title
||--    set target.title-bar.controls = content.title-controls
||--    set content.single-pane = target
  }

|| TODO: Is accepting only BasePanes too restrictive?
  {method public {add-pane pane:BasePane}:void
    {self.add-pane-at-index pane, self.tc.tab-panes.size}
  }

|| TODO: Is accepting only BasePanes too restrictive?
  {method public {add-pane-at-index pane:BasePane, index:int}:void
    {type-switch pane
     case sp:SinglePane do
|| TODO: When (if?) SinglePane's content becomes strictly a PaneContent, this PaneContent cast will not be necessary.
        def tab = {(sp.content asa PaneContent).make-tab-dragger}
        def tp = {TabPane label = tab, pane}
        set tab.tab-pane = tp
        {self.tc.add-pane-at-index tp, index, show? = true}
        {if index >= 0 and index < self.base-panes.size then
            {self.base-panes.insert pane, index}
         else
            {self.base-panes.append pane}
        }
     case pg:PaneGroup do
|| TODO: Test this case.
        def sps = {pg.get-descendant-single-panes}
        {for sp key i in sps do
|| TODO: When (if?) SinglePane's content becomes strictly a PaneContent, this PaneContent cast will not be necessary.
            def tab = {(sp.content asa PaneContent).make-tab-dragger}
            def tp = {TabPane label = tab, pane}
            set tab.tab-pane = tp
            def ndx = index + i
            {self.tc.add-pane-at-index tp, ndx, show? = true}
            {if ndx >= 0 and ndx < self.base-panes.size then
                {self.base-panes.insert pane, ndx}
             else
                {self.base-panes.append pane}
            }
        }
    }
  }

  {method public sealed {add-pane-and-resize
                            pane:BasePane,
                            index:int
                        }:void
    {self.add-pane-at-index pane, index}
  }

  {method protected {swap-panes my-pane:SinglePane, other-pane:SinglePane}:void
    || TODO:
  }

|| TODO: Is returning only BasePanes too restrictive?
  {method public {remove-pane-at-index index:int}:#BasePane
    {if index < 0 or index >= self.base-panes.size then
        {return null}
    }
    {self.base-panes.remove index}
    def pane = {self.get-pane index}
    {self.remove-pane-at-index index}
    {return pane}
  }

  {method public sealed {remove-pane-and-resize index:int}:void
    {self.tc.remove-pane-at-index index}
  }

  {method package {save-state out:TextOutputStream}:void
    let current:int = 0
    {for pane key i in self.tc.tab-panes do
        {if pane.showing? then
            set current = i
            {break}
        }
    }
    {format out = out,
        "\n\{tabbed-pane-group percent = %s, current = %d",
        self.percent,
        current
    }
    {for tab in self.tc.tab-panes do
        {out.write-one-string ", "}
        def content = tab.content asa SinglePane
        {content.save-tabbed-content-state out}
    }
    {out.write-one '\}'}
  }

  {method public {replicate invert-orientation?:bool = false}:PaneGroup
    def replica = {TabbedPaneGroup}
    {return replica}
  }
}

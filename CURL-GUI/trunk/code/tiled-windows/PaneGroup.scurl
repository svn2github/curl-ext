{define-class public abstract sealed PaneGroup {inherits BasePane}
  field protected base-panes:{Array-of BasePane}

  {constructor public {default ...:BasePane}
    set self.base-panes = {new {Array-of BasePane}}
    {construct-super}
  }

  {setter public {root-container pc:#PaneContainer}:void
    set self._root-container = pc
    {for pane in self.base-panes do
        set pane.root-container = pc
    }
  }

  {getter public abstract sealed {size}:int}
  {getter package abstract {drag-view-divisor}:int}
  {method package abstract {get-percent pane:BasePane}:double}
|| TODO: Is returning only BasePanes too restrictive?
  {method public abstract {get index:int}:#BasePane}
  {method public abstract {find child:any}:int}
  {method protected abstract {insert-pane
                                 pane:SinglePane,
                                 orientation:Orientation = Orientation.vertical,
                                 at-top-or-left?:bool = false
                             }:void}
  {method protected abstract {insert-pane-in-target
                                 pane:SinglePane,
                                 target:SinglePane,
                                 orientation:Orientation = Orientation.vertical,
                                 at-top-or-left?:bool = false
                             }:void}
|| TODO: Is accepting only BasePanes too restrictive?
  {method public abstract {add-pane pane:BasePane}:void}
|| TODO: Is accepting only BasePanes too restrictive?
  {method public abstract {add-pane-at-index pane:BasePane, index:int}:void}
  {method public abstract sealed {add-pane-and-resize
                                     pane:BasePane,
                                     index:int
                                 }:void}
  {method protected abstract {swap-panes
                                 my-pane:SinglePane,
                                 other-pane:SinglePane
                             }:void}
|| TODO: Is returning only BasePanes too restrictive?
  {method public abstract {remove-pane-at-index index:int}:#BasePane}
  {method public abstract sealed {remove-pane-and-resize index:int}:void}
  {method public abstract {replicate
                              invert-orientation?:bool = false
                          }:PaneGroup}

  {method public {get-descendant-single-panes}:{Array-of SinglePane}
    def sps = {new {Array-of SinglePane}}
    {for pane in self.base-panes do
        {type-switch pane
         case sp:SinglePane do
            {sps.append sp}
         case pg:PaneGroup do
            {sps.append {splice {pg.get-descendant-single-panes}}}
         else
            || Unsupported
        }
    }
    {return sps}
  }
}

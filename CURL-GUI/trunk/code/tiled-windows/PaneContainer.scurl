
{define-class public open PaneContainer {inherits Frame}
  field protected pane-content-proc:{proc-type {PaneContentID}:PaneContent}
  field public known-content:PaneMap = {PaneMap}
  field constant private status-bar:#StatusBar
  field constant private floating-window-menu:#MenuBar
  field constant package pane-focus-mgr:PaneFocusManager = {PaneFocusManager}

  || DEBUGGING
  field public log?:bool = false
  field public-get log-actions:StringArray = {StringArray}
  field public-get log-specs:StringArray = {StringArray}
  {method {log msg:String}:void
    {if self.log? then
        {output "=============================="}
        {output msg}
        {self.log-actions.append msg}
        def spec = self.pane-layout
        {output spec}
        {self.log-specs.append spec}
    }
  }

  {constructor public
    {empty
        pane-content-proc:{proc-type {PaneContentID}:PaneContent},
        status-bar:#StatusBar = {StatusBar},
        floating-window-menu:#MenuBar = null,
        ...
    }
    {construct-super
        hstretch? = true,
        vstretch? = true,
        {splice ...}
    }
    set self.status-bar = status-bar
    set self.floating-window-menu = floating-window-menu
    set self.pane-content-proc = pane-content-proc
    {if-non-null sb = self.status-bar then
        {self.add
            {VBox
                {EmptyPaneGroup},
                status-bar
            }
        }
    }
  }

  {constructor public
    {default
        pane-content-proc:{proc-type {PaneContentID}:PaneContent},
||--        orientation:Orientation = Orientation.horizontal,
        status-bar:#StatusBar = {StatusBar},
        floating-window-menu:#MenuBar = null,
        ...
    }
    set self.status-bar = status-bar
    set self.floating-window-menu = floating-window-menu
    set self.pane-content-proc = pane-content-proc

    def args = {Arguments}
    def panes = {new {Array-of BasePane}}
    {for (arg, k) in ... do
        {type-switch arg
         case sp:SinglePane do
            set sp.root-container = self
            {panes.append sp}
         case pg:PaneGroup do
            set pg.root-container = self
            {panes.append pg}
         case bp:BasePane do
            set bp.root-container = self
            {panes.append bp}
         else
            {args.append arg, keyword = k}
        }
    }
    {construct-super
        hstretch? = true,
        vstretch? = true,
        {splice args}
    }
    {switch panes.size
     case 0 do
        {if-non-null sb = self.status-bar then
            {self.add
                replace? = true,
                {VBox
                    {EmptyPaneGroup},
                    sb
                }
            }
         else
            || Nothing
        }
     case 1 do
        def pane = panes[0]
        {if pane.percent <= 0.0 then
            set pane.percent = 1.0
        }
        {type-switch pane
         case pg:PaneGroup do
            {if-non-null sb = self.status-bar then
                {self.add
                    replace? = true,
                    {VBox
                        pg,
                        sb
                    }
                }
             else
                {self.add replace? = true, pg}
            }
         else || BasePane
            {if-non-null sb = self.status-bar then
                {self.add
                    replace? = true,
                    {VBox
                        {TiledPaneGroup
|| TODO: Do we need a way to declaratively specify max-rows & max-cols?
                            max-rows = 1,
||--                            orientation = orientation,
                            percent = 1.0,
                            pane
                        },
                        sb
                    }
                }
             else
                {self.add
                    replace? = true,
                    {TiledPaneGroup
|| TODO: Do we need a way to declaratively specify max-rows & max-cols?
                        max-rows = 1,
||--                        orientation = orientation,
                        percent = 1.0,
                        pane
                    }
                }
            }
        }
     else
|| TODO: How should the panes be laid out? Tabular?
        {for pane in panes do
            set pane.percent = 1.0 / panes.size
        }
        def root =
            {TiledPaneGroup
|| TODO: Do we need a way to declaratively specify max-rows & max-cols?
                max-rows = 0,
                max-cols = 0,
||--                orientation = orientation,
                percent = 1.0,
                {splice panes}
            }
        {if-non-null sb = self.status-bar then
            {self.add
                replace? = true,
                {VBox
                    root,
                    sb
                }
            }
         else
            {self.add replace? = true, root}
        }
    }
  }

  {factory public
    {from-layout-spec
        layout-spec:String,
        pane-content-proc:{proc-type {PaneContentID}:PaneContent},
        status-bar:#StatusBar = {StatusBar},
        floating-window-menu:#MenuBar = null
    }:PaneContainer
    || NOTE: The default constructor tries to do the right thing if given
    ||       multiple SinglePanes, or multiple PaneGroups. The from-layout-spec
    ||       factory expects things to be more formally defined, so isn't as
    ||       forgiving.

|| TODO: Orientation should come from the layout-spec, or be a keyword on PaneContainer (which might be ignored).
    def pane-container =
        {PaneContainer.empty
            pane-content-proc,
            status-bar = status-bar,
            floating-window-menu = floating-window-menu
        }
    set pane-container.pane-layout = layout-spec
    {return pane-container}
  }

  {getter public {pane-layout}:String
    def windows = self.known-content
    def buf = {StringBuf}
    {self.save-state  windows, buf}
    {return {buf.to-String}}
  }

  {setter public {pane-layout layout-spec:String}:void
    {evaluate
        layout-spec,
        package =
            {evaluate-saved-windows-package
                || TODO: consider caching this
                {fn name => {self.pane-content-for name}},
                self
            }
    }
|| TODO: Gracefully handle missing content
  }

  {method package {pane-content-for name:PaneContentID}:PaneContent
    def content = {self.pane-content-proc name}
    {if not {self.known-content.key-exists? name} then
        set self.known-content[name] = content}
    {return content}
  }

  {method public {get-content name:PaneContentID}:PaneContent
    {return self.known-content[name]}
  }

  {getter package {pane-group}:PaneGroup
    || TODO: set field in constructor
    {if-non-null sb = self.status-bar then
        def vbox = self.child.graphic asa VBox
|| TODO: What about an empty PaneContainer? The child might be null or a Fill.
        {for c in vbox.graphical-children do
            {type-switch c
             case pg:PaneGroup do
                {return pg}
            }
        }
        {return {EmptyPaneGroup}}
     else
        {return self.child.graphic asa PaneGroup}
    }
  }

  {method public sealed {replace-pane-group-with 
                            top:PaneGroup,
                            ...:SinglePane
                        }:void
    {self.pane-group.replace-with top}
    {for window in ... do
        {if not window.hidden? then
            {switch window.state
             case PaneState.dockable, PaneState.floating do
                {self.show-pane window}
            }  
        }
    }
  }

  {method package {get-single-pane-at x:Distance, y:Distance}:#SinglePane
    let container:PaneGroup = self.pane-group
    set (x, y) = {container.transform-from-display-coordinates x, y}
    let g:#Graphic = {container.find-graphic-at x, y,
                         {proc {g:Graphic}:bool
                             {return g isa SinglePane}
                         }
                     }
    {return g asa #SinglePane}
  }

  {method public {insert-pane
                     pane:SinglePane,
||--                     orientation:Orientation = Orientation.vertical,
                     at-top-or-left?:bool = false
                 }:void
    let pg:PaneGroup = self.pane-group
    {pg.insert-pane
        pane,
||--        orientation = orientation,
        at-top-or-left? = at-top-or-left?
    }
    {pane.mark-as-docked}
  }

  {method package {show-drop-zone
                      x:Distance,
                      y:Distance,
                      drag-view:View
                  }:bool
    set (x, y) = {self.transform-from-display-coordinates x, y}
    let grect:GRect = {self.layout.get-cell-bounds}
    let width:Distance = grect.width
    let height:Distance = grect.height
    let pane-group:PaneGroup = self.pane-group
    let (d-x:Distance, d-y:Distance) = 
        {self.transform-to-display-coordinates 0pt, 0pt}
    {if x < 0pt and x > 0pt - dock-zone-size then
        {if y < 0pt or y > height then {return false}}
        {drag-view.set-window-position-and-size 
            d-x, 
            d-y,
            width / pane-group.drag-view-divisor,
            height
        }
        {return true}
     elseif x > width and x < width + dock-zone-size then
        {if y < 0pt or y > height then {return false}}
        {drag-view.set-window-size
            width / pane-group.drag-view-divisor,
            height
        }
        let (vwidth:Distance, vheight:Distance) = {drag-view.get-size}
        {drag-view.set-window-position d-x + width - vwidth, d-y}
        {return true}
     elseif y < 0pt and y > 0pt - dock-zone-size then
        {if x < 0pt or x > width then {return false}}
        {drag-view.set-window-position-and-size 
            d-x, 
            d-y,
            width,
            height / pane-group.drag-view-divisor
        }
        {return true}
     elseif y > height and y < height + dock-zone-size then
        {if x < 0pt or x > width then {return false}}
        {drag-view.set-window-size
            width,
            height / pane-group.drag-view-divisor
        }
        let (vwidth:Distance, vheight:Distance) = {drag-view.get-size}
        {drag-view.set-window-position d-x, d-y + height - vheight}
        {return true}
    }
    {return false}
  }

  {method package {compute-dock-state
                      x:Distance,
                      y:Distance
                  }:DockingAction
    set (x, y) = {self.transform-from-display-coordinates x, y}
    let grect:GRect = {self.layout.get-cell-bounds}
    let width:Distance = grect.width
    let height:Distance = grect.height
    {if x < 0pt and x > 0pt - dock-zone-size then
        {return DockingAction.left}
     elseif x > width and x < width + dock-zone-size then
        {return DockingAction.right}
     elseif y < 0pt and y > 0pt - dock-zone-size then
        {return DockingAction.top}
     elseif y > height and y < height + dock-zone-size then
        {return DockingAction.bottom}
    }
    {return DockingAction.none}
  }

  {method private {do-docking 
                      pane:SinglePane, 
                      state:DockingAction, 
                      target:#SinglePane
                  }:void
    let content:PaneContent = pane.visible-pane-content

    {if-non-null target then
        {switch state
         case DockingAction.left do
            {target.insert-pane
                pane,
||--                orientation = Orientation.horizontal,
                at-top-or-left? = true
            }
         case DockingAction.right do
            {target.insert-pane
                pane,
||--                orientation = Orientation.horizontal,
                at-top-or-left? = false
            }
         case DockingAction.top do
            {target.insert-pane
                pane,
||--                orientation = Orientation.vertical,
                at-top-or-left? = true
            }
         case DockingAction.bottom do
            {target.insert-pane
                pane,
||--                orientation = Orientation.vertical,
                at-top-or-left? = false
            }
         case DockingAction.tab do
            {target.insert-content-as-tab pane}
            {content.sync-focus-to-title-bar}
        }
     else
        {switch state
         case DockingAction.left do
            {self.insert-pane
                pane,
||--                orientation = Orientation.horizontal,
                at-top-or-left? = true
            }
         case DockingAction.right do
            {self.insert-pane
                pane,
||--                orientation = Orientation.horizontal,
                at-top-or-left? = false
            }
         case DockingAction.top do
            {self.insert-pane
                pane,
||--                orientation = Orientation.vertical,
                at-top-or-left? = true
            }
         case DockingAction.bottom do
            {self.insert-pane
                pane,
||--                orientation = Orientation.vertical,
                at-top-or-left? = false
            }
        }
    }
    {content.refresh-pane-focus}
||--    {content.refresh-decorations-focus}
  }

  {method package {dock-pane 
                      pane:SinglePane, 
                      state:DockingAction, 
                      target:#SinglePane
                  }:void
    {if pane.state == PaneState.docked then
        {self.remove-pane pane}
     elseif pane.state == PaneState.dockable then
        {{pane.get-view}.destroy}
    }
    {self.do-docking pane, state, target}
    {if-debuggable
        {self.log
            {message dock-pane:
                {value pane.content.name}
                {value state},
                {if-non-null target then target.content.name else null}}}
    }
  }

  {method package {dock-pane-from-tab 
                      pane:SinglePane, 
                      old:SinglePane,
                      tab-pane:TabPane,
                      state:DockingAction, 
                      target:#SinglePane
                  }:void
    {self.remove-old-tab tab-pane, old}
    {self.do-docking pane, state, target}
    {if-debuggable
        {self.log
            {message dock-pane-from-tab:
                {value pane.content.name}
                {value state},
                {if-non-null target then target.content.name else null}}}
    }
  }

  {method package {heuristic-dock-pane-from-path pane:SinglePane}:void
    let pane-group:PaneGroup = self.pane-group
    || Special case if there are no visible windows
    {if pane-group.size == 0 then
|| TODO: When this is no longer a PanedWindow, we'll need another way to do this
        {pane-group.add-pane pane}
        {pane.mark-as-docked}
        {pane.visible-pane-content.refresh-pane-focus}
||--        {pane.visible-pane-content.refresh-decorations-focus}
        {return}
    }
    {for i = 0 below pane.path.size - 1 do
        let index:int = pane.path[i]
        let j:int = {if index < pane-group.size then
                        index
                     else
                        pane-group.size - 1
                    }
|| TODO: When this is no longer a PanedWindow, we'll need another way to do this
||--        let next:Visual = {pane-group.get j}
        {if-non-null next = {pane-group.get j} then
            {type-switch next
             case pg:PaneGroup do
                set pane-group = pg
             else
                let new-pg:PaneGroup =
                    {pane-group.replicate invert-orientation? = true}
                set new-pg.pane-group = pane-group
                {pane-group.remove-pane-at-index j}
                {pane-group.add-pane-at-index new-pg, j}
                {new-pg.add-pane next}
                set pane-group = new-pg

            }
        }
    }
    {if pane.path.empty? then
        {pane-group.add-pane-and-resize pane, pane-group.size}
     else
        let insert-position:int = pane.path[pane.path.size - 1]
        {if pane.from-tab? then
            {if insert-position >= pane-group.size then
                set insert-position = pane-group.size - 1
            }
|| TODO: When this is no longer a PanedWindow, we'll need another way to do this
            let target:BasePane = 
                pane-group[insert-position] asa BasePane
            {while true do
                {if target isa SinglePane then
                    {break}
                }
                set target = (target asa PaneGroup)[0] asa BasePane
            }
            {(target asa SinglePane).insert-content-as-tab pane}
         else
            {if insert-position > pane-group.size then
                set insert-position = pane-group.size
            }
            {pane-group.add-pane-and-resize pane, insert-position}
        }
    }
    {pane.visible-pane-content.refresh-pane-focus}
||--    {pane.visible-pane-content.refresh-decorations-focus}
    {pane.mark-as-docked}
    {if-debuggable
        {self.log
            {message dock-pane-from-path:
                {value pane.content.name}}}
    }
  }

  {method package {float-pane pane:SinglePane, dockable?:bool}:void
    {type-switch pane.content
     case content:PaneContent do
        set pane.path = {self.compute-path pane}
        set (pane.pane-group, pane.percent) = {pane.compute-percentage}
        {self.remove-pane pane}
        {self.do-float pane, dockable?}
     case tabs:TabContainer do
        let current-tab:TabPane = {non-null tabs.current-pane}
        {self.float-pane-from-tab 
            current-tab.content asa PaneContent,
            current-tab,
            dockable?
        }
    }
    {if-debuggable
        {self.log
            {message float-pane:
                {value pane.content.name}
                {value dockable?}}}
    }
  }

  || Invoked whenever a floating pane is activated.
  {method public open {on-floating-pane-activate pane:SinglePane}:void}

  {method private {create-floating-view
                      pane:SinglePane,
                      center?:bool
                  }:View
    let pane-view:#View = {pane.get-view}
    {if {self.get-view} != pane-view then
        {if-non-null pane-view then
            {return pane-view}
        }
    }

    let owner:#View = {self.get-view}
    let view:View =
        {View
            owner = owner, 
            center? = center?, 
            width = pane.floating-width, 
            height = pane.floating-height,
            hstretch? = true,
            vstretch? = true,
            decorations? = false,
            context-menu-for-view = null,
            {on ViewActivateEvent do
                {if pane.visible-pane-content.has-focus? then
                    {pane.visible-pane-content.refresh-pane-focus}
                 else
                    {pane.visible-pane-content.request-pane-focus}
                }
||--                {if pane.visible-pane-content.has-decorations-focus? then
||--                    {pane.visible-pane-content.refresh-decorations-focus}
||--                 else
||--                    {pane.visible-pane-content.request-decorations-focus}
||--                }
                {if-non-null menu-bar = self.floating-window-menu then
                    {platform-switch case "carbon" do
                        set view.mac-menu-bar = menu-bar 
                     else
                        {view.focus-manager.request-menu-focus menu-bar}
                    }
                }
                {self.on-floating-pane-activate pane}
            },
            || TEMP until this window has no title bar
            {on e:WindowClose do
                {e.consume}
|| TODO: When this is no longer a PanedWindow, we'll need another way to do this
                {pane.hide}
            }
        }
    {view.add
        {ResizeableDecorationlessView 
            view,
            cursor = cursor-arrow,
            border-width = 4pixels,
            border-color = FillPattern.gray,
            border-style = BorderStyle.ridge,
            vstretch? = true,
            hstretch? = true,
            pane
        }
    }

    {if-non-null owner then
        {if owner.visibility != WindowVisibility.hidden then
            {view.show}
        }
     else
        {dump "No owner", self}
    }
    {return view}
  }

  {method private {do-float pane:SinglePane, dockable?:bool}:void
    set pane.state = 
        {if dockable? then PaneState.dockable else PaneState.floating}
    {if pane.floating-x < 0pt then
        let view:View = {self.create-floating-view pane, true}
        set (pane.floating-x, pane.floating-y) = {view.get-position}
     else
        {self.show-pane pane}
    }
  }

  {method private {remove-old-tab
                      tab:TabPane,
                      old:SinglePane,
                      focus-remaining?:bool = false
                  }:void

|| TODO: This crashes because the path to the PaneContent skips the SinglePane, but...
|| TODO: Should the TabbedPaneGroup work similarly to how the TabContainer in TiledWindowPane worked? That is, should there be a single titlebar for the group, and each TabPane contains PaneContent instead of SinglePanes?

    let container:TabContainer = tab.tab-container asa TabContainer
    {container.remove-pane tab}
    {if container.tab-panes.size > 1 then
        {container.show-last}
        let content:PaneContent =
            container.current-pane.content asa PaneContent
        set old.title-bar.title = content.title
        set old.title-bar.controls = content.title-controls
        {if focus-remaining? then
            {content.request-pane-focus}
||--            {content.request-decorations-focus}
        }
     else
        let remaining-content:PaneContent =
            container.tab-panes[0].content asa PaneContent
        set old.content = remaining-content
        set old.title-bar.title = remaining-content.title
        set old.title-bar.controls = remaining-content.title-controls
        {if focus-remaining? then
            {remaining-content.request-pane-focus}
||--            {remaining-content.request-decorations-focus}
        }
    }
    {old.visible-pane-content.sync-focus-to-title-bar}
  }

  {method package {float-pane-from-tab 
                      content:PaneContent,
                      tab:TabPane,
                      dockable?:bool
                  }:void
    let old-pane:SinglePane = {non-null content.single-pane}
    let new-pane:SinglePane = {old-pane.clone-with-new-content content}
    set new-pane.path = {self.compute-path old-pane}
    set (new-pane.pane-group, new-pane.percent) =
        {old-pane.compute-percentage}
    {self.remove-old-tab tab, old-pane}
    {self.do-float new-pane, dockable?}
    {if-debuggable
        {self.log
            {message float-pane:
                {value content.name}
                {value dockable?}}}
    }
  }


  {method package {show-pane pane:SinglePane}:void
    set pane.hidden? =
        {if pane.state == PaneState.docked then
            {self.heuristic-dock-pane-from-path pane}
            false
         else
            let view:View = {self.create-floating-view pane, false}
            {view.set-window-position pane.floating-x, pane.floating-y}
            view.visibility == WindowVisibility.hidden
        }
    {if-debuggable
        {self.log
            {message show-pane:
                {value pane.content.name}}}
    }
  }

  {method package {hide-pane
                      pane:SinglePane,
                      content:#PaneContent = null
                  }:void
    {if pane.state == PaneState.docked then
        {type-switch pane.content
         case content:PaneContent do
            set pane.path = {self.compute-path pane}
            set (pane.pane-group, pane.percent) =
                {pane.compute-percentage}
            {self.remove-pane pane}
            || Attempt to focus another pane here, or focus no pane.
            {self.focus-first-pane} 
         case tabs:TabContainer do
            let tab-to-remove:TabPane = 
                {uninitialized-value-for-type TabPane}
            {if-non-null content then
                {for tab in tabs.tab-panes do
                    {if tab.content == content then
                        set tab-to-remove = tab
                        {break}
                    }
                }
             else
                set tab-to-remove = {non-null tabs.current-pane}
            }
            let pane-to-hide:SinglePane = 
                {pane.clone-with-new-content 
                    tab-to-remove.content asa PaneContent
                }
            {self.remove-old-tab tab-to-remove, pane, focus-remaining? = true}
            set pane-to-hide.path = {self.compute-path pane}
            set (pane-to-hide.pane-group, pane-to-hide.percent) =
                {pane.compute-percentage}
            set pane-to-hide.hidden? = true
            set pane = pane-to-hide
        }
     else
        let floating-view:View = {non-null {pane.get-view}}
        set (pane.floating-width, pane.floating-height) =
            {floating-view.get-size}
        set (pane.floating-x, pane.floating-y) = {floating-view.get-position}
        {pane.detach}
        {floating-view.destroy}
    }
    set pane.hidden? = true
    {if-debuggable
        {self.log
            {message hide-pane:
                {value pane.content.name}
                {if-non-null content then content.name else null}}}
    }
  }

  {method package {compute-path pane:SinglePane}:{Array-of int}
    let path:{Array-of int} = {new {Array-of int}}
    let child:Graphic = pane
    {while true do
        let pg:PaneGroup = {get-parent-pane-group child}
        let index:int = {pg.find child}
        {assert index != -1}
        {path.append index}
        {if pg == self.pane-group then {break}}
        set child = pg
    }
    {path.reverse}
    {return path}
  }

  {method private {remove-pane pane:Graphic}:void
    let pg:PaneGroup = {get-parent-pane-group pane}
    {pg.remove-pane-and-resize {pg.find pane}}
    {if pg != self.pane-group and pg.size == 0 then
        {self.remove-pane pg}
    }
  }

  {method public sealed {save-state 
                            windows:PaneMap,
                            out:TextOutputStream
                        }:void
    {format out = out, "\{pane-container "}
    {self.pane-group.save-state out}
    {for content in windows do
        {if-non-null pane = content.single-pane then
            {if pane.state != PaneState.docked or pane.hidden? then
                {if not pane.hidden? then
                    {pane.record-floating-state}
                }
                {out.write-one-string ", "}
                {pane.save-window-content-state out}
            }
        }
    }
    {out.write-one '\}'}
  }

  || These are the windows that are not reachable from the main window
  {method public sealed {hide-or-show-floating-windows
                            windows:PaneMap,
                            hide?:bool = true
                        }:void
    {for content in windows do
        {if-non-null window = content.single-pane then
            {if not window.hidden? and window.state != PaneState.docked then
                {if hide? then
                    {window.hide content = content}
                 else
|| TODO: root-container could be null
                    {window.root-container.show-pane window}
                }
            }
        }
    }
  }

  {method public sealed {detach-content-windows
                            windows:PaneMap
                        }:void
    {for content in windows do
        {if-non-null window = content.single-pane then
            {if not window.hidden? then
                {content.detach}
                {if window.state != PaneState.docked then
                    {{window.get-view}.destroy}
                }
            }
        }
    }
  }

  || Focus the "first" pane in our graphic hierarchy, if any.  If no
  || pane was found to focus, return false.
  {method public sealed {focus-first-pane}:(any-focused?:bool)
    {if-non-null
        pane = {self.find-graphic-at 0pt, 0pt,
                   {proc {g:Graphic}:bool
                       {return g isa SinglePane}
                   }
               }
     then
        {(pane asa SinglePane).visible-pane-content.request-pane-focus}
||--        {(pane asa SinglePane).visible-pane-content.request-decorations-focus}
        {return true}
     else
        {return false}
    }
  }

  {method public {enable-status-messages}:void
    {if-non-null sb = self.status-bar then
        set sb.status-messages-enabled? = true
    }
  }

  {method public {disable-status-messages}:void
    {if-non-null sb = self.status-bar then
        set sb.status-messages-enabled? = false
    }
  }

  {method public open {set-status-text text:String}:void
    {if-non-null sb = self.status-bar then
        {sb.set-status-text text}
    }
  }
}

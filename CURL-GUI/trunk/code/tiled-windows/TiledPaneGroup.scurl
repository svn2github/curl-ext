{define-class public open TiledPaneGroup {inherits PaneGroup}
  field protected pw:PanedWindow
  field protected max-rows:int = 0
  field protected max-cols:int = 0
||--  field protected orientation:Orientation

  {constructor public {default
||--                          orientation:Orientation = Orientation.vertical,
                          max-rows:int = 0,
                          max-cols:int = 0,
|| TODO: BasePanes need a percent value when they're in a TiledPaneGroup, so percent needs to be -1 for any other circumstance (or an unset option somewhere)
                          percent:double = -1.0,
                          ...:BasePane
                      }
||--    {construct-super orientation = orientation, percent = percent, {splice ...}}

    {construct-super {splice ...}}
    set self.width = {add-stretch}
    set self.height = {add-stretch}
    set self.max-rows = max-rows
    set self.max-cols = max-cols
    {assert max-rows > 0 or max-cols > 0}
    def sizes = {{Array-of double}}
    def base-panes = {{Array-of BasePane} {splice ...}}
    || TODO: When is SinglePane.percent really optional?
    || - It seems to throw an error when it isn't set.
    {if self.max-rows == 1 then
        || horizontal
        set self.pw = {PanedWindow orientation = Orientation.horizontal}
        {for base-pane key i in base-panes do
            {if self.max-cols == 0 or i < self.max-cols then
                set base-pane.pane-group = self
                {self.add-pane base-pane}
                {if base-pane.percent == -1 then
                    {sizes.append 1 / base-panes.size}
                 else
                    {sizes.append base-pane.percent}
                }
            }
        }
        {self.set-pane-sizes sizes}
     elseif self.max-cols == 1 then
        || vertical
        set self.pw = {PanedWindow orientation = Orientation.vertical}
        {for base-pane key i in base-panes do
            {if self.max-rows == 0 or i < self.max-rows then
                set base-pane.pane-group = self
                {self.add-pane base-pane}
                {sizes.append base-pane.percent}
                {if base-pane.percent == -1 then
                    {sizes.append 1 / base-panes.size}
                 else
                    {sizes.append base-pane.percent}
                }
            }
        }
        {self.set-pane-sizes sizes}
     else
        || tabular
        || TODO: Handle the tabular case (i.e., when max-rows & max-cols != 1)
        set self.pw = {PanedWindow orientation = Orientation.vertical}
        {for base-pane in base-panes do
            set base-pane.pane-group = self
            {self.add-pane base-pane}
            {sizes.append base-pane.percent}
        }
        {self.set-pane-sizes sizes}
    }
    {self.add self.pw}

    set self.percent = percent
||--    set self.orientation = orientation
  }

  {getter public sealed {size}:int
    {return {self.pw.pane-count}}
  }

  {getter package {drag-view-divisor}:int
    {return
        3
|| TODO: Orientation might not be a valid thing to check
||--        {if self.orientation == Orientation.horizontal then
||--            self.size + 1
||--         else
||--            3
||--        }
    }
  }

  {getter public {orientation}:Orientation
    {return
        {if self.max-rows == 1 then Orientation.horizontal
         elseif self.max-cols == 1 then Orientation.vertical
         else || TODO:
            Orientation.vertical}}
  }

  {method package {get-percent pane:BasePane}:double
    def my-index = {self.find pane}
    let my-size:double
    let sum:double = 0.0
    {for i = 0 below self.size do
        def rect = {{self.get-pane i}.layout.get-cell-bounds}
        def size =
            {if self.orientation == Orientation.horizontal then
                rect.width / 1m
             else
                rect.height / 1m
            }
        {if i == my-index then
            set my-size = size
        }
        set sum = sum + size
    }
    {if sum == 0.0 then
        {return 0.0}
     else
        {return my-size / sum}
    }
  }

  {method private {get-pane-sizes}:{Array-of double}
    let sizes:{Array-of double} = 
        {new {Array-of double}.from-size, self.size, 0.0}
    {for i = 0 below sizes.size do
        set sizes[i] = {{self.get-pane i}.get-stretchiness}
    }
    {return sizes}
  }

  {method public {set-pane-sizes sizes:{Array-of double}}:void
|| TODO: Is this still necessary?
|| TODO: Implement the methods that used to come with PanedWindow
    {self.pw.set-pane-sizes sizes}
  }

|| TODO: Is returning only BasePanes too restrictive?
  {method public {get index:int}:#BasePane
|| TODO: Implement the methods that used to come with PanedWindow
    {return {self.pw.get index} asa #BasePane}
  }

  {method public {get-pane index:int}:#Pane
|| TODO: Implement the methods that used to come with PanedWindow
    {return {self.pw.get-pane index}}
  }

  {method public {find child:any}:int
|| TODO: Implement the methods that used to come with PanedWindow
    {return {self.pw.find child}}
  }

  {method protected {insert-pane
                        pane:SinglePane,
||--                        orientation:Orientation = Orientation.vertical,
                        at-top-or-left?:bool = false
                    }:void
|| TODO: Handle the removal of orientation

||--    {if self.orientation != orientation then
||--        let new-parent:PaneGroup =
||--            {TiledPaneGroup orientation = orientation, percent = 1.0}
||--        {self.replace-with new-parent}
||--        set self.pane-group = new-parent
||--        set self.percent = .67
||--        set pane.pane-group = new-parent
||--        set pane.percent = .33
||--        {if at-top-or-left? then
||--            {new-parent.add-pane-and-resize pane, 0}
||--            {new-parent.add-pane-and-resize self, 1}
||--         else
||--            {new-parent.add-pane-and-resize self, 0}
||--            {new-parent.add-pane-and-resize pane, 1}
||--        }
||--     else
        {self.add-pane-and-resize
            pane,
            {if at-top-or-left? then 0 else self.size}
        }
||--    }
  }

  {method protected {insert-pane-in-target
                        pane:SinglePane,
                        target:SinglePane,
||--                        orientation:Orientation = Orientation.vertical,
                        at-top-or-left?:bool = false
                    }:void
|| TODO: Handle the removal of orientation

||--    {if self.orientation != orientation then
||--        let new-parent:PaneGroup =
||--            {TiledPaneGroup orientation = orientation}
||--        let index-in-parent:int = {self.find target}
||--        set new-parent.pane-group = target.pane-group
||--        set new-parent.percent = target.percent
||--        set target.pane-group = new-parent
||--        set target.percent = .67
||--        set pane.pane-group = new-parent
||--        set pane.percent = .33
||--        {self.remove-pane-and-resize index-in-parent}
||--        {self.add-pane-and-resize new-parent, index-in-parent}
||--        {if at-top-or-left? then
||--            {new-parent.add-pane-and-resize pane, 0}
||--            {new-parent.add-pane-and-resize target, 1}
||--         else
||--            {new-parent.add-pane-and-resize target, 0}
||--            {new-parent.add-pane-and-resize pane, 1}
||--        }
||--     else
        {self.add-pane-and-resize
            pane, 
            {if at-top-or-left? then
                {max {self.find target}, 0}
             else
                {self.find target} + 1}
        }
||--    }
  }

|| TODO: Is accepting only BasePanes too restrictive?
  {method public {add-pane pane:BasePane}:void
|| TODO: Implement the methods that used to come with PanedWindow
    {self.pw.add-pane pane}
    {self.base-panes.append pane}
  }

|| TODO: Is accepting only BasePanes too restrictive?
  {method public {add-pane-at-index pane:BasePane, index:int}:void
|| TODO: Implement the methods that used to come with PanedWindow
    {self.pw.add-pane-at-index pane, index}
    {if index >= 0 and index < self.base-panes.size then
        {self.base-panes.insert pane, index}
     else
        {self.base-panes.append pane}
    }
  }

  {method public sealed {add-pane-and-resize
                            pane:BasePane,
                            index:int
                        }:void
    let percent:double = 
        {if pane.pane-group == self and pane.percent >= 0.0 then 
            pane.percent 
         else 
            1 / (self.size + 1)
        }
    || This can happen if there was one element in a pane group. In this case
    || its size is not really meaningful.
    {if percent >= .99 then
        set percent = 0.5
    }
    let sizes:{Array-of double} = {self.get-pane-sizes}
    let sum:double = 0.0
    {if sizes.empty? then
        set sum = 1.0
     else
        {for size in sizes do
            set sum = sum + size
        }
    }
    {for i = 0 below sizes.size do
        set sizes[i] = sizes[i] * (1 - percent) / sum
    }
    {sizes.insert percent, index}
    {self.add-pane-at-index pane, index}
    {self.set-pane-sizes sizes}
    {if index >= 0 and index < self.base-panes.size then
        {self.base-panes.insert pane, index}
     else
        {self.base-panes.append pane}
    }
  }

  {method protected {swap-panes my-pane:SinglePane, other-pane:SinglePane}:void
    def my-index = {self.find my-pane}
    def other-pg = {get-parent-pane-group other-pane}
    def other-index = {other-pg.find other-pane}

    def other-percent =
        {type-switch other-pg
         case tpg:TiledPaneGroup do
            {tpg.get-pane-sizes}[other-index]
         else
            -1.0
        }
    def my-percent = {self.get-pane-sizes}[my-index]
    set other-pane.pane-group = self
    set other-pane.percent = my-percent
    set my-pane.pane-group = other-pg
    set my-pane.percent = other-percent

    {self.remove-pane-and-resize my-index}
    {other-pg.remove-pane-and-resize other-index}
    {self.add-pane-and-resize other-pane, my-index}
    {other-pg.add-pane-and-resize my-pane, other-index}

    {my-pane.mark-as-docked}
    {other-pane.mark-as-docked}
  }

|| TODO: Is returning only BasePanes too restrictive?
  {method public {remove-pane-at-index index:int}:#BasePane
|| TODO: Implement the methods that used to come with PanedWindow
    {if index < 0 or index >= self.base-panes.size then
        {return null}
    }
    {self.base-panes.remove index}
    {return {self.pw.remove-pane-at-index index} asa #BasePane}
  }

  {method public sealed {remove-pane-and-resize index:int}:void
    {if index < 0 or index >= self.base-panes.size then
        {return}
    }
    let sizes:{Array-of double} = {self.get-pane-sizes}
    let sum:double = 0.0
    {for size in sizes do
        set sum = sum + size
    }
    let removed:double = sizes[index]
    {sizes.remove index}
    {for i = 0 below sizes.size do
        set sizes[i] = sizes[i] / (sum - removed)
    }
    {self.remove-pane-at-index index}
    {self.set-pane-sizes sizes}
  }

  {method package {save-state out:TextOutputStream}:void
    || Check if we are the top-level group
    {if {get-parent-pane-group-or-null self} != null then
        set (self.pane-group, self.percent) = {self.compute-percentage}
     else
        set self.percent = 1.0
    }
    {assert self.percent >= 0, {format "%s", self.percent}}
|| TODO: Handle the removal of orientation
||--    {format out = out, "\{pane-group orientation = %w, percent = %s",
||--        self.orientation.name, self.percent
||--    }
    {format out = out, "\n\{tiled-pane-group max-rows = %d, max-cols = %d, percent = %s",
        self.max-rows,
        self.max-cols,
        self.percent
    }
    {for i = 0 below self.size do
        {out.write-one-string ", "}
        {(self[i] asa BasePane).save-state out}
    }
    {out.write-one '\}'}
  }

  {method public {replicate invert-orientation?:bool = false}:PaneGroup
|| TODO: I think invert-orientation? goes away
|| TODO: Handle the removal of orientation
    def replica =
        {TiledPaneGroup max-rows = self.max-rows, max-cols = self.max-cols}
||--    def replica = {TiledPaneGroup orientation = self.orientation}
||--    {if invert-orientation? then
||--        set replica.orientation =
||--            {if self.orientation == Orientation.vertical then
||--                Orientation.horizontal
||--             else
||--                Orientation.vertical
||--            }
||--    }
    {return replica}
  }
}
